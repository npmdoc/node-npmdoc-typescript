<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://typescriptlang.org/">typescript (v2.2.2)</a>
</h1>
<h4>TypeScript is a language for application scale JavaScript development</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript">module typescript</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">typescript.</span>disableIncrementalParsing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">typescript.</span>localeCompareIsCorrect</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.ClassificationTypeNames">
            function <span class="apidocSignatureSpan">typescript.</span>ClassificationTypeNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.CoreServicesShimHostAdapter">
            function <span class="apidocSignatureSpan">typescript.</span>CoreServicesShimHostAdapter
            <span class="apidocSignatureSpan">(shimHost)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter">
            function <span class="apidocSignatureSpan">typescript.</span>LanguageServiceShimHostAdapter
            <span class="apidocSignatureSpan">(shimHost)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.OperationCanceledException">
            function <span class="apidocSignatureSpan">typescript.</span>OperationCanceledException
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TextChange">
            function <span class="apidocSignatureSpan">typescript.</span>TextChange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TypeScriptServicesFactory">
            function <span class="apidocSignatureSpan">typescript.</span>TypeScriptServicesFactory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.addEmitHelper">
            function <span class="apidocSignatureSpan">typescript.</span>addEmitHelper
            <span class="apidocSignatureSpan">(node, helper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.addEmitHelpers">
            function <span class="apidocSignatureSpan">typescript.</span>addEmitHelpers
            <span class="apidocSignatureSpan">(node, helpers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.addPrologueDirectives">
            function <span class="apidocSignatureSpan">typescript.</span>addPrologueDirectives
            <span class="apidocSignatureSpan">(target, source, ensureUseStrict, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.addRange">
            function <span class="apidocSignatureSpan">typescript.</span>addRange
            <span class="apidocSignatureSpan">(to, from)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.adjustExtensionPriority">
            function <span class="apidocSignatureSpan">typescript.</span>adjustExtensionPriority
            <span class="apidocSignatureSpan">(extensionPriority, supportedExtensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.aggregateTransformFlags">
            function <span class="apidocSignatureSpan">typescript.</span>aggregateTransformFlags
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.append">
            function <span class="apidocSignatureSpan">typescript.</span>append
            <span class="apidocSignatureSpan">(to, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.arrayFrom">
            function <span class="apidocSignatureSpan">typescript.</span>arrayFrom
            <span class="apidocSignatureSpan">(iterator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.arrayIsEqualTo">
            function <span class="apidocSignatureSpan">typescript.</span>arrayIsEqualTo
            <span class="apidocSignatureSpan">(array1, array2, equaler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.arrayToMap">
            function <span class="apidocSignatureSpan">typescript.</span>arrayToMap
            <span class="apidocSignatureSpan">(array, makeKey, makeValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.assign">
            function <span class="apidocSignatureSpan">typescript.</span>assign
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.binarySearch">
            function <span class="apidocSignatureSpan">typescript.</span>binarySearch
            <span class="apidocSignatureSpan">(array, value, comparer, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.bindSourceFile">
            function <span class="apidocSignatureSpan">typescript.</span>bindSourceFile
            <span class="apidocSignatureSpan">(file, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.breakIntoCharacterSpans">
            function <span class="apidocSignatureSpan">typescript.</span>breakIntoCharacterSpans
            <span class="apidocSignatureSpan">(identifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.breakIntoWordSpans">
            function <span class="apidocSignatureSpan">typescript.</span>breakIntoWordSpans
            <span class="apidocSignatureSpan">(identifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.chain">
            function <span class="apidocSignatureSpan">typescript.</span>chain
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.chainDiagnosticMessages">
            function <span class="apidocSignatureSpan">typescript.</span>chainDiagnosticMessages
            <span class="apidocSignatureSpan">(details, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.changeExtension">
            function <span class="apidocSignatureSpan">typescript.</span>changeExtension
            <span class="apidocSignatureSpan">(path, newExtension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.changesAffectModuleResolution">
            function <span class="apidocSignatureSpan">typescript.</span>changesAffectModuleResolution
            <span class="apidocSignatureSpan">(oldOptions, newOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.childIsDecorated">
            function <span class="apidocSignatureSpan">typescript.</span>childIsDecorated
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.classicNameResolver">
            function <span class="apidocSignatureSpan">typescript.</span>classicNameResolver
            <span class="apidocSignatureSpan">(moduleName, containingFile, compilerOptions, host, cache)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.climbPastPropertyAccess">
            function <span class="apidocSignatureSpan">typescript.</span>climbPastPropertyAccess
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.clone">
            function <span class="apidocSignatureSpan">typescript.</span>clone
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.cloneMap">
            function <span class="apidocSignatureSpan">typescript.</span>cloneMap
            <span class="apidocSignatureSpan">(map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.collapseRangeToEnd">
            function <span class="apidocSignatureSpan">typescript.</span>collapseRangeToEnd
            <span class="apidocSignatureSpan">(range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.collapseRangeToStart">
            function <span class="apidocSignatureSpan">typescript.</span>collapseRangeToStart
            <span class="apidocSignatureSpan">(range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.collapseTextChangeRangesAcrossMultipleVersions">
            function <span class="apidocSignatureSpan">typescript.</span>collapseTextChangeRangesAcrossMultipleVersions
            <span class="apidocSignatureSpan">(changes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.collectExternalModuleInfo">
            function <span class="apidocSignatureSpan">typescript.</span>collectExternalModuleInfo
            <span class="apidocSignatureSpan">(sourceFile, resolver, compilerOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.combinePaths">
            function <span class="apidocSignatureSpan">typescript.</span>combinePaths
            <span class="apidocSignatureSpan">(path1, path2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.compact">
            function <span class="apidocSignatureSpan">typescript.</span>compact
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.compareDataObjects">
            function <span class="apidocSignatureSpan">typescript.</span>compareDataObjects
            <span class="apidocSignatureSpan">(dst, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.compareDiagnostics">
            function <span class="apidocSignatureSpan">typescript.</span>compareDiagnostics
            <span class="apidocSignatureSpan">(d1, d2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.compareEmitHelpers">
            function <span class="apidocSignatureSpan">typescript.</span>compareEmitHelpers
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.comparePaths">
            function <span class="apidocSignatureSpan">typescript.</span>comparePaths
            <span class="apidocSignatureSpan">(a, b, currentDirectory, ignoreCase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.compareStrings">
            function <span class="apidocSignatureSpan">typescript.</span>compareStrings
            <span class="apidocSignatureSpan">(a, b, ignoreCase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.compareStringsCaseInsensitive">
            function <span class="apidocSignatureSpan">typescript.</span>compareStringsCaseInsensitive
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.compareValues">
            function <span class="apidocSignatureSpan">typescript.</span>compareValues
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.compose">
            function <span class="apidocSignatureSpan">typescript.</span>compose
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.computeCommonSourceDirectoryOfFilenames">
            function <span class="apidocSignatureSpan">typescript.</span>computeCommonSourceDirectoryOfFilenames
            <span class="apidocSignatureSpan">(fileNames, currentDirectory, getCanonicalFileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.computeLineAndCharacterOfPosition">
            function <span class="apidocSignatureSpan">typescript.</span>computeLineAndCharacterOfPosition
            <span class="apidocSignatureSpan">(lineStarts, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.computeLineStarts">
            function <span class="apidocSignatureSpan">typescript.</span>computeLineStarts
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.computePositionOfLineAndCharacter">
            function <span class="apidocSignatureSpan">typescript.</span>computePositionOfLineAndCharacter
            <span class="apidocSignatureSpan">(lineStarts, line, character)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.computeTransformFlagsForNode">
            function <span class="apidocSignatureSpan">typescript.</span>computeTransformFlagsForNode
            <span class="apidocSignatureSpan">(node, subtreeFlags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.concatenate">
            function <span class="apidocSignatureSpan">typescript.</span>concatenate
            <span class="apidocSignatureSpan">(array1, array2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.concatenateDiagnosticMessageChains">
            function <span class="apidocSignatureSpan">typescript.</span>concatenateDiagnosticMessageChains
            <span class="apidocSignatureSpan">(headChain, tailChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.contains">
            function <span class="apidocSignatureSpan">typescript.</span>contains
            <span class="apidocSignatureSpan">(array, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.containsParseError">
            function <span class="apidocSignatureSpan">typescript.</span>containsParseError
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.containsPath">
            function <span class="apidocSignatureSpan">typescript.</span>containsPath
            <span class="apidocSignatureSpan">(parent, child, currentDirectory, ignoreCase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertCompileOnSaveOptionFromJson">
            function <span class="apidocSignatureSpan">typescript.</span>convertCompileOnSaveOptionFromJson
            <span class="apidocSignatureSpan">(jsonOption, basePath, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertCompilerOptionsFromJson">
            function <span class="apidocSignatureSpan">typescript.</span>convertCompilerOptionsFromJson
            <span class="apidocSignatureSpan">(jsonOptions, basePath, configFileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertEnableAutoDiscoveryToEnable">
            function <span class="apidocSignatureSpan">typescript.</span>convertEnableAutoDiscoveryToEnable
            <span class="apidocSignatureSpan">(typeAcquisition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToArray">
            function <span class="apidocSignatureSpan">typescript.</span>convertToArray
            <span class="apidocSignatureSpan">(iterator, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToArrayAssignmentElement">
            function <span class="apidocSignatureSpan">typescript.</span>convertToArrayAssignmentElement
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToArrayAssignmentPattern">
            function <span class="apidocSignatureSpan">typescript.</span>convertToArrayAssignmentPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToAssignmentElementTarget">
            function <span class="apidocSignatureSpan">typescript.</span>convertToAssignmentElementTarget
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToAssignmentPattern">
            function <span class="apidocSignatureSpan">typescript.</span>convertToAssignmentPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToBase64">
            function <span class="apidocSignatureSpan">typescript.</span>convertToBase64
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToFunctionBody">
            function <span class="apidocSignatureSpan">typescript.</span>convertToFunctionBody
            <span class="apidocSignatureSpan">(node, multiLine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToObjectAssignmentElement">
            function <span class="apidocSignatureSpan">typescript.</span>convertToObjectAssignmentElement
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToObjectAssignmentPattern">
            function <span class="apidocSignatureSpan">typescript.</span>convertToObjectAssignmentPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertToRelativePath">
            function <span class="apidocSignatureSpan">typescript.</span>convertToRelativePath
            <span class="apidocSignatureSpan">(absoluteOrRelativePath, basePath, getCanonicalFileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.convertTypeAcquisitionFromJson">
            function <span class="apidocSignatureSpan">typescript.</span>convertTypeAcquisitionFromJson
            <span class="apidocSignatureSpan">(jsonOptions, basePath, configFileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.copyEntries">
            function <span class="apidocSignatureSpan">typescript.</span>copyEntries
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.couldStartTrivia">
            function <span class="apidocSignatureSpan">typescript.</span>couldStartTrivia
            <span class="apidocSignatureSpan">(text, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.countWhere">
            function <span class="apidocSignatureSpan">typescript.</span>countWhere
            <span class="apidocSignatureSpan">(array, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createAdd">
            function <span class="apidocSignatureSpan">typescript.</span>createAdd
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createArrayBindingPattern">
            function <span class="apidocSignatureSpan">typescript.</span>createArrayBindingPattern
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createArrayConcat">
            function <span class="apidocSignatureSpan">typescript.</span>createArrayConcat
            <span class="apidocSignatureSpan">(array, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createArrayLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>createArrayLiteral
            <span class="apidocSignatureSpan">(elements, multiLine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createArraySlice">
            function <span class="apidocSignatureSpan">typescript.</span>createArraySlice
            <span class="apidocSignatureSpan">(array, start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createArrowFunction">
            function <span class="apidocSignatureSpan">typescript.</span>createArrowFunction
            <span class="apidocSignatureSpan">(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createAsExpression">
            function <span class="apidocSignatureSpan">typescript.</span>createAsExpression
            <span class="apidocSignatureSpan">(expression, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createAssignHelper">
            function <span class="apidocSignatureSpan">typescript.</span>createAssignHelper
            <span class="apidocSignatureSpan">(context, attributesSegments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>createAssignment
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createAwait">
            function <span class="apidocSignatureSpan">typescript.</span>createAwait
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createBinary">
            function <span class="apidocSignatureSpan">typescript.</span>createBinary
            <span class="apidocSignatureSpan">(left, operator, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createBindingElement">
            function <span class="apidocSignatureSpan">typescript.</span>createBindingElement
            <span class="apidocSignatureSpan">(propertyName, dotDotDotToken, name, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createBlock">
            function <span class="apidocSignatureSpan">typescript.</span>createBlock
            <span class="apidocSignatureSpan">(statements, multiLine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createBreak">
            function <span class="apidocSignatureSpan">typescript.</span>createBreak
            <span class="apidocSignatureSpan">(label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createBundle">
            function <span class="apidocSignatureSpan">typescript.</span>createBundle
            <span class="apidocSignatureSpan">(sourceFiles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCall">
            function <span class="apidocSignatureSpan">typescript.</span>createCall
            <span class="apidocSignatureSpan">(expression, typeArguments, argumentsArray)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCallBinding">
            function <span class="apidocSignatureSpan">typescript.</span>createCallBinding
            <span class="apidocSignatureSpan">(expression, recordTempVariable, languageVersion, cacheIdentifiers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCaseBlock">
            function <span class="apidocSignatureSpan">typescript.</span>createCaseBlock
            <span class="apidocSignatureSpan">(clauses)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCaseClause">
            function <span class="apidocSignatureSpan">typescript.</span>createCaseClause
            <span class="apidocSignatureSpan">(expression, statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCatchClause">
            function <span class="apidocSignatureSpan">typescript.</span>createCatchClause
            <span class="apidocSignatureSpan">(variableDeclaration, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createClassDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>createClassDeclaration
            <span class="apidocSignatureSpan">(decorators, modifiers, name, typeParameters, heritageClauses, members)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createClassExpression">
            function <span class="apidocSignatureSpan">typescript.</span>createClassExpression
            <span class="apidocSignatureSpan">(modifiers, name, typeParameters, heritageClauses, members)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createClassifier">
            function <span class="apidocSignatureSpan">typescript.</span>createClassifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createComma">
            function <span class="apidocSignatureSpan">typescript.</span>createComma
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCommentWriter">
            function <span class="apidocSignatureSpan">typescript.</span>createCommentWriter
            <span class="apidocSignatureSpan">(printerOptions, emitPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCompilerDiagnostic">
            function <span class="apidocSignatureSpan">typescript.</span>createCompilerDiagnostic
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCompilerDiagnosticForInvalidCustomType">
            function <span class="apidocSignatureSpan">typescript.</span>createCompilerDiagnosticForInvalidCustomType
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCompilerDiagnosticFromMessageChain">
            function <span class="apidocSignatureSpan">typescript.</span>createCompilerDiagnosticFromMessageChain
            <span class="apidocSignatureSpan">(chain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createCompilerHost">
            function <span class="apidocSignatureSpan">typescript.</span>createCompilerHost
            <span class="apidocSignatureSpan">(options, setParentNodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createComputedPropertyName">
            function <span class="apidocSignatureSpan">typescript.</span>createComputedPropertyName
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createConditional">
            function <span class="apidocSignatureSpan">typescript.</span>createConditional
            <span class="apidocSignatureSpan">(condition, questionTokenOrWhenTrue, whenTrueOrWhenFalse, colonToken, whenFalse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createConstructor">
            function <span class="apidocSignatureSpan">typescript.</span>createConstructor
            <span class="apidocSignatureSpan">(decorators, modifiers, parameters, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createContinue">
            function <span class="apidocSignatureSpan">typescript.</span>createContinue
            <span class="apidocSignatureSpan">(label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createDecorator">
            function <span class="apidocSignatureSpan">typescript.</span>createDecorator
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createDefaultClause">
            function <span class="apidocSignatureSpan">typescript.</span>createDefaultClause
            <span class="apidocSignatureSpan">(statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createDelete">
            function <span class="apidocSignatureSpan">typescript.</span>createDelete
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createDiagnosticCollection">
            function <span class="apidocSignatureSpan">typescript.</span>createDiagnosticCollection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createDiagnosticForNode">
            function <span class="apidocSignatureSpan">typescript.</span>createDiagnosticForNode
            <span class="apidocSignatureSpan">(node, message, arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createDiagnosticForNodeFromMessageChain">
            function <span class="apidocSignatureSpan">typescript.</span>createDiagnosticForNodeFromMessageChain
            <span class="apidocSignatureSpan">(node, messageChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createDiagnosticForNodeInSourceFile">
            function <span class="apidocSignatureSpan">typescript.</span>createDiagnosticForNodeInSourceFile
            <span class="apidocSignatureSpan">(sourceFile, node, message, arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createDo">
            function <span class="apidocSignatureSpan">typescript.</span>createDo
            <span class="apidocSignatureSpan">(statement, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createDocumentRegistry">
            function <span class="apidocSignatureSpan">typescript.</span>createDocumentRegistry
            <span class="apidocSignatureSpan">(useCaseSensitiveFileNames, currentDirectory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createElementAccess">
            function <span class="apidocSignatureSpan">typescript.</span>createElementAccess
            <span class="apidocSignatureSpan">(expression, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createEmptyStatement">
            function <span class="apidocSignatureSpan">typescript.</span>createEmptyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createEndOfDeclarationMarker">
            function <span class="apidocSignatureSpan">typescript.</span>createEndOfDeclarationMarker
            <span class="apidocSignatureSpan">(original)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createEnumDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>createEnumDeclaration
            <span class="apidocSignatureSpan">(decorators, modifiers, name, members)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createEnumMember">
            function <span class="apidocSignatureSpan">typescript.</span>createEnumMember
            <span class="apidocSignatureSpan">(name, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExportAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>createExportAssignment
            <span class="apidocSignatureSpan">(decorators, modifiers, isExportEquals, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExportDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>createExportDeclaration
            <span class="apidocSignatureSpan">(decorators, modifiers, exportClause, moduleSpecifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExportDefault">
            function <span class="apidocSignatureSpan">typescript.</span>createExportDefault
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExportSpecifier">
            function <span class="apidocSignatureSpan">typescript.</span>createExportSpecifier
            <span class="apidocSignatureSpan">(name, propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExpressionForJsxElement">
            function <span class="apidocSignatureSpan">typescript.</span>createExpressionForJsxElement
            <span class="apidocSignatureSpan">(jsxFactoryEntity, reactNamespace, tagName, props, children, parentElement, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExpressionForObjectLiteralElementLike">
            function <span class="apidocSignatureSpan">typescript.</span>createExpressionForObjectLiteralElementLike
            <span class="apidocSignatureSpan">(node, property, receiver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExpressionForPropertyName">
            function <span class="apidocSignatureSpan">typescript.</span>createExpressionForPropertyName
            <span class="apidocSignatureSpan">(memberName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExpressionFromEntityName">
            function <span class="apidocSignatureSpan">typescript.</span>createExpressionFromEntityName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExpressionWithTypeArguments">
            function <span class="apidocSignatureSpan">typescript.</span>createExpressionWithTypeArguments
            <span class="apidocSignatureSpan">(typeArguments, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExternalModuleExport">
            function <span class="apidocSignatureSpan">typescript.</span>createExternalModuleExport
            <span class="apidocSignatureSpan">(exportName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createExternalModuleReference">
            function <span class="apidocSignatureSpan">typescript.</span>createExternalModuleReference
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createFalse">
            function <span class="apidocSignatureSpan">typescript.</span>createFalse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createFileDiagnostic">
            function <span class="apidocSignatureSpan">typescript.</span>createFileDiagnostic
            <span class="apidocSignatureSpan">(file, start, length, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createFileMap">
            function <span class="apidocSignatureSpan">typescript.</span>createFileMap
            <span class="apidocSignatureSpan">(keyMapper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createFor">
            function <span class="apidocSignatureSpan">typescript.</span>createFor
            <span class="apidocSignatureSpan">(initializer, condition, incrementor, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createForIn">
            function <span class="apidocSignatureSpan">typescript.</span>createForIn
            <span class="apidocSignatureSpan">(initializer, expression, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createForOf">
            function <span class="apidocSignatureSpan">typescript.</span>createForOf
            <span class="apidocSignatureSpan">(initializer, expression, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createFunctionApply">
            function <span class="apidocSignatureSpan">typescript.</span>createFunctionApply
            <span class="apidocSignatureSpan">(func, thisArg, argumentsExpression, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createFunctionCall">
            function <span class="apidocSignatureSpan">typescript.</span>createFunctionCall
            <span class="apidocSignatureSpan">(func, thisArg, argumentsList, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createFunctionDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>createFunctionDeclaration
            <span class="apidocSignatureSpan">(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createFunctionExpression">
            function <span class="apidocSignatureSpan">typescript.</span>createFunctionExpression
            <span class="apidocSignatureSpan">(modifiers, asteriskToken, name, typeParameters, parameters, type, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createGetAccessor">
            function <span class="apidocSignatureSpan">typescript.</span>createGetAccessor
            <span class="apidocSignatureSpan">(decorators, modifiers, name, parameters, type, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createGetCanonicalFileName">
            function <span class="apidocSignatureSpan">typescript.</span>createGetCanonicalFileName
            <span class="apidocSignatureSpan">(useCaseSensitiveFileNames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createHeritageClause">
            function <span class="apidocSignatureSpan">typescript.</span>createHeritageClause
            <span class="apidocSignatureSpan">(token, types)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createIdentifier">
            function <span class="apidocSignatureSpan">typescript.</span>createIdentifier
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createIf">
            function <span class="apidocSignatureSpan">typescript.</span>createIf
            <span class="apidocSignatureSpan">(expression, thenStatement, elseStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createImportClause">
            function <span class="apidocSignatureSpan">typescript.</span>createImportClause
            <span class="apidocSignatureSpan">(name, namedBindings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createImportDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>createImportDeclaration
            <span class="apidocSignatureSpan">(decorators, modifiers, importClause, moduleSpecifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createImportEqualsDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>createImportEqualsDeclaration
            <span class="apidocSignatureSpan">(decorators, modifiers, name, moduleReference)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createImportSpecifier">
            function <span class="apidocSignatureSpan">typescript.</span>createImportSpecifier
            <span class="apidocSignatureSpan">(propertyName, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createJsxAttribute">
            function <span class="apidocSignatureSpan">typescript.</span>createJsxAttribute
            <span class="apidocSignatureSpan">(name, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createJsxClosingElement">
            function <span class="apidocSignatureSpan">typescript.</span>createJsxClosingElement
            <span class="apidocSignatureSpan">(tagName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createJsxElement">
            function <span class="apidocSignatureSpan">typescript.</span>createJsxElement
            <span class="apidocSignatureSpan">(openingElement, children, closingElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createJsxExpression">
            function <span class="apidocSignatureSpan">typescript.</span>createJsxExpression
            <span class="apidocSignatureSpan">(expression, dotDotDotToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createJsxOpeningElement">
            function <span class="apidocSignatureSpan">typescript.</span>createJsxOpeningElement
            <span class="apidocSignatureSpan">(tagName, attributes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createJsxSelfClosingElement">
            function <span class="apidocSignatureSpan">typescript.</span>createJsxSelfClosingElement
            <span class="apidocSignatureSpan">(tagName, attributes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createJsxSpreadAttribute">
            function <span class="apidocSignatureSpan">typescript.</span>createJsxSpreadAttribute
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createLabel">
            function <span class="apidocSignatureSpan">typescript.</span>createLabel
            <span class="apidocSignatureSpan">(label, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createLanguageService">
            function <span class="apidocSignatureSpan">typescript.</span>createLanguageService
            <span class="apidocSignatureSpan">(host, documentRegistry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createLanguageServiceSourceFile">
            function <span class="apidocSignatureSpan">typescript.</span>createLanguageServiceSourceFile
            <span class="apidocSignatureSpan">(fileName, scriptSnapshot, scriptTarget, version, setNodeParents, scriptKind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createLessThan">
            function <span class="apidocSignatureSpan">typescript.</span>createLessThan
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>createLiteral
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createLogicalAnd">
            function <span class="apidocSignatureSpan">typescript.</span>createLogicalAnd
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createLogicalNot">
            function <span class="apidocSignatureSpan">typescript.</span>createLogicalNot
            <span class="apidocSignatureSpan">(operand)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createLogicalOr">
            function <span class="apidocSignatureSpan">typescript.</span>createLogicalOr
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createLoopVariable">
            function <span class="apidocSignatureSpan">typescript.</span>createLoopVariable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createMap">
            function <span class="apidocSignatureSpan">typescript.</span>createMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createMapFromTemplate">
            function <span class="apidocSignatureSpan">typescript.</span>createMapFromTemplate
            <span class="apidocSignatureSpan">(template)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createMathPow">
            function <span class="apidocSignatureSpan">typescript.</span>createMathPow
            <span class="apidocSignatureSpan">(left, right, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createMemberAccessForPropertyName">
            function <span class="apidocSignatureSpan">typescript.</span>createMemberAccessForPropertyName
            <span class="apidocSignatureSpan">(target, memberName, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createMergeDeclarationMarker">
            function <span class="apidocSignatureSpan">typescript.</span>createMergeDeclarationMarker
            <span class="apidocSignatureSpan">(original)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createMethod">
            function <span class="apidocSignatureSpan">typescript.</span>createMethod
            <span class="apidocSignatureSpan">(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createModuleBlock">
            function <span class="apidocSignatureSpan">typescript.</span>createModuleBlock
            <span class="apidocSignatureSpan">(statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createModuleDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>createModuleDeclaration
            <span class="apidocSignatureSpan">(decorators, modifiers, name, body, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createModuleResolutionCache">
            function <span class="apidocSignatureSpan">typescript.</span>createModuleResolutionCache
            <span class="apidocSignatureSpan">(currentDirectory, getCanonicalFileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createMultiMap">
            function <span class="apidocSignatureSpan">typescript.</span>createMultiMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNamedExports">
            function <span class="apidocSignatureSpan">typescript.</span>createNamedExports
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNamedImports">
            function <span class="apidocSignatureSpan">typescript.</span>createNamedImports
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNamespaceImport">
            function <span class="apidocSignatureSpan">typescript.</span>createNamespaceImport
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNew">
            function <span class="apidocSignatureSpan">typescript.</span>createNew
            <span class="apidocSignatureSpan">(expression, typeArguments, argumentsArray)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNode">
            function <span class="apidocSignatureSpan">typescript.</span>createNode
            <span class="apidocSignatureSpan">(kind, pos, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNodeArray">
            function <span class="apidocSignatureSpan">typescript.</span>createNodeArray
            <span class="apidocSignatureSpan">(elements, hasTrailingComma)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNonNullExpression">
            function <span class="apidocSignatureSpan">typescript.</span>createNonNullExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNotEmittedStatement">
            function <span class="apidocSignatureSpan">typescript.</span>createNotEmittedStatement
            <span class="apidocSignatureSpan">(original)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNull">
            function <span class="apidocSignatureSpan">typescript.</span>createNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createNumericLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>createNumericLiteral
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createObjectBindingPattern">
            function <span class="apidocSignatureSpan">typescript.</span>createObjectBindingPattern
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createObjectLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>createObjectLiteral
            <span class="apidocSignatureSpan">(properties, multiLine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createOmittedExpression">
            function <span class="apidocSignatureSpan">typescript.</span>createOmittedExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createParameter">
            function <span class="apidocSignatureSpan">typescript.</span>createParameter
            <span class="apidocSignatureSpan">(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createParen">
            function <span class="apidocSignatureSpan">typescript.</span>createParen
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createPartiallyEmittedExpression">
            function <span class="apidocSignatureSpan">typescript.</span>createPartiallyEmittedExpression
            <span class="apidocSignatureSpan">(expression, original)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createPatternMatcher">
            function <span class="apidocSignatureSpan">typescript.</span>createPatternMatcher
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createPostfix">
            function <span class="apidocSignatureSpan">typescript.</span>createPostfix
            <span class="apidocSignatureSpan">(operand, operator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createPostfixIncrement">
            function <span class="apidocSignatureSpan">typescript.</span>createPostfixIncrement
            <span class="apidocSignatureSpan">(operand)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createPrefix">
            function <span class="apidocSignatureSpan">typescript.</span>createPrefix
            <span class="apidocSignatureSpan">(operator, operand)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createPrinter">
            function <span class="apidocSignatureSpan">typescript.</span>createPrinter
            <span class="apidocSignatureSpan">(printerOptions, handlers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createProgram">
            function <span class="apidocSignatureSpan">typescript.</span>createProgram
            <span class="apidocSignatureSpan">(rootNames, options, host, oldProgram)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createProperty">
            function <span class="apidocSignatureSpan">typescript.</span>createProperty
            <span class="apidocSignatureSpan">(decorators, modifiers, name, questionToken, type, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createPropertyAccess">
            function <span class="apidocSignatureSpan">typescript.</span>createPropertyAccess
            <span class="apidocSignatureSpan">(expression, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createPropertyAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>createPropertyAssignment
            <span class="apidocSignatureSpan">(name, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createQualifiedName">
            function <span class="apidocSignatureSpan">typescript.</span>createQualifiedName
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createRange">
            function <span class="apidocSignatureSpan">typescript.</span>createRange
            <span class="apidocSignatureSpan">(pos, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createReturn">
            function <span class="apidocSignatureSpan">typescript.</span>createReturn
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createScanner">
            function <span class="apidocSignatureSpan">typescript.</span>createScanner
            <span class="apidocSignatureSpan">(languageVersion, skipTrivia, languageVariant, text, onError, start, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createSetAccessor">
            function <span class="apidocSignatureSpan">typescript.</span>createSetAccessor
            <span class="apidocSignatureSpan">(decorators, modifiers, name, parameters, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createShorthandPropertyAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>createShorthandPropertyAssignment
            <span class="apidocSignatureSpan">(name, objectAssignmentInitializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createSourceFile">
            function <span class="apidocSignatureSpan">typescript.</span>createSourceFile
            <span class="apidocSignatureSpan">(fileName, sourceText, languageVersion, setParentNodes, scriptKind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createSourceMapWriter">
            function <span class="apidocSignatureSpan">typescript.</span>createSourceMapWriter
            <span class="apidocSignatureSpan">(host, writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createSpread">
            function <span class="apidocSignatureSpan">typescript.</span>createSpread
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createSpreadAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>createSpreadAssignment
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createStatement">
            function <span class="apidocSignatureSpan">typescript.</span>createStatement
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createStrictEquality">
            function <span class="apidocSignatureSpan">typescript.</span>createStrictEquality
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createStrictInequality">
            function <span class="apidocSignatureSpan">typescript.</span>createStrictInequality
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createSubtract">
            function <span class="apidocSignatureSpan">typescript.</span>createSubtract
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createSuper">
            function <span class="apidocSignatureSpan">typescript.</span>createSuper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createSwitch">
            function <span class="apidocSignatureSpan">typescript.</span>createSwitch
            <span class="apidocSignatureSpan">(expression, caseBlock)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTaggedTemplate">
            function <span class="apidocSignatureSpan">typescript.</span>createTaggedTemplate
            <span class="apidocSignatureSpan">(tag, template)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTempVariable">
            function <span class="apidocSignatureSpan">typescript.</span>createTempVariable
            <span class="apidocSignatureSpan">(recordTempVariable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTemplateExpression">
            function <span class="apidocSignatureSpan">typescript.</span>createTemplateExpression
            <span class="apidocSignatureSpan">(head, templateSpans)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTemplateSpan">
            function <span class="apidocSignatureSpan">typescript.</span>createTemplateSpan
            <span class="apidocSignatureSpan">(expression, literal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTextChangeRange">
            function <span class="apidocSignatureSpan">typescript.</span>createTextChangeRange
            <span class="apidocSignatureSpan">(span, newLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTextSpan">
            function <span class="apidocSignatureSpan">typescript.</span>createTextSpan
            <span class="apidocSignatureSpan">(start, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTextSpanFromBounds">
            function <span class="apidocSignatureSpan">typescript.</span>createTextSpanFromBounds
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTextSpanFromNode">
            function <span class="apidocSignatureSpan">typescript.</span>createTextSpanFromNode
            <span class="apidocSignatureSpan">(node, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTextWriter">
            function <span class="apidocSignatureSpan">typescript.</span>createTextWriter
            <span class="apidocSignatureSpan">(newLine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createThis">
            function <span class="apidocSignatureSpan">typescript.</span>createThis
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createThrow">
            function <span class="apidocSignatureSpan">typescript.</span>createThrow
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createToken">
            function <span class="apidocSignatureSpan">typescript.</span>createToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTokenRange">
            function <span class="apidocSignatureSpan">typescript.</span>createTokenRange
            <span class="apidocSignatureSpan">(pos, token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTrue">
            function <span class="apidocSignatureSpan">typescript.</span>createTrue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTry">
            function <span class="apidocSignatureSpan">typescript.</span>createTry
            <span class="apidocSignatureSpan">(tryBlock, catchClause, finallyBlock)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTypeAssertion">
            function <span class="apidocSignatureSpan">typescript.</span>createTypeAssertion
            <span class="apidocSignatureSpan">(type, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTypeCheck">
            function <span class="apidocSignatureSpan">typescript.</span>createTypeCheck
            <span class="apidocSignatureSpan">(value, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTypeChecker">
            function <span class="apidocSignatureSpan">typescript.</span>createTypeChecker
            <span class="apidocSignatureSpan">(host, produceDiagnostics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createTypeOf">
            function <span class="apidocSignatureSpan">typescript.</span>createTypeOf
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createUniqueName">
            function <span class="apidocSignatureSpan">typescript.</span>createUniqueName
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createVariableDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>createVariableDeclaration
            <span class="apidocSignatureSpan">(name, type, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createVariableDeclarationList">
            function <span class="apidocSignatureSpan">typescript.</span>createVariableDeclarationList
            <span class="apidocSignatureSpan">(declarations, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createVariableStatement">
            function <span class="apidocSignatureSpan">typescript.</span>createVariableStatement
            <span class="apidocSignatureSpan">(modifiers, declarationList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createVoid">
            function <span class="apidocSignatureSpan">typescript.</span>createVoid
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createVoidZero">
            function <span class="apidocSignatureSpan">typescript.</span>createVoidZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createWhile">
            function <span class="apidocSignatureSpan">typescript.</span>createWhile
            <span class="apidocSignatureSpan">(expression, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createWith">
            function <span class="apidocSignatureSpan">typescript.</span>createWith
            <span class="apidocSignatureSpan">(expression, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.createYield">
            function <span class="apidocSignatureSpan">typescript.</span>createYield
            <span class="apidocSignatureSpan">(asteriskTokenOrExpression, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.declarationNameToString">
            function <span class="apidocSignatureSpan">typescript.</span>declarationNameToString
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.decodedTextSpanIntersectsWith">
            function <span class="apidocSignatureSpan">typescript.</span>decodedTextSpanIntersectsWith
            <span class="apidocSignatureSpan">(start1, length1, start2, length2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.deduplicate">
            function <span class="apidocSignatureSpan">typescript.</span>deduplicate
            <span class="apidocSignatureSpan">(array, areEqual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.deduplicateSortedDiagnostics">
            function <span class="apidocSignatureSpan">typescript.</span>deduplicateSortedDiagnostics
            <span class="apidocSignatureSpan">(diagnostics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.directoryProbablyExists">
            function <span class="apidocSignatureSpan">typescript.</span>directoryProbablyExists
            <span class="apidocSignatureSpan">(directoryName, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.displayPart">
            function <span class="apidocSignatureSpan">typescript.</span>displayPart
            <span class="apidocSignatureSpan">(text, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.displayPartsToString">
            function <span class="apidocSignatureSpan">typescript.</span>displayPartsToString
            <span class="apidocSignatureSpan">(displayParts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.disposeEmitNodes">
            function <span class="apidocSignatureSpan">typescript.</span>disposeEmitNodes
            <span class="apidocSignatureSpan">(sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.emitComments">
            function <span class="apidocSignatureSpan">typescript.</span>emitComments
            <span class="apidocSignatureSpan">(text, lineMap, writer, comments, leadingSeparator, trailingSeparator, newLine, writeComment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.emitDetachedComments">
            function <span class="apidocSignatureSpan">typescript.</span>emitDetachedComments
            <span class="apidocSignatureSpan">(text, lineMap, writer, writeComment, node, newLine, removeComments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.emitFiles">
            function <span class="apidocSignatureSpan">typescript.</span>emitFiles
            <span class="apidocSignatureSpan">(resolver, host, targetSourceFile, emitOnlyDtsFiles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.emitNewLineBeforeLeadingCommentOfPosition">
            function <span class="apidocSignatureSpan">typescript.</span>emitNewLineBeforeLeadingCommentOfPosition
            <span class="apidocSignatureSpan">(lineMap, writer, pos, commentPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.emitNewLineBeforeLeadingComments">
            function <span class="apidocSignatureSpan">typescript.</span>emitNewLineBeforeLeadingComments
            <span class="apidocSignatureSpan">(lineMap, writer, node, leadingComments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.emitNewLineBeforeLeadingCommentsOfPosition">
            function <span class="apidocSignatureSpan">typescript.</span>emitNewLineBeforeLeadingCommentsOfPosition
            <span class="apidocSignatureSpan">(lineMap, writer, pos, leadingComments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.endsWith">
            function <span class="apidocSignatureSpan">typescript.</span>endsWith
            <span class="apidocSignatureSpan">(str, suffix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.ensureScriptKind">
            function <span class="apidocSignatureSpan">typescript.</span>ensureScriptKind
            <span class="apidocSignatureSpan">(fileName, scriptKind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.ensureTrailingDirectorySeparator">
            function <span class="apidocSignatureSpan">typescript.</span>ensureTrailingDirectorySeparator
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.ensureUseStrict">
            function <span class="apidocSignatureSpan">typescript.</span>ensureUseStrict
            <span class="apidocSignatureSpan">(statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.entityNameToString">
            function <span class="apidocSignatureSpan">typescript.</span>entityNameToString
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.equalOwnProperties">
            function <span class="apidocSignatureSpan">typescript.</span>equalOwnProperties
            <span class="apidocSignatureSpan">(left, right, equalityComparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.escapeIdentifier">
            function <span class="apidocSignatureSpan">typescript.</span>escapeIdentifier
            <span class="apidocSignatureSpan">(identifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.escapeNonAsciiCharacters">
            function <span class="apidocSignatureSpan">typescript.</span>escapeNonAsciiCharacters
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.escapeString">
            function <span class="apidocSignatureSpan">typescript.</span>escapeString
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.every">
            function <span class="apidocSignatureSpan">typescript.</span>every
            <span class="apidocSignatureSpan">(array, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.exportAssignmentIsAlias">
            function <span class="apidocSignatureSpan">typescript.</span>exportAssignmentIsAlias
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.extend">
            function <span class="apidocSignatureSpan">typescript.</span>extend
            <span class="apidocSignatureSpan">(first, second)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.extensionFromPath">
            function <span class="apidocSignatureSpan">typescript.</span>extensionFromPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.extensionIsTypeScript">
            function <span class="apidocSignatureSpan">typescript.</span>extensionIsTypeScript
            <span class="apidocSignatureSpan">(ext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.fileExtensionIs">
            function <span class="apidocSignatureSpan">typescript.</span>fileExtensionIs
            <span class="apidocSignatureSpan">(path, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.fileExtensionIsAny">
            function <span class="apidocSignatureSpan">typescript.</span>fileExtensionIsAny
            <span class="apidocSignatureSpan">(path, extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.filter">
            function <span class="apidocSignatureSpan">typescript.</span>filter
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.filterMutate">
            function <span class="apidocSignatureSpan">typescript.</span>filterMutate
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.find">
            function <span class="apidocSignatureSpan">typescript.</span>find
            <span class="apidocSignatureSpan">(array, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findBestPatternMatch">
            function <span class="apidocSignatureSpan">typescript.</span>findBestPatternMatch
            <span class="apidocSignatureSpan">(values, getPattern, candidate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findChildOfKind">
            function <span class="apidocSignatureSpan">typescript.</span>findChildOfKind
            <span class="apidocSignatureSpan">(n, kind, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findConfigFile">
            function <span class="apidocSignatureSpan">typescript.</span>findConfigFile
            <span class="apidocSignatureSpan">(searchPath, fileExists, configName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findContainingList">
            function <span class="apidocSignatureSpan">typescript.</span>findContainingList
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findIndex">
            function <span class="apidocSignatureSpan">typescript.</span>findIndex
            <span class="apidocSignatureSpan">(array, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findListItemInfo">
            function <span class="apidocSignatureSpan">typescript.</span>findListItemInfo
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findMap">
            function <span class="apidocSignatureSpan">typescript.</span>findMap
            <span class="apidocSignatureSpan">(array, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findNextToken">
            function <span class="apidocSignatureSpan">typescript.</span>findNextToken
            <span class="apidocSignatureSpan">(previousToken, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findPrecedingToken">
            function <span class="apidocSignatureSpan">typescript.</span>findPrecedingToken
            <span class="apidocSignatureSpan">(position, sourceFile, startNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.findTokenOnLeftOfPosition">
            function <span class="apidocSignatureSpan">typescript.</span>findTokenOnLeftOfPosition
            <span class="apidocSignatureSpan">(file, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.firstOrUndefined">
            function <span class="apidocSignatureSpan">typescript.</span>firstOrUndefined
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.flatMap">
            function <span class="apidocSignatureSpan">typescript.</span>flatMap
            <span class="apidocSignatureSpan">(array, mapfn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.flatten">
            function <span class="apidocSignatureSpan">typescript.</span>flatten
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.flattenDestructuringAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>flattenDestructuringAssignment
            <span class="apidocSignatureSpan">(node, visitor, context, level, needsValue, createAssignmentCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.flattenDestructuringBinding">
            function <span class="apidocSignatureSpan">typescript.</span>flattenDestructuringBinding
            <span class="apidocSignatureSpan">(node, visitor, context, level, rval, hoistTempVariables, skipInitializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.flattenDiagnosticMessageText">
            function <span class="apidocSignatureSpan">typescript.</span>flattenDiagnosticMessageText
            <span class="apidocSignatureSpan">(messageText, newLine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.forEach">
            function <span class="apidocSignatureSpan">typescript.</span>forEach
            <span class="apidocSignatureSpan">(array, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.forEachChild">
            function <span class="apidocSignatureSpan">typescript.</span>forEachChild
            <span class="apidocSignatureSpan">(node, cbNode, cbNodeArray)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.forEachEmittedFile">
            function <span class="apidocSignatureSpan">typescript.</span>forEachEmittedFile
            <span class="apidocSignatureSpan">(host, action, sourceFilesOrTargetSourceFile, emitOnlyDtsFiles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.forEachEntry">
            function <span class="apidocSignatureSpan">typescript.</span>forEachEntry
            <span class="apidocSignatureSpan">(map, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.forEachKey">
            function <span class="apidocSignatureSpan">typescript.</span>forEachKey
            <span class="apidocSignatureSpan">(map, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.forEachLeadingCommentRange">
            function <span class="apidocSignatureSpan">typescript.</span>forEachLeadingCommentRange
            <span class="apidocSignatureSpan">(text, pos, cb, state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.forEachReturnStatement">
            function <span class="apidocSignatureSpan">typescript.</span>forEachReturnStatement
            <span class="apidocSignatureSpan">(body, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.forEachTrailingCommentRange">
            function <span class="apidocSignatureSpan">typescript.</span>forEachTrailingCommentRange
            <span class="apidocSignatureSpan">(text, pos, cb, state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.forEachYieldExpression">
            function <span class="apidocSignatureSpan">typescript.</span>forEachYieldExpression
            <span class="apidocSignatureSpan">(body, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatDiagnostics">
            function <span class="apidocSignatureSpan">typescript.</span>formatDiagnostics
            <span class="apidocSignatureSpan">(diagnostics, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatMessage">
            function <span class="apidocSignatureSpan">typescript.</span>formatMessage
            <span class="apidocSignatureSpan">(_dummy, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatStringFromArgs">
            function <span class="apidocSignatureSpan">typescript.</span>formatStringFromArgs
            <span class="apidocSignatureSpan">(text, args, baseIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatSyntaxKind">
            function <span class="apidocSignatureSpan">typescript.</span>formatSyntaxKind
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.FormattingContext
            <span class="apidocSignatureSpan">(sourceFile, formattingRequestKind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rule">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.Rule
            <span class="apidocSignatureSpan">(Descriptor, Operation, Flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleDescriptor">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.RuleDescriptor
            <span class="apidocSignatureSpan">(LeftTokenRange, RightTokenRange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperation">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.RuleOperation
            <span class="apidocSignatureSpan">(Context, Action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperationContext">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.RuleOperationContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.Rules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucket">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.RulesBucket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucketConstructionState">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.RulesBucketConstructionState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesMap">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.RulesMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesProvider">
            function <span class="apidocSignatureSpan">typescript.</span>formatting.RulesProvider
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.generateTSConfig">
            function <span class="apidocSignatureSpan">typescript.</span>generateTSConfig
            <span class="apidocSignatureSpan">(options, fileNames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getAllAccessorDeclarations">
            function <span class="apidocSignatureSpan">typescript.</span>getAllAccessorDeclarations
            <span class="apidocSignatureSpan">(declarations, accessor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getAncestor">
            function <span class="apidocSignatureSpan">typescript.</span>getAncestor
            <span class="apidocSignatureSpan">(node, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getAssignmentTargetKind">
            function <span class="apidocSignatureSpan">typescript.</span>getAssignmentTargetKind
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getAutomaticTypeDirectiveNames">
            function <span class="apidocSignatureSpan">typescript.</span>getAutomaticTypeDirectiveNames
            <span class="apidocSignatureSpan">(options, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getBaseFileName">
            function <span class="apidocSignatureSpan">typescript.</span>getBaseFileName
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getClassExtendsHeritageClauseElement">
            function <span class="apidocSignatureSpan">typescript.</span>getClassExtendsHeritageClauseElement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getClassImplementsHeritageClauseElements">
            function <span class="apidocSignatureSpan">typescript.</span>getClassImplementsHeritageClauseElements
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getCombinedModifierFlags">
            function <span class="apidocSignatureSpan">typescript.</span>getCombinedModifierFlags
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getCombinedNodeFlags">
            function <span class="apidocSignatureSpan">typescript.</span>getCombinedNodeFlags
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getCommentRange">
            function <span class="apidocSignatureSpan">typescript.</span>getCommentRange
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getCommentsFromJSDoc">
            function <span class="apidocSignatureSpan">typescript.</span>getCommentsFromJSDoc
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getConstantValue">
            function <span class="apidocSignatureSpan">typescript.</span>getConstantValue
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getContainerNode">
            function <span class="apidocSignatureSpan">typescript.</span>getContainerNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getContainingClass">
            function <span class="apidocSignatureSpan">typescript.</span>getContainingClass
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getContainingFunction">
            function <span class="apidocSignatureSpan">typescript.</span>getContainingFunction
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getDeclarationDiagnostics">
            function <span class="apidocSignatureSpan">typescript.</span>getDeclarationDiagnostics
            <span class="apidocSignatureSpan">(host, resolver, targetSourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getDeclarationEmitOutputFilePath">
            function <span class="apidocSignatureSpan">typescript.</span>getDeclarationEmitOutputFilePath
            <span class="apidocSignatureSpan">(sourceFile, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getDeclarationName">
            function <span class="apidocSignatureSpan">typescript.</span>getDeclarationName
            <span class="apidocSignatureSpan">(node, allowComments, allowSourceMaps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getDeclarationOfKind">
            function <span class="apidocSignatureSpan">typescript.</span>getDeclarationOfKind
            <span class="apidocSignatureSpan">(symbol, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getDeclaredName">
            function <span class="apidocSignatureSpan">typescript.</span>getDeclaredName
            <span class="apidocSignatureSpan">(typeChecker, symbol, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getDefaultCompilerOptions">
            function <span class="apidocSignatureSpan">typescript.</span>getDefaultCompilerOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getDefaultLibFileName">
            function <span class="apidocSignatureSpan">typescript.</span>getDefaultLibFileName
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getDefaultLibFilePath">
            function <span class="apidocSignatureSpan">typescript.</span>getDefaultLibFilePath
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getDirectoryPath">
            function <span class="apidocSignatureSpan">typescript.</span>getDirectoryPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEffectiveTypeRoots">
            function <span class="apidocSignatureSpan">typescript.</span>getEffectiveTypeRoots
            <span class="apidocSignatureSpan">(options, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getElementsOfBindingOrAssignmentPattern">
            function <span class="apidocSignatureSpan">typescript.</span>getElementsOfBindingOrAssignmentPattern
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEmitFlags">
            function <span class="apidocSignatureSpan">typescript.</span>getEmitFlags
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEmitHelpers">
            function <span class="apidocSignatureSpan">typescript.</span>getEmitHelpers
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEmitModuleKind">
            function <span class="apidocSignatureSpan">typescript.</span>getEmitModuleKind
            <span class="apidocSignatureSpan">(compilerOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEmitModuleResolutionKind">
            function <span class="apidocSignatureSpan">typescript.</span>getEmitModuleResolutionKind
            <span class="apidocSignatureSpan">(compilerOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEmitScriptTarget">
            function <span class="apidocSignatureSpan">typescript.</span>getEmitScriptTarget
            <span class="apidocSignatureSpan">(compilerOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEnclosingBlockScopeContainer">
            function <span class="apidocSignatureSpan">typescript.</span>getEnclosingBlockScopeContainer
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEncodedSemanticClassifications">
            function <span class="apidocSignatureSpan">typescript.</span>getEncodedSemanticClassifications
            <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFile, classifiableNames, span)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEncodedSyntacticClassifications">
            function <span class="apidocSignatureSpan">typescript.</span>getEncodedSyntacticClassifications
            <span class="apidocSignatureSpan">(cancellationToken, sourceFile, span)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEndLinePosition">
            function <span class="apidocSignatureSpan">typescript.</span>getEndLinePosition
            <span class="apidocSignatureSpan">(line, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getEntityNameFromTypeNode">
            function <span class="apidocSignatureSpan">typescript.</span>getEntityNameFromTypeNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getErrorSpanForNode">
            function <span class="apidocSignatureSpan">typescript.</span>getErrorSpanForNode
            <span class="apidocSignatureSpan">(sourceFile, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExportName">
            function <span class="apidocSignatureSpan">typescript.</span>getExportName
            <span class="apidocSignatureSpan">(node, allowComments, allowSourceMaps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExpressionAssociativity">
            function <span class="apidocSignatureSpan">typescript.</span>getExpressionAssociativity
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExpressionPrecedence">
            function <span class="apidocSignatureSpan">typescript.</span>getExpressionPrecedence
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExtensionPriority">
            function <span class="apidocSignatureSpan">typescript.</span>getExtensionPriority
            <span class="apidocSignatureSpan">(path, supportedExtensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExternalHelpersModuleName">
            function <span class="apidocSignatureSpan">typescript.</span>getExternalHelpersModuleName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExternalModuleImportEqualsDeclarationExpression">
            function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleImportEqualsDeclarationExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExternalModuleName">
            function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExternalModuleNameFromDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleNameFromDeclaration
            <span class="apidocSignatureSpan">(host, resolver, declaration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExternalModuleNameFromPath">
            function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleNameFromPath
            <span class="apidocSignatureSpan">(host, fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExternalModuleNameLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleNameLiteral
            <span class="apidocSignatureSpan">(importNode, sourceFile, host, resolver, compilerOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getExternalModuleOrNamespaceExportName">
            function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleOrNamespaceExportName
            <span class="apidocSignatureSpan">(ns, node, allowComments, allowSourceMaps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getFileMatcherPatterns">
            function <span class="apidocSignatureSpan">typescript.</span>getFileMatcherPatterns
            <span class="apidocSignatureSpan">(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getFileReferenceFromReferencePath">
            function <span class="apidocSignatureSpan">typescript.</span>getFileReferenceFromReferencePath
            <span class="apidocSignatureSpan">(comment, commentRange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getFirstConstructorWithBody">
            function <span class="apidocSignatureSpan">typescript.</span>getFirstConstructorWithBody
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getFullWidth">
            function <span class="apidocSignatureSpan">typescript.</span>getFullWidth
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getGeneratedNameForNode">
            function <span class="apidocSignatureSpan">typescript.</span>getGeneratedNameForNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getHelperName">
            function <span class="apidocSignatureSpan">typescript.</span>getHelperName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getHeritageClause">
            function <span class="apidocSignatureSpan">typescript.</span>getHeritageClause
            <span class="apidocSignatureSpan">(clauses, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getImmediatelyInvokedFunctionExpression">
            function <span class="apidocSignatureSpan">typescript.</span>getImmediatelyInvokedFunctionExpression
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getIndentSize">
            function <span class="apidocSignatureSpan">typescript.</span>getIndentSize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getIndentString">
            function <span class="apidocSignatureSpan">typescript.</span>getIndentString
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getInitializedVariables">
            function <span class="apidocSignatureSpan">typescript.</span>getInitializedVariables
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getInitializerOfBindingOrAssignmentElement">
            function <span class="apidocSignatureSpan">typescript.</span>getInitializerOfBindingOrAssignmentElement
            <span class="apidocSignatureSpan">(bindingElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getInterfaceBaseTypeNodes">
            function <span class="apidocSignatureSpan">typescript.</span>getInterfaceBaseTypeNodes
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getInvokedExpression">
            function <span class="apidocSignatureSpan">typescript.</span>getInvokedExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getJSDocAugmentsTag">
            function <span class="apidocSignatureSpan">typescript.</span>getJSDocAugmentsTag
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getJSDocCommentRanges">
            function <span class="apidocSignatureSpan">typescript.</span>getJSDocCommentRanges
            <span class="apidocSignatureSpan">(node, text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getJSDocParameterTags">
            function <span class="apidocSignatureSpan">typescript.</span>getJSDocParameterTags
            <span class="apidocSignatureSpan">(param)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getJSDocReturnTag">
            function <span class="apidocSignatureSpan">typescript.</span>getJSDocReturnTag
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getJSDocTemplateTag">
            function <span class="apidocSignatureSpan">typescript.</span>getJSDocTemplateTag
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getJSDocType">
            function <span class="apidocSignatureSpan">typescript.</span>getJSDocType
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getJsDocTagAtPosition">
            function <span class="apidocSignatureSpan">typescript.</span>getJsDocTagAtPosition
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLeadingCommentRanges">
            function <span class="apidocSignatureSpan">typescript.</span>getLeadingCommentRanges
            <span class="apidocSignatureSpan">(text, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLeadingCommentRangesOfNode">
            function <span class="apidocSignatureSpan">typescript.</span>getLeadingCommentRangesOfNode
            <span class="apidocSignatureSpan">(node, sourceFileOfNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLeadingCommentRangesOfNodeFromText">
            function <span class="apidocSignatureSpan">typescript.</span>getLeadingCommentRangesOfNodeFromText
            <span class="apidocSignatureSpan">(node, text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLineAndCharacterOfPosition">
            function <span class="apidocSignatureSpan">typescript.</span>getLineAndCharacterOfPosition
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLineOfLocalPosition">
            function <span class="apidocSignatureSpan">typescript.</span>getLineOfLocalPosition
            <span class="apidocSignatureSpan">(currentSourceFile, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLineOfLocalPositionFromLineMap">
            function <span class="apidocSignatureSpan">typescript.</span>getLineOfLocalPositionFromLineMap
            <span class="apidocSignatureSpan">(lineMap, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLineStartPositionForPosition">
            function <span class="apidocSignatureSpan">typescript.</span>getLineStartPositionForPosition
            <span class="apidocSignatureSpan">(position, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLineStarts">
            function <span class="apidocSignatureSpan">typescript.</span>getLineStarts
            <span class="apidocSignatureSpan">(sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLiteralText">
            function <span class="apidocSignatureSpan">typescript.</span>getLiteralText
            <span class="apidocSignatureSpan">(node, sourceFile, languageVersion)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLocalName">
            function <span class="apidocSignatureSpan">typescript.</span>getLocalName
            <span class="apidocSignatureSpan">(node, allowComments, allowSourceMaps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLocalNameForExternalImport">
            function <span class="apidocSignatureSpan">typescript.</span>getLocalNameForExternalImport
            <span class="apidocSignatureSpan">(node, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLocalSymbolForExportDefault">
            function <span class="apidocSignatureSpan">typescript.</span>getLocalSymbolForExportDefault
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getLocaleSpecificMessage">
            function <span class="apidocSignatureSpan">typescript.</span>getLocaleSpecificMessage
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getMeaningFromDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>getMeaningFromDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getMeaningFromLocation">
            function <span class="apidocSignatureSpan">typescript.</span>getMeaningFromLocation
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getModifierFlags">
            function <span class="apidocSignatureSpan">typescript.</span>getModifierFlags
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getModuleInstanceState">
            function <span class="apidocSignatureSpan">typescript.</span>getModuleInstanceState
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getMutableClone">
            function <span class="apidocSignatureSpan">typescript.</span>getMutableClone
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNameTable">
            function <span class="apidocSignatureSpan">typescript.</span>getNameTable
            <span class="apidocSignatureSpan">(sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNamespaceDeclarationNode">
            function <span class="apidocSignatureSpan">typescript.</span>getNamespaceDeclarationNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNamespaceMemberName">
            function <span class="apidocSignatureSpan">typescript.</span>getNamespaceMemberName
            <span class="apidocSignatureSpan">(ns, name, allowComments, allowSourceMaps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNewLineCharacter">
            function <span class="apidocSignatureSpan">typescript.</span>getNewLineCharacter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNewLineOrDefaultFromHost">
            function <span class="apidocSignatureSpan">typescript.</span>getNewLineOrDefaultFromHost
            <span class="apidocSignatureSpan">(host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNewTargetContainer">
            function <span class="apidocSignatureSpan">typescript.</span>getNewTargetContainer
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNextLowestExtensionPriority">
            function <span class="apidocSignatureSpan">typescript.</span>getNextLowestExtensionPriority
            <span class="apidocSignatureSpan">(extensionPriority, supportedExtensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNodeId">
            function <span class="apidocSignatureSpan">typescript.</span>getNodeId
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNodeKind">
            function <span class="apidocSignatureSpan">typescript.</span>getNodeKind
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNodeMajorVersion">
            function <span class="apidocSignatureSpan">typescript.</span>getNodeMajorVersion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNodeModifiers">
            function <span class="apidocSignatureSpan">typescript.</span>getNodeModifiers
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNonDecoratorTokenPosOfNode">
            function <span class="apidocSignatureSpan">typescript.</span>getNonDecoratorTokenPosOfNode
            <span class="apidocSignatureSpan">(node, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNormalizedAbsolutePath">
            function <span class="apidocSignatureSpan">typescript.</span>getNormalizedAbsolutePath
            <span class="apidocSignatureSpan">(fileName, currentDirectory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNormalizedPathComponents">
            function <span class="apidocSignatureSpan">typescript.</span>getNormalizedPathComponents
            <span class="apidocSignatureSpan">(path, currentDirectory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNormalizedPathFromPathComponents">
            function <span class="apidocSignatureSpan">typescript.</span>getNormalizedPathFromPathComponents
            <span class="apidocSignatureSpan">(pathComponents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getNumericLiteralFlags">
            function <span class="apidocSignatureSpan">typescript.</span>getNumericLiteralFlags
            <span class="apidocSignatureSpan">(text, hint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOpenBraceEnd">
            function <span class="apidocSignatureSpan">typescript.</span>getOpenBraceEnd
            <span class="apidocSignatureSpan">(constructor, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOperator">
            function <span class="apidocSignatureSpan">typescript.</span>getOperator
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOperatorAssociativity">
            function <span class="apidocSignatureSpan">typescript.</span>getOperatorAssociativity
            <span class="apidocSignatureSpan">(kind, operator, hasArguments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOperatorPrecedence">
            function <span class="apidocSignatureSpan">typescript.</span>getOperatorPrecedence
            <span class="apidocSignatureSpan">(nodeKind, operatorKind, hasArguments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOptionNameMap">
            function <span class="apidocSignatureSpan">typescript.</span>getOptionNameMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOrCreateEmitNode">
            function <span class="apidocSignatureSpan">typescript.</span>getOrCreateEmitNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOrCreateExternalHelpersModuleNameIfNeeded">
            function <span class="apidocSignatureSpan">typescript.</span>getOrCreateExternalHelpersModuleNameIfNeeded
            <span class="apidocSignatureSpan">(node, compilerOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOriginalNode">
            function <span class="apidocSignatureSpan">typescript.</span>getOriginalNode
            <span class="apidocSignatureSpan">(node, nodeTest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOriginalNodeId">
            function <span class="apidocSignatureSpan">typescript.</span>getOriginalNodeId
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOriginalSourceFileOrBundle">
            function <span class="apidocSignatureSpan">typescript.</span>getOriginalSourceFileOrBundle
            <span class="apidocSignatureSpan">(sourceFileOrBundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOriginalSourceFiles">
            function <span class="apidocSignatureSpan">typescript.</span>getOriginalSourceFiles
            <span class="apidocSignatureSpan">(sourceFiles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOwnEmitOutputFilePath">
            function <span class="apidocSignatureSpan">typescript.</span>getOwnEmitOutputFilePath
            <span class="apidocSignatureSpan">(sourceFile, host, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getOwnKeys">
            function <span class="apidocSignatureSpan">typescript.</span>getOwnKeys
            <span class="apidocSignatureSpan">(map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getParseTreeNode">
            function <span class="apidocSignatureSpan">typescript.</span>getParseTreeNode
            <span class="apidocSignatureSpan">(node, nodeTest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getPositionOfLineAndCharacter">
            function <span class="apidocSignatureSpan">typescript.</span>getPositionOfLineAndCharacter
            <span class="apidocSignatureSpan">(sourceFile, line, character)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getPreEmitDiagnostics">
            function <span class="apidocSignatureSpan">typescript.</span>getPreEmitDiagnostics
            <span class="apidocSignatureSpan">(program, sourceFile, cancellationToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getProperty">
            function <span class="apidocSignatureSpan">typescript.</span>getProperty
            <span class="apidocSignatureSpan">(map, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getPropertyNameForKnownSymbolName">
            function <span class="apidocSignatureSpan">typescript.</span>getPropertyNameForKnownSymbolName
            <span class="apidocSignatureSpan">(symbolName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getPropertyNameForPropertyNameNode">
            function <span class="apidocSignatureSpan">typescript.</span>getPropertyNameForPropertyNameNode
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getPropertyNameOfBindingOrAssignmentElement">
            function <span class="apidocSignatureSpan">typescript.</span>getPropertyNameOfBindingOrAssignmentElement
            <span class="apidocSignatureSpan">(bindingElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getRangeEnd">
            function <span class="apidocSignatureSpan">typescript.</span>getRangeEnd
            <span class="apidocSignatureSpan">(range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getRangePos">
            function <span class="apidocSignatureSpan">typescript.</span>getRangePos
            <span class="apidocSignatureSpan">(range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getRegularExpressionForWildcard">
            function <span class="apidocSignatureSpan">typescript.</span>getRegularExpressionForWildcard
            <span class="apidocSignatureSpan">(specs, basePath, usage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getRelativePathToDirectoryOrUrl">
            function <span class="apidocSignatureSpan">typescript.</span>getRelativePathToDirectoryOrUrl
            <span class="apidocSignatureSpan">(directoryPathOrUrl, relativeOrAbsolutePath, currentDirectory, getCanonicalFileName, isAbsolutePathAnUrl )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getResolutionDiagnostic">
            function <span class="apidocSignatureSpan">typescript.</span>getResolutionDiagnostic
            <span class="apidocSignatureSpan">(options, _a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getResolvedExternalModuleName">
            function <span class="apidocSignatureSpan">typescript.</span>getResolvedExternalModuleName
            <span class="apidocSignatureSpan">(host, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getResolvedModule">
            function <span class="apidocSignatureSpan">typescript.</span>getResolvedModule
            <span class="apidocSignatureSpan">(sourceFile, moduleNameText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getRestIndicatorOfBindingOrAssignmentElement">
            function <span class="apidocSignatureSpan">typescript.</span>getRestIndicatorOfBindingOrAssignmentElement
            <span class="apidocSignatureSpan">(bindingElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getRestParameterElementType">
            function <span class="apidocSignatureSpan">typescript.</span>getRestParameterElementType
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getRootDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>getRootDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getRootLength">
            function <span class="apidocSignatureSpan">typescript.</span>getRootLength
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getScriptKind">
            function <span class="apidocSignatureSpan">typescript.</span>getScriptKind
            <span class="apidocSignatureSpan">(fileName, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getScriptKindFromFileName">
            function <span class="apidocSignatureSpan">typescript.</span>getScriptKindFromFileName
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSemanticClassifications">
            function <span class="apidocSignatureSpan">typescript.</span>getSemanticClassifications
            <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFile, classifiableNames, span)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSetAccessorTypeAnnotationNode">
            function <span class="apidocSignatureSpan">typescript.</span>getSetAccessorTypeAnnotationNode
            <span class="apidocSignatureSpan">(accessor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getShebang">
            function <span class="apidocSignatureSpan">typescript.</span>getShebang
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSingleLineStringWriter">
            function <span class="apidocSignatureSpan">typescript.</span>getSingleLineStringWriter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSourceFileOfNode">
            function <span class="apidocSignatureSpan">typescript.</span>getSourceFileOfNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSourceFilePathInNewDir">
            function <span class="apidocSignatureSpan">typescript.</span>getSourceFilePathInNewDir
            <span class="apidocSignatureSpan">(sourceFile, host, newDirPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSourceFilesToEmit">
            function <span class="apidocSignatureSpan">typescript.</span>getSourceFilesToEmit
            <span class="apidocSignatureSpan">(host, targetSourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSourceMapRange">
            function <span class="apidocSignatureSpan">typescript.</span>getSourceMapRange
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSourceTextOfNodeFromSourceFile">
            function <span class="apidocSignatureSpan">typescript.</span>getSourceTextOfNodeFromSourceFile
            <span class="apidocSignatureSpan">(sourceFile, node, includeTrivia)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSpanOfTokenAtPosition">
            function <span class="apidocSignatureSpan">typescript.</span>getSpanOfTokenAtPosition
            <span class="apidocSignatureSpan">(sourceFile, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSpecialPropertyAssignmentKind">
            function <span class="apidocSignatureSpan">typescript.</span>getSpecialPropertyAssignmentKind
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getStartPosOfNode">
            function <span class="apidocSignatureSpan">typescript.</span>getStartPosOfNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getStartPositionOfLine">
            function <span class="apidocSignatureSpan">typescript.</span>getStartPositionOfLine
            <span class="apidocSignatureSpan">(line, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getStartPositionOfRange">
            function <span class="apidocSignatureSpan">typescript.</span>getStartPositionOfRange
            <span class="apidocSignatureSpan">(range, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getStringLiteralTypeForNode">
            function <span class="apidocSignatureSpan">typescript.</span>getStringLiteralTypeForNode
            <span class="apidocSignatureSpan">(node, typeChecker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSuperContainer">
            function <span class="apidocSignatureSpan">typescript.</span>getSuperContainer
            <span class="apidocSignatureSpan">(node, stopOnFunctions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSupportedCodeFixes">
            function <span class="apidocSignatureSpan">typescript.</span>getSupportedCodeFixes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSupportedExtensions">
            function <span class="apidocSignatureSpan">typescript.</span>getSupportedExtensions
            <span class="apidocSignatureSpan">(options, extraFileExtensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSymbolId">
            function <span class="apidocSignatureSpan">typescript.</span>getSymbolId
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSyntacticClassifications">
            function <span class="apidocSignatureSpan">typescript.</span>getSyntacticClassifications
            <span class="apidocSignatureSpan">(cancellationToken, sourceFile, span)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getSynthesizedClone">
            function <span class="apidocSignatureSpan">typescript.</span>getSynthesizedClone
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTargetLabel">
            function <span class="apidocSignatureSpan">typescript.</span>getTargetLabel
            <span class="apidocSignatureSpan">(referenceNode, labelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTargetOfBindingOrAssignmentElement">
            function <span class="apidocSignatureSpan">typescript.</span>getTargetOfBindingOrAssignmentElement
            <span class="apidocSignatureSpan">(bindingElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTextOfNode">
            function <span class="apidocSignatureSpan">typescript.</span>getTextOfNode
            <span class="apidocSignatureSpan">(node, includeTrivia)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTextOfNodeFromSourceText">
            function <span class="apidocSignatureSpan">typescript.</span>getTextOfNodeFromSourceText
            <span class="apidocSignatureSpan">(sourceText, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTextOfPropertyName">
            function <span class="apidocSignatureSpan">typescript.</span>getTextOfPropertyName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getThisContainer">
            function <span class="apidocSignatureSpan">typescript.</span>getThisContainer
            <span class="apidocSignatureSpan">(node, includeArrowFunctions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getThisParameter">
            function <span class="apidocSignatureSpan">typescript.</span>getThisParameter
            <span class="apidocSignatureSpan">(signature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTokenAtPosition">
            function <span class="apidocSignatureSpan">typescript.</span>getTokenAtPosition
            <span class="apidocSignatureSpan">(sourceFile, position, includeJsDocComment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTokenPosOfNode">
            function <span class="apidocSignatureSpan">typescript.</span>getTokenPosOfNode
            <span class="apidocSignatureSpan">(node, sourceFile, includeJsDoc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTokenSourceMapRange">
            function <span class="apidocSignatureSpan">typescript.</span>getTokenSourceMapRange
            <span class="apidocSignatureSpan">(node, token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTouchingPropertyName">
            function <span class="apidocSignatureSpan">typescript.</span>getTouchingPropertyName
            <span class="apidocSignatureSpan">(sourceFile, position, includeJsDocComment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTouchingToken">
            function <span class="apidocSignatureSpan">typescript.</span>getTouchingToken
            <span class="apidocSignatureSpan">(sourceFile, position, includeItemAtEndPosition, includeJsDocComment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTouchingWord">
            function <span class="apidocSignatureSpan">typescript.</span>getTouchingWord
            <span class="apidocSignatureSpan">(sourceFile, position, includeJsDocComment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTrailingCommentRanges">
            function <span class="apidocSignatureSpan">typescript.</span>getTrailingCommentRanges
            <span class="apidocSignatureSpan">(text, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTransformFlagsSubtreeExclusions">
            function <span class="apidocSignatureSpan">typescript.</span>getTransformFlagsSubtreeExclusions
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTransformers">
            function <span class="apidocSignatureSpan">typescript.</span>getTransformers
            <span class="apidocSignatureSpan">(compilerOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTypeArgumentOrTypeParameterList">
            function <span class="apidocSignatureSpan">typescript.</span>getTypeArgumentOrTypeParameterList
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.getTypeParameterOwner">
            function <span class="apidocSignatureSpan">typescript.</span>getTypeParameterOwner
            <span class="apidocSignatureSpan">(d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasChangesInResolutions">
            function <span class="apidocSignatureSpan">typescript.</span>hasChangesInResolutions
            <span class="apidocSignatureSpan">(names, newResolutions, oldResolutions, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasChildOfKind">
            function <span class="apidocSignatureSpan">typescript.</span>hasChildOfKind
            <span class="apidocSignatureSpan">(n, kind, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasDeclaredRestParameter">
            function <span class="apidocSignatureSpan">typescript.</span>hasDeclaredRestParameter
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasDocComment">
            function <span class="apidocSignatureSpan">typescript.</span>hasDocComment
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasDynamicName">
            function <span class="apidocSignatureSpan">typescript.</span>hasDynamicName
            <span class="apidocSignatureSpan">(declaration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasExtension">
            function <span class="apidocSignatureSpan">typescript.</span>hasExtension
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasJSDocParameterTags">
            function <span class="apidocSignatureSpan">typescript.</span>hasJSDocParameterTags
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasJavaScriptFileExtension">
            function <span class="apidocSignatureSpan">typescript.</span>hasJavaScriptFileExtension
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasModifier">
            function <span class="apidocSignatureSpan">typescript.</span>hasModifier
            <span class="apidocSignatureSpan">(node, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasModifiers">
            function <span class="apidocSignatureSpan">typescript.</span>hasModifiers
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasProperty">
            function <span class="apidocSignatureSpan">typescript.</span>hasProperty
            <span class="apidocSignatureSpan">(map, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasQuestionToken">
            function <span class="apidocSignatureSpan">typescript.</span>hasQuestionToken
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasResolvedModule">
            function <span class="apidocSignatureSpan">typescript.</span>hasResolvedModule
            <span class="apidocSignatureSpan">(sourceFile, moduleNameText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasRestParameter">
            function <span class="apidocSignatureSpan">typescript.</span>hasRestParameter
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasTrailingDirectorySeparator">
            function <span class="apidocSignatureSpan">typescript.</span>hasTrailingDirectorySeparator
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasTypeScriptFileExtension">
            function <span class="apidocSignatureSpan">typescript.</span>hasTypeScriptFileExtension
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.hasZeroOrOneAsteriskCharacter">
            function <span class="apidocSignatureSpan">typescript.</span>hasZeroOrOneAsteriskCharacter
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.identifierIsThisKeyword">
            function <span class="apidocSignatureSpan">typescript.</span>identifierIsThisKeyword
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.indexOf">
            function <span class="apidocSignatureSpan">typescript.</span>indexOf
            <span class="apidocSignatureSpan">(array, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.indexOfAnyCharCode">
            function <span class="apidocSignatureSpan">typescript.</span>indexOfAnyCharCode
            <span class="apidocSignatureSpan">(text, charCodes, start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.inlineExpressions">
            function <span class="apidocSignatureSpan">typescript.</span>inlineExpressions
            <span class="apidocSignatureSpan">(expressions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.introducesArgumentsExoticObject">
            function <span class="apidocSignatureSpan">typescript.</span>introducesArgumentsExoticObject
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAccessibilityModifier">
            function <span class="apidocSignatureSpan">typescript.</span>isAccessibilityModifier
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAccessor">
            function <span class="apidocSignatureSpan">typescript.</span>isAccessor
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAliasSymbolDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isAliasSymbolDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAmbientModule">
            function <span class="apidocSignatureSpan">typescript.</span>isAmbientModule
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isArray">
            function <span class="apidocSignatureSpan">typescript.</span>isArray
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isArrayBindingElement">
            function <span class="apidocSignatureSpan">typescript.</span>isArrayBindingElement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isArrayBindingOrAssignmentPattern">
            function <span class="apidocSignatureSpan">typescript.</span>isArrayBindingOrAssignmentPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isArrayBindingPattern">
            function <span class="apidocSignatureSpan">typescript.</span>isArrayBindingPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isArrayLiteralExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isArrayLiteralExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isArrayLiteralOrObjectLiteralDestructuringPattern">
            function <span class="apidocSignatureSpan">typescript.</span>isArrayLiteralOrObjectLiteralDestructuringPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAssertionExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isAssertionExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAssignmentExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isAssignmentExpression
            <span class="apidocSignatureSpan">(node, excludeCompoundAssignment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAssignmentOperator">
            function <span class="apidocSignatureSpan">typescript.</span>isAssignmentOperator
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAssignmentPattern">
            function <span class="apidocSignatureSpan">typescript.</span>isAssignmentPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAssignmentTarget">
            function <span class="apidocSignatureSpan">typescript.</span>isAssignmentTarget
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isAsyncFunctionLike">
            function <span class="apidocSignatureSpan">typescript.</span>isAsyncFunctionLike
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBinaryExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isBinaryExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBinaryOrOctalIntegerLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>isBinaryOrOctalIntegerLiteral
            <span class="apidocSignatureSpan">(node, text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBindingElement">
            function <span class="apidocSignatureSpan">typescript.</span>isBindingElement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBindingName">
            function <span class="apidocSignatureSpan">typescript.</span>isBindingName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBindingOrAssignmentPattern">
            function <span class="apidocSignatureSpan">typescript.</span>isBindingOrAssignmentPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBindingPattern">
            function <span class="apidocSignatureSpan">typescript.</span>isBindingPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBlock">
            function <span class="apidocSignatureSpan">typescript.</span>isBlock
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBlockOrCatchScoped">
            function <span class="apidocSignatureSpan">typescript.</span>isBlockOrCatchScoped
            <span class="apidocSignatureSpan">(declaration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBlockScope">
            function <span class="apidocSignatureSpan">typescript.</span>isBlockScope
            <span class="apidocSignatureSpan">(node, parentNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isBlockScopedContainerTopLevel">
            function <span class="apidocSignatureSpan">typescript.</span>isBlockScopedContainerTopLevel
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isCallExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isCallExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isCallExpressionTarget">
            function <span class="apidocSignatureSpan">typescript.</span>isCallExpressionTarget
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isCallLikeExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isCallLikeExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isCaseBlock">
            function <span class="apidocSignatureSpan">typescript.</span>isCaseBlock
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isCaseOrDefaultClause">
            function <span class="apidocSignatureSpan">typescript.</span>isCaseOrDefaultClause
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isCatchClause">
            function <span class="apidocSignatureSpan">typescript.</span>isCatchClause
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isCatchClauseVariableDeclarationOrBindingElement">
            function <span class="apidocSignatureSpan">typescript.</span>isCatchClauseVariableDeclarationOrBindingElement
            <span class="apidocSignatureSpan">(declaration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isChildOfNodeWithKind">
            function <span class="apidocSignatureSpan">typescript.</span>isChildOfNodeWithKind
            <span class="apidocSignatureSpan">(node, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isClassElement">
            function <span class="apidocSignatureSpan">typescript.</span>isClassElement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isClassLike">
            function <span class="apidocSignatureSpan">typescript.</span>isClassLike
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isCollapsedRange">
            function <span class="apidocSignatureSpan">typescript.</span>isCollapsedRange
            <span class="apidocSignatureSpan">(range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isComment">
            function <span class="apidocSignatureSpan">typescript.</span>isComment
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isCompletedNode">
            function <span class="apidocSignatureSpan">typescript.</span>isCompletedNode
            <span class="apidocSignatureSpan">(n, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isComputedPropertyName">
            function <span class="apidocSignatureSpan">typescript.</span>isComputedPropertyName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isConciseBody">
            function <span class="apidocSignatureSpan">typescript.</span>isConciseBody
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isConditionalExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isConditionalExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isConst">
            function <span class="apidocSignatureSpan">typescript.</span>isConst
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isConstEnumDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isConstEnumDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDeclarationBindingElement">
            function <span class="apidocSignatureSpan">typescript.</span>isDeclarationBindingElement
            <span class="apidocSignatureSpan">(bindingElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDeclarationFile">
            function <span class="apidocSignatureSpan">typescript.</span>isDeclarationFile
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDeclarationName">
            function <span class="apidocSignatureSpan">typescript.</span>isDeclarationName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDeclarationNameOfEnumOrNamespace">
            function <span class="apidocSignatureSpan">typescript.</span>isDeclarationNameOfEnumOrNamespace
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDeclarationOfFunctionExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isDeclarationOfFunctionExpression
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDeclarationStatement">
            function <span class="apidocSignatureSpan">typescript.</span>isDeclarationStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDeclaredRestParam">
            function <span class="apidocSignatureSpan">typescript.</span>isDeclaredRestParam
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDecorator">
            function <span class="apidocSignatureSpan">typescript.</span>isDecorator
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDefaultImport">
            function <span class="apidocSignatureSpan">typescript.</span>isDefaultImport
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDefined">
            function <span class="apidocSignatureSpan">typescript.</span>isDefined
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDeleteTarget">
            function <span class="apidocSignatureSpan">typescript.</span>isDeleteTarget
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDestructuringAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>isDestructuringAssignment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isDynamicName">
            function <span class="apidocSignatureSpan">typescript.</span>isDynamicName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isESSymbolIdentifier">
            function <span class="apidocSignatureSpan">typescript.</span>isESSymbolIdentifier
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isEffectiveExternalModule">
            function <span class="apidocSignatureSpan">typescript.</span>isEffectiveExternalModule
            <span class="apidocSignatureSpan">(node, compilerOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isElementAccessExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isElementAccessExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isEmptyObjectLiteralOrArrayLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>isEmptyObjectLiteralOrArrayLiteral
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isEntityName">
            function <span class="apidocSignatureSpan">typescript.</span>isEntityName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isEntityNameExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isEntityNameExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isEnumMember">
            function <span class="apidocSignatureSpan">typescript.</span>isEnumMember
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExportDefaultSymbol">
            function <span class="apidocSignatureSpan">typescript.</span>isExportDefaultSymbol
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExportName">
            function <span class="apidocSignatureSpan">typescript.</span>isExportName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExportSpecifier">
            function <span class="apidocSignatureSpan">typescript.</span>isExportSpecifier
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExpressionOfExternalModuleImportEqualsDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isExpressionOfExternalModuleImportEqualsDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExpressionWithTypeArguments">
            function <span class="apidocSignatureSpan">typescript.</span>isExpressionWithTypeArguments
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExpressionWithTypeArgumentsInClassExtendsClause">
            function <span class="apidocSignatureSpan">typescript.</span>isExpressionWithTypeArgumentsInClassExtendsClause
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExternalModule">
            function <span class="apidocSignatureSpan">typescript.</span>isExternalModule
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExternalModuleAugmentation">
            function <span class="apidocSignatureSpan">typescript.</span>isExternalModuleAugmentation
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExternalModuleImportEqualsDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isExternalModuleImportEqualsDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExternalModuleNameRelative">
            function <span class="apidocSignatureSpan">typescript.</span>isExternalModuleNameRelative
            <span class="apidocSignatureSpan">(moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isExternalOrCommonJsModule">
            function <span class="apidocSignatureSpan">typescript.</span>isExternalOrCommonJsModule
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isFirstDeclarationOfKind">
            function <span class="apidocSignatureSpan">typescript.</span>isFirstDeclarationOfKind
            <span class="apidocSignatureSpan">(node, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isFirstDeclarationOfSymbolParameter">
            function <span class="apidocSignatureSpan">typescript.</span>isFirstDeclarationOfSymbolParameter
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isForInitializer">
            function <span class="apidocSignatureSpan">typescript.</span>isForInitializer
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isFunctionBlock">
            function <span class="apidocSignatureSpan">typescript.</span>isFunctionBlock
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isFunctionBody">
            function <span class="apidocSignatureSpan">typescript.</span>isFunctionBody
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isFunctionLike">
            function <span class="apidocSignatureSpan">typescript.</span>isFunctionLike
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isFunctionLikeKind">
            function <span class="apidocSignatureSpan">typescript.</span>isFunctionLikeKind
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isGeneratedIdentifier">
            function <span class="apidocSignatureSpan">typescript.</span>isGeneratedIdentifier
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isGlobalScopeAugmentation">
            function <span class="apidocSignatureSpan">typescript.</span>isGlobalScopeAugmentation
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isHeritageClause">
            function <span class="apidocSignatureSpan">typescript.</span>isHeritageClause
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isIdentifier">
            function <span class="apidocSignatureSpan">typescript.</span>isIdentifier
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isIdentifierName">
            function <span class="apidocSignatureSpan">typescript.</span>isIdentifierName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isIdentifierPart">
            function <span class="apidocSignatureSpan">typescript.</span>isIdentifierPart
            <span class="apidocSignatureSpan">(ch, languageVersion)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isIdentifierStart">
            function <span class="apidocSignatureSpan">typescript.</span>isIdentifierStart
            <span class="apidocSignatureSpan">(ch, languageVersion)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isIdentifierText">
            function <span class="apidocSignatureSpan">typescript.</span>isIdentifierText
            <span class="apidocSignatureSpan">(name, languageVersion)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isIdentifierTypePredicate">
            function <span class="apidocSignatureSpan">typescript.</span>isIdentifierTypePredicate
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isImplicitGlob">
            function <span class="apidocSignatureSpan">typescript.</span>isImplicitGlob
            <span class="apidocSignatureSpan">(lastPathComponent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isImportClause">
            function <span class="apidocSignatureSpan">typescript.</span>isImportClause
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isImportEqualsDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isImportEqualsDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isImportOrExportSpecifierName">
            function <span class="apidocSignatureSpan">typescript.</span>isImportOrExportSpecifierName
            <span class="apidocSignatureSpan">(location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isImportSpecifier">
            function <span class="apidocSignatureSpan">typescript.</span>isImportSpecifier
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInAmbientContext">
            function <span class="apidocSignatureSpan">typescript.</span>isInAmbientContext
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInComment">
            function <span class="apidocSignatureSpan">typescript.</span>isInComment
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInCommentHelper">
            function <span class="apidocSignatureSpan">typescript.</span>isInCommentHelper
            <span class="apidocSignatureSpan">(sourceFile, position, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInJavaScriptFile">
            function <span class="apidocSignatureSpan">typescript.</span>isInJavaScriptFile
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInNonReferenceComment">
            function <span class="apidocSignatureSpan">typescript.</span>isInNonReferenceComment
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInReferenceComment">
            function <span class="apidocSignatureSpan">typescript.</span>isInReferenceComment
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInString">
            function <span class="apidocSignatureSpan">typescript.</span>isInString
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInTemplateString">
            function <span class="apidocSignatureSpan">typescript.</span>isInTemplateString
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInsideComment">
            function <span class="apidocSignatureSpan">typescript.</span>isInsideComment
            <span class="apidocSignatureSpan">(sourceFile, token, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInsideJsxElementOrAttribute">
            function <span class="apidocSignatureSpan">typescript.</span>isInsideJsxElementOrAttribute
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInsideTemplateLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>isInsideTemplateLiteral
            <span class="apidocSignatureSpan">(node, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInstantiatedModule">
            function <span class="apidocSignatureSpan">typescript.</span>isInstantiatedModule
            <span class="apidocSignatureSpan">(node, preserveConstEnums)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isInternalModuleImportEqualsDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isInternalModuleImportEqualsDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isIntrinsicJsxName">
            function <span class="apidocSignatureSpan">typescript.</span>isIntrinsicJsxName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isIterationStatement">
            function <span class="apidocSignatureSpan">typescript.</span>isIterationStatement
            <span class="apidocSignatureSpan">(node, lookInLabeledStatements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJSDocConstructSignature">
            function <span class="apidocSignatureSpan">typescript.</span>isJSDocConstructSignature
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJSDocNamespaceBody">
            function <span class="apidocSignatureSpan">typescript.</span>isJSDocNamespaceBody
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJSDocNode">
            function <span class="apidocSignatureSpan">typescript.</span>isJSDocNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJSDocTag">
            function <span class="apidocSignatureSpan">typescript.</span>isJSDocTag
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJSXTagName">
            function <span class="apidocSignatureSpan">typescript.</span>isJSXTagName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJsxAttribute">
            function <span class="apidocSignatureSpan">typescript.</span>isJsxAttribute
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJsxAttributeLike">
            function <span class="apidocSignatureSpan">typescript.</span>isJsxAttributeLike
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJsxChild">
            function <span class="apidocSignatureSpan">typescript.</span>isJsxChild
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJsxClosingElement">
            function <span class="apidocSignatureSpan">typescript.</span>isJsxClosingElement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJsxOpeningElement">
            function <span class="apidocSignatureSpan">typescript.</span>isJsxOpeningElement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJsxSpreadAttribute">
            function <span class="apidocSignatureSpan">typescript.</span>isJsxSpreadAttribute
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJsxTagNameExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isJsxTagNameExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isJumpStatementTarget">
            function <span class="apidocSignatureSpan">typescript.</span>isJumpStatementTarget
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isKeyword">
            function <span class="apidocSignatureSpan">typescript.</span>isKeyword
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLabelName">
            function <span class="apidocSignatureSpan">typescript.</span>isLabelName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLeftHandSideExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isLeftHandSideExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLet">
            function <span class="apidocSignatureSpan">typescript.</span>isLet
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLineBreak">
            function <span class="apidocSignatureSpan">typescript.</span>isLineBreak
            <span class="apidocSignatureSpan">(ch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLiteralComputedPropertyDeclarationName">
            function <span class="apidocSignatureSpan">typescript.</span>isLiteralComputedPropertyDeclarationName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLiteralExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isLiteralExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLiteralKind">
            function <span class="apidocSignatureSpan">typescript.</span>isLiteralKind
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLiteralNameOfPropertyDeclarationOrIndexAccess">
            function <span class="apidocSignatureSpan">typescript.</span>isLiteralNameOfPropertyDeclarationOrIndexAccess
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLocalName">
            function <span class="apidocSignatureSpan">typescript.</span>isLocalName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isLogicalOperator">
            function <span class="apidocSignatureSpan">typescript.</span>isLogicalOperator
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isMergedWithClass">
            function <span class="apidocSignatureSpan">typescript.</span>isMergedWithClass
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isMethodDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isMethodDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isModifier">
            function <span class="apidocSignatureSpan">typescript.</span>isModifier
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isModifierKind">
            function <span class="apidocSignatureSpan">typescript.</span>isModifierKind
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isModuleBody">
            function <span class="apidocSignatureSpan">typescript.</span>isModuleBody
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isModuleName">
            function <span class="apidocSignatureSpan">typescript.</span>isModuleName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isModuleOrEnumDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isModuleOrEnumDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isModuleReference">
            function <span class="apidocSignatureSpan">typescript.</span>isModuleReference
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNameOfFunctionDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isNameOfFunctionDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNameOfModuleDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isNameOfModuleDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNamedExports">
            function <span class="apidocSignatureSpan">typescript.</span>isNamedExports
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNamedImportBindings">
            function <span class="apidocSignatureSpan">typescript.</span>isNamedImportBindings
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNamespaceBody">
            function <span class="apidocSignatureSpan">typescript.</span>isNamespaceBody
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNewExpressionTarget">
            function <span class="apidocSignatureSpan">typescript.</span>isNewExpressionTarget
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNoSubstitutionTemplateLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>isNoSubstitutionTemplateLiteral
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNodeArray">
            function <span class="apidocSignatureSpan">typescript.</span>isNodeArray
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNodeDescendantOf">
            function <span class="apidocSignatureSpan">typescript.</span>isNodeDescendantOf
            <span class="apidocSignatureSpan">(node, ancestor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNotEmittedOrPartiallyEmittedNode">
            function <span class="apidocSignatureSpan">typescript.</span>isNotEmittedOrPartiallyEmittedNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isNotEmittedStatement">
            function <span class="apidocSignatureSpan">typescript.</span>isNotEmittedStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isObjectBindingOrAssignmentPattern">
            function <span class="apidocSignatureSpan">typescript.</span>isObjectBindingOrAssignmentPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isObjectBindingPattern">
            function <span class="apidocSignatureSpan">typescript.</span>isObjectBindingPattern
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isObjectLiteralElementLike">
            function <span class="apidocSignatureSpan">typescript.</span>isObjectLiteralElementLike
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isObjectLiteralExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isObjectLiteralExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isObjectLiteralMethod">
            function <span class="apidocSignatureSpan">typescript.</span>isObjectLiteralMethod
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isObjectLiteralOrClassExpressionMethod">
            function <span class="apidocSignatureSpan">typescript.</span>isObjectLiteralOrClassExpressionMethod
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isOctalDigit">
            function <span class="apidocSignatureSpan">typescript.</span>isOctalDigit
            <span class="apidocSignatureSpan">(ch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isOmittedExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isOmittedExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isParameter">
            function <span class="apidocSignatureSpan">typescript.</span>isParameter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isParameterDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isParameterDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isParameterPropertyDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isParameterPropertyDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isParseTreeNode">
            function <span class="apidocSignatureSpan">typescript.</span>isParseTreeNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPartOfExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isPartOfExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPartOfTypeNode">
            function <span class="apidocSignatureSpan">typescript.</span>isPartOfTypeNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPartiallyEmittedExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isPartiallyEmittedExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPrefixUnaryExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isPrefixUnaryExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPrologueDirective">
            function <span class="apidocSignatureSpan">typescript.</span>isPrologueDirective
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPropertyAccessExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isPropertyAccessExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPropertyAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>isPropertyAssignment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPropertyName">
            function <span class="apidocSignatureSpan">typescript.</span>isPropertyName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPunctuation">
            function <span class="apidocSignatureSpan">typescript.</span>isPunctuation
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isPushOrUnshiftIdentifier">
            function <span class="apidocSignatureSpan">typescript.</span>isPushOrUnshiftIdentifier
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isQualifiedName">
            function <span class="apidocSignatureSpan">typescript.</span>isQualifiedName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isRequireCall">
            function <span class="apidocSignatureSpan">typescript.</span>isRequireCall
            <span class="apidocSignatureSpan">(expression, checkArgumentIsStringLiteral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isRestParameter">
            function <span class="apidocSignatureSpan">typescript.</span>isRestParameter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isRightSideOfPropertyAccess">
            function <span class="apidocSignatureSpan">typescript.</span>isRightSideOfPropertyAccess
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isRightSideOfQualifiedName">
            function <span class="apidocSignatureSpan">typescript.</span>isRightSideOfQualifiedName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isRightSideOfQualifiedNameOrPropertyAccess">
            function <span class="apidocSignatureSpan">typescript.</span>isRightSideOfQualifiedNameOrPropertyAccess
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isRootedDiskPath">
            function <span class="apidocSignatureSpan">typescript.</span>isRootedDiskPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isShorthandAmbientModuleSymbol">
            function <span class="apidocSignatureSpan">typescript.</span>isShorthandAmbientModuleSymbol
            <span class="apidocSignatureSpan">(moduleSymbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isShorthandPropertyAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>isShorthandPropertyAssignment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isSimpleExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isSimpleExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isSingleOrDoubleQuote">
            function <span class="apidocSignatureSpan">typescript.</span>isSingleOrDoubleQuote
            <span class="apidocSignatureSpan">(charCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isSourceFile">
            function <span class="apidocSignatureSpan">typescript.</span>isSourceFile
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isSourceFileJavaScript">
            function <span class="apidocSignatureSpan">typescript.</span>isSourceFileJavaScript
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isSpreadExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isSpreadExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isStatement">
            function <span class="apidocSignatureSpan">typescript.</span>isStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isStatementButNotDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isStatementButNotDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isStatementWithLocals">
            function <span class="apidocSignatureSpan">typescript.</span>isStatementWithLocals
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isStringLiteralOrJsxExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isStringLiteralOrJsxExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isStringOrNumericLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>isStringOrNumericLiteral
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isStringOrRegularExpressionOrTemplateLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>isStringOrRegularExpressionOrTemplateLiteral
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isSuperCall">
            function <span class="apidocSignatureSpan">typescript.</span>isSuperCall
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isSuperProperty">
            function <span class="apidocSignatureSpan">typescript.</span>isSuperProperty
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isSupportedExpressionWithTypeArguments">
            function <span class="apidocSignatureSpan">typescript.</span>isSupportedExpressionWithTypeArguments
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isSupportedSourceFileName">
            function <span class="apidocSignatureSpan">typescript.</span>isSupportedSourceFileName
            <span class="apidocSignatureSpan">(fileName, compilerOptions, extraFileExtensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTemplateHead">
            function <span class="apidocSignatureSpan">typescript.</span>isTemplateHead
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTemplateLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>isTemplateLiteral
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTemplateLiteralKind">
            function <span class="apidocSignatureSpan">typescript.</span>isTemplateLiteralKind
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTemplateMiddleOrTemplateTail">
            function <span class="apidocSignatureSpan">typescript.</span>isTemplateMiddleOrTemplateTail
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTemplateSpan">
            function <span class="apidocSignatureSpan">typescript.</span>isTemplateSpan
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTextualLiteralKind">
            function <span class="apidocSignatureSpan">typescript.</span>isTextualLiteralKind
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isThis">
            function <span class="apidocSignatureSpan">typescript.</span>isThis
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isThisIdentifier">
            function <span class="apidocSignatureSpan">typescript.</span>isThisIdentifier
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isThisTypePredicate">
            function <span class="apidocSignatureSpan">typescript.</span>isThisTypePredicate
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isToken">
            function <span class="apidocSignatureSpan">typescript.</span>isToken
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTraceEnabled">
            function <span class="apidocSignatureSpan">typescript.</span>isTraceEnabled
            <span class="apidocSignatureSpan">(compilerOptions, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTrivia">
            function <span class="apidocSignatureSpan">typescript.</span>isTrivia
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTypeKeyword">
            function <span class="apidocSignatureSpan">typescript.</span>isTypeKeyword
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTypeNode">
            function <span class="apidocSignatureSpan">typescript.</span>isTypeNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isTypeParameter">
            function <span class="apidocSignatureSpan">typescript.</span>isTypeParameter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isUnaryExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isUnaryExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isUnicodeIdentifierStart">
            function <span class="apidocSignatureSpan">typescript.</span>isUnicodeIdentifierStart
            <span class="apidocSignatureSpan">(code, languageVersion)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isUrl">
            function <span class="apidocSignatureSpan">typescript.</span>isUrl
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isVariableDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>isVariableDeclaration
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isVariableDeclarationList">
            function <span class="apidocSignatureSpan">typescript.</span>isVariableDeclarationList
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isVariableLike">
            function <span class="apidocSignatureSpan">typescript.</span>isVariableLike
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isVoidExpression">
            function <span class="apidocSignatureSpan">typescript.</span>isVoidExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isWatchSet">
            function <span class="apidocSignatureSpan">typescript.</span>isWatchSet
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isWellKnownSymbolSyntactically">
            function <span class="apidocSignatureSpan">typescript.</span>isWellKnownSymbolSyntactically
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isWhiteSpace">
            function <span class="apidocSignatureSpan">typescript.</span>isWhiteSpace
            <span class="apidocSignatureSpan">(ch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isWhiteSpaceSingleLine">
            function <span class="apidocSignatureSpan">typescript.</span>isWhiteSpaceSingleLine
            <span class="apidocSignatureSpan">(ch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.isWord">
            function <span class="apidocSignatureSpan">typescript.</span>isWord
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.keywordPart">
            function <span class="apidocSignatureSpan">typescript.</span>keywordPart
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.lastOrUndefined">
            function <span class="apidocSignatureSpan">typescript.</span>lastOrUndefined
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.length">
            function <span class="apidocSignatureSpan">typescript.</span>length
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.liftToBlock">
            function <span class="apidocSignatureSpan">typescript.</span>liftToBlock
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.lineBreakPart">
            function <span class="apidocSignatureSpan">typescript.</span>lineBreakPart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.loadModuleFromGlobalCache">
            function <span class="apidocSignatureSpan">typescript.</span>loadModuleFromGlobalCache
            <span class="apidocSignatureSpan">(moduleName, projectName, compilerOptions, host, globalCache)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.makeIdentifierFromModuleName">
            function <span class="apidocSignatureSpan">typescript.</span>makeIdentifierFromModuleName
            <span class="apidocSignatureSpan">(moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.map">
            function <span class="apidocSignatureSpan">typescript.</span>map
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.mapEntries">
            function <span class="apidocSignatureSpan">typescript.</span>mapEntries
            <span class="apidocSignatureSpan">(map, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.mapToDisplayParts">
            function <span class="apidocSignatureSpan">typescript.</span>mapToDisplayParts
            <span class="apidocSignatureSpan">(writeDisplayParts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.matchFiles">
            function <span class="apidocSignatureSpan">typescript.</span>matchFiles
            <span class="apidocSignatureSpan">(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, getFileSystemEntries)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.matchPatternOrExact">
            function <span class="apidocSignatureSpan">typescript.</span>matchPatternOrExact
            <span class="apidocSignatureSpan">(patternStrings, candidate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.matchedText">
            function <span class="apidocSignatureSpan">typescript.</span>matchedText
            <span class="apidocSignatureSpan">(pattern, candidate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.memoize">
            function <span class="apidocSignatureSpan">typescript.</span>memoize
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.mergeFunctionBodyLexicalEnvironment">
            function <span class="apidocSignatureSpan">typescript.</span>mergeFunctionBodyLexicalEnvironment
            <span class="apidocSignatureSpan">(body, declarations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.mergeLexicalEnvironment">
            function <span class="apidocSignatureSpan">typescript.</span>mergeLexicalEnvironment
            <span class="apidocSignatureSpan">(statements, declarations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.modifierToFlag">
            function <span class="apidocSignatureSpan">typescript.</span>modifierToFlag
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.moduleHasNonRelativeName">
            function <span class="apidocSignatureSpan">typescript.</span>moduleHasNonRelativeName
            <span class="apidocSignatureSpan">(moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.moduleResolutionIsEqualTo">
            function <span class="apidocSignatureSpan">typescript.</span>moduleResolutionIsEqualTo
            <span class="apidocSignatureSpan">(oldResolution, newResolution)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.moveEmitHelpers">
            function <span class="apidocSignatureSpan">typescript.</span>moveEmitHelpers
            <span class="apidocSignatureSpan">(source, target, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.movePos">
            function <span class="apidocSignatureSpan">typescript.</span>movePos
            <span class="apidocSignatureSpan">(pos, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.moveRangeEnd">
            function <span class="apidocSignatureSpan">typescript.</span>moveRangeEnd
            <span class="apidocSignatureSpan">(range, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.moveRangePastDecorators">
            function <span class="apidocSignatureSpan">typescript.</span>moveRangePastDecorators
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.moveRangePastModifiers">
            function <span class="apidocSignatureSpan">typescript.</span>moveRangePastModifiers
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.moveRangePos">
            function <span class="apidocSignatureSpan">typescript.</span>moveRangePos
            <span class="apidocSignatureSpan">(range, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodeCanBeDecorated">
            function <span class="apidocSignatureSpan">typescript.</span>nodeCanBeDecorated
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodeIsDecorated">
            function <span class="apidocSignatureSpan">typescript.</span>nodeIsDecorated
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodeIsMissing">
            function <span class="apidocSignatureSpan">typescript.</span>nodeIsMissing
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodeIsPresent">
            function <span class="apidocSignatureSpan">typescript.</span>nodeIsPresent
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodeIsSynthesized">
            function <span class="apidocSignatureSpan">typescript.</span>nodeIsSynthesized
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodeModuleNameResolver">
            function <span class="apidocSignatureSpan">typescript.</span>nodeModuleNameResolver
            <span class="apidocSignatureSpan">(moduleName, containingFile, compilerOptions, host, cache)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodeModuleNameResolverWorker">
            function <span class="apidocSignatureSpan">typescript.</span>nodeModuleNameResolverWorker
            <span class="apidocSignatureSpan">(moduleName, containingFile, compilerOptions, host, cache, jsOnly)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodeOrChildIsDecorated">
            function <span class="apidocSignatureSpan">typescript.</span>nodeOrChildIsDecorated
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodePosToString">
            function <span class="apidocSignatureSpan">typescript.</span>nodePosToString
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.nodeStartsNewLexicalEnvironment">
            function <span class="apidocSignatureSpan">typescript.</span>nodeStartsNewLexicalEnvironment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.noop">
            function <span class="apidocSignatureSpan">typescript.</span>noop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.normalizePath">
            function <span class="apidocSignatureSpan">typescript.</span>normalizePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.normalizeSlashes">
            function <span class="apidocSignatureSpan">typescript.</span>normalizeSlashes
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.notImplemented">
            function <span class="apidocSignatureSpan">typescript.</span>notImplemented
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.operatorPart">
            function <span class="apidocSignatureSpan">typescript.</span>operatorPart
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.orderedRemoveItem">
            function <span class="apidocSignatureSpan">typescript.</span>orderedRemoveItem
            <span class="apidocSignatureSpan">(array, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.orderedRemoveItemAt">
            function <span class="apidocSignatureSpan">typescript.</span>orderedRemoveItemAt
            <span class="apidocSignatureSpan">(array, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parameterIsThisKeyword">
            function <span class="apidocSignatureSpan">typescript.</span>parameterIsThisKeyword
            <span class="apidocSignatureSpan">(parameter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizeBinaryOperand">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizeBinaryOperand
            <span class="apidocSignatureSpan">(binaryOperator, operand, isLeftSideOfBinary, leftOperand)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizeConciseBody">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizeConciseBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizeExpressionForExpressionStatement">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizeExpressionForExpressionStatement
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizeExpressionForList">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizeExpressionForList
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizeForAccess">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizeForAccess
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizeForConditionalHead">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizeForConditionalHead
            <span class="apidocSignatureSpan">(condition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizeForNew">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizeForNew
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizeListElements">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizeListElements
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizePostfixOperand">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizePostfixOperand
            <span class="apidocSignatureSpan">(operand)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizePrefixOperand">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizePrefixOperand
            <span class="apidocSignatureSpan">(operand)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parenthesizeSubexpressionOfConditionalExpression">
            function <span class="apidocSignatureSpan">typescript.</span>parenthesizeSubexpressionOfConditionalExpression
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parseCommandLine">
            function <span class="apidocSignatureSpan">typescript.</span>parseCommandLine
            <span class="apidocSignatureSpan">(commandLine, readFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parseConfigFileTextToJson">
            function <span class="apidocSignatureSpan">typescript.</span>parseConfigFileTextToJson
            <span class="apidocSignatureSpan">(fileName, jsonText, stripComments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parseCustomTypeOption">
            function <span class="apidocSignatureSpan">typescript.</span>parseCustomTypeOption
            <span class="apidocSignatureSpan">(opt, value, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parseIsolatedEntityName">
            function <span class="apidocSignatureSpan">typescript.</span>parseIsolatedEntityName
            <span class="apidocSignatureSpan">(text, languageVersion)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parseIsolatedJSDocComment">
            function <span class="apidocSignatureSpan">typescript.</span>parseIsolatedJSDocComment
            <span class="apidocSignatureSpan">(content, start, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parseJSDocTypeExpressionForTests">
            function <span class="apidocSignatureSpan">typescript.</span>parseJSDocTypeExpressionForTests
            <span class="apidocSignatureSpan">(content, start, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parseJsonConfigFileContent">
            function <span class="apidocSignatureSpan">typescript.</span>parseJsonConfigFileContent
            <span class="apidocSignatureSpan">(json, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.parseListTypeOption">
            function <span class="apidocSignatureSpan">typescript.</span>parseListTypeOption
            <span class="apidocSignatureSpan">(opt, value, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.pathEndsWithDirectorySeparator">
            function <span class="apidocSignatureSpan">typescript.</span>pathEndsWithDirectorySeparator
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.patternText">
            function <span class="apidocSignatureSpan">typescript.</span>patternText
            <span class="apidocSignatureSpan">(_a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.positionBelongsToNode">
            function <span class="apidocSignatureSpan">typescript.</span>positionBelongsToNode
            <span class="apidocSignatureSpan">(candidate, position, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.positionIsSynthesized">
            function <span class="apidocSignatureSpan">typescript.</span>positionIsSynthesized
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.positionsAreOnSameLine">
            function <span class="apidocSignatureSpan">typescript.</span>positionsAreOnSameLine
            <span class="apidocSignatureSpan">(pos1, pos2, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.preProcessFile">
            function <span class="apidocSignatureSpan">typescript.</span>preProcessFile
            <span class="apidocSignatureSpan">(sourceText, readImportFiles, detectJavaScriptImports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.punctuationPart">
            function <span class="apidocSignatureSpan">typescript.</span>punctuationPart
            <span class="apidocSignatureSpan">(kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.rangeContainsRange">
            function <span class="apidocSignatureSpan">typescript.</span>rangeContainsRange
            <span class="apidocSignatureSpan">(r1, r2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.rangeContainsStartEnd">
            function <span class="apidocSignatureSpan">typescript.</span>rangeContainsStartEnd
            <span class="apidocSignatureSpan">(range, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.rangeEndIsOnSameLineAsRangeStart">
            function <span class="apidocSignatureSpan">typescript.</span>rangeEndIsOnSameLineAsRangeStart
            <span class="apidocSignatureSpan">(range1, range2, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.rangeEndPositionsAreOnSameLine">
            function <span class="apidocSignatureSpan">typescript.</span>rangeEndPositionsAreOnSameLine
            <span class="apidocSignatureSpan">(range1, range2, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.rangeEquals">
            function <span class="apidocSignatureSpan">typescript.</span>rangeEquals
            <span class="apidocSignatureSpan">(array1, array2, pos, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.rangeIsOnSingleLine">
            function <span class="apidocSignatureSpan">typescript.</span>rangeIsOnSingleLine
            <span class="apidocSignatureSpan">(range, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.rangeOverlapsWithStartEnd">
            function <span class="apidocSignatureSpan">typescript.</span>rangeOverlapsWithStartEnd
            <span class="apidocSignatureSpan">(r1, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.rangeStartIsOnSameLineAsRangeEnd">
            function <span class="apidocSignatureSpan">typescript.</span>rangeStartIsOnSameLineAsRangeEnd
            <span class="apidocSignatureSpan">(range1, range2, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.rangeStartPositionsAreOnSameLine">
            function <span class="apidocSignatureSpan">typescript.</span>rangeStartPositionsAreOnSameLine
            <span class="apidocSignatureSpan">(range1, range2, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.readConfigFile">
            function <span class="apidocSignatureSpan">typescript.</span>readConfigFile
            <span class="apidocSignatureSpan">(fileName, readFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.realizeDiagnostics">
            function <span class="apidocSignatureSpan">typescript.</span>realizeDiagnostics
            <span class="apidocSignatureSpan">(diagnostics, newLine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.reduceEachChild">
            function <span class="apidocSignatureSpan">typescript.</span>reduceEachChild
            <span class="apidocSignatureSpan">(node, initial, cbNode, cbNodeArray)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.reduceEachLeadingCommentRange">
            function <span class="apidocSignatureSpan">typescript.</span>reduceEachLeadingCommentRange
            <span class="apidocSignatureSpan">(text, pos, cb, state, initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.reduceEachTrailingCommentRange">
            function <span class="apidocSignatureSpan">typescript.</span>reduceEachTrailingCommentRange
            <span class="apidocSignatureSpan">(text, pos, cb, state, initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.reduceLeft">
            function <span class="apidocSignatureSpan">typescript.</span>reduceLeft
            <span class="apidocSignatureSpan">(array, f, initial, start, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.reduceRight">
            function <span class="apidocSignatureSpan">typescript.</span>reduceRight
            <span class="apidocSignatureSpan">(array, f, initial, start, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.relativeComplement">
            function <span class="apidocSignatureSpan">typescript.</span>relativeComplement
            <span class="apidocSignatureSpan">(arrayA, arrayB, comparer, offsetA, offsetB)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.releaseStringWriter">
            function <span class="apidocSignatureSpan">typescript.</span>releaseStringWriter
            <span class="apidocSignatureSpan">(writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.removeEmitHelper">
            function <span class="apidocSignatureSpan">typescript.</span>removeEmitHelper
            <span class="apidocSignatureSpan">(node, helper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.removeExtension">
            function <span class="apidocSignatureSpan">typescript.</span>removeExtension
            <span class="apidocSignatureSpan">(path, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.removeFileExtension">
            function <span class="apidocSignatureSpan">typescript.</span>removeFileExtension
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.removeTrailingDirectorySeparator">
            function <span class="apidocSignatureSpan">typescript.</span>removeTrailingDirectorySeparator
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.removeWhere">
            function <span class="apidocSignatureSpan">typescript.</span>removeWhere
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.replaceElement">
            function <span class="apidocSignatureSpan">typescript.</span>replaceElement
            <span class="apidocSignatureSpan">(array, index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.resolveModuleName">
            function <span class="apidocSignatureSpan">typescript.</span>resolveModuleName
            <span class="apidocSignatureSpan">(moduleName, containingFile, compilerOptions, host, cache)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.resolveTripleslashReference">
            function <span class="apidocSignatureSpan">typescript.</span>resolveTripleslashReference
            <span class="apidocSignatureSpan">(moduleName, containingFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.resolveTypeReferenceDirective">
            function <span class="apidocSignatureSpan">typescript.</span>resolveTypeReferenceDirective
            <span class="apidocSignatureSpan">(typeReferenceDirectiveName, containingFile, options, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.restoreEnclosingLabel">
            function <span class="apidocSignatureSpan">typescript.</span>restoreEnclosingLabel
            <span class="apidocSignatureSpan">(node, outermostLabeledStatement, afterRestoreLabelCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sameMap">
            function <span class="apidocSignatureSpan">typescript.</span>sameMap
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sanitizeConfigFile">
            function <span class="apidocSignatureSpan">typescript.</span>sanitizeConfigFile
            <span class="apidocSignatureSpan">(configFileName, content)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scriptKindIs">
            function <span class="apidocSignatureSpan">typescript.</span>scriptKindIs
            <span class="apidocSignatureSpan">(fileName, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.setCommentRange">
            function <span class="apidocSignatureSpan">typescript.</span>setCommentRange
            <span class="apidocSignatureSpan">(node, range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.setConstantValue">
            function <span class="apidocSignatureSpan">typescript.</span>setConstantValue
            <span class="apidocSignatureSpan">(node, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.setEmitFlags">
            function <span class="apidocSignatureSpan">typescript.</span>setEmitFlags
            <span class="apidocSignatureSpan">(node, emitFlags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.setOriginalNode">
            function <span class="apidocSignatureSpan">typescript.</span>setOriginalNode
            <span class="apidocSignatureSpan">(node, original)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.setResolvedModule">
            function <span class="apidocSignatureSpan">typescript.</span>setResolvedModule
            <span class="apidocSignatureSpan">(sourceFile, moduleNameText, resolvedModule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.setResolvedTypeReferenceDirective">
            function <span class="apidocSignatureSpan">typescript.</span>setResolvedTypeReferenceDirective
            <span class="apidocSignatureSpan">(sourceFile, typeReferenceDirectiveName, resolvedTypeReferenceDirective)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.setSourceMapRange">
            function <span class="apidocSignatureSpan">typescript.</span>setSourceMapRange
            <span class="apidocSignatureSpan">(node, range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.setTextRange">
            function <span class="apidocSignatureSpan">typescript.</span>setTextRange
            <span class="apidocSignatureSpan">(range, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.setTokenSourceMapRange">
            function <span class="apidocSignatureSpan">typescript.</span>setTokenSourceMapRange
            <span class="apidocSignatureSpan">(node, token, range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.signatureToDisplayParts">
            function <span class="apidocSignatureSpan">typescript.</span>signatureToDisplayParts
            <span class="apidocSignatureSpan">(typechecker, signature, enclosingDeclaration, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.singleOrMany">
            function <span class="apidocSignatureSpan">typescript.</span>singleOrMany
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.singleOrUndefined">
            function <span class="apidocSignatureSpan">typescript.</span>singleOrUndefined
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.skipAssertions">
            function <span class="apidocSignatureSpan">typescript.</span>skipAssertions
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.skipOuterExpressions">
            function <span class="apidocSignatureSpan">typescript.</span>skipOuterExpressions
            <span class="apidocSignatureSpan">(node, kinds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.skipParentheses">
            function <span class="apidocSignatureSpan">typescript.</span>skipParentheses
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.skipPartiallyEmittedExpressions">
            function <span class="apidocSignatureSpan">typescript.</span>skipPartiallyEmittedExpressions
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.skipTrivia">
            function <span class="apidocSignatureSpan">typescript.</span>skipTrivia
            <span class="apidocSignatureSpan">(text, pos, stopAfterLineBreak, stopAtComments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.some">
            function <span class="apidocSignatureSpan">typescript.</span>some
            <span class="apidocSignatureSpan">(array, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sortAndDeduplicateDiagnostics">
            function <span class="apidocSignatureSpan">typescript.</span>sortAndDeduplicateDiagnostics
            <span class="apidocSignatureSpan">(diagnostics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sourceFileMayBeEmitted">
            function <span class="apidocSignatureSpan">typescript.</span>sourceFileMayBeEmitted
            <span class="apidocSignatureSpan">(sourceFile, options, isSourceFileFromExternalLibrary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.spacePart">
            function <span class="apidocSignatureSpan">typescript.</span>spacePart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.span">
            function <span class="apidocSignatureSpan">typescript.</span>span
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.spanMap">
            function <span class="apidocSignatureSpan">typescript.</span>spanMap
            <span class="apidocSignatureSpan">(array, keyfn, mapfn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.stableSort">
            function <span class="apidocSignatureSpan">typescript.</span>stableSort
            <span class="apidocSignatureSpan">(array, comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.startEndContainsRange">
            function <span class="apidocSignatureSpan">typescript.</span>startEndContainsRange
            <span class="apidocSignatureSpan">(start, end, range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.startEndOverlapsWithStartEnd">
            function <span class="apidocSignatureSpan">typescript.</span>startEndOverlapsWithStartEnd
            <span class="apidocSignatureSpan">(start1, end1, start2, end2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.startOnNewLine">
            function <span class="apidocSignatureSpan">typescript.</span>startOnNewLine
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.startsWith">
            function <span class="apidocSignatureSpan">typescript.</span>startsWith
            <span class="apidocSignatureSpan">(str, prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.startsWithUseStrict">
            function <span class="apidocSignatureSpan">typescript.</span>startsWithUseStrict
            <span class="apidocSignatureSpan">(statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.stringToToken">
            function <span class="apidocSignatureSpan">typescript.</span>stringToToken
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.stripQuotes">
            function <span class="apidocSignatureSpan">typescript.</span>stripQuotes
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sum">
            function <span class="apidocSignatureSpan">typescript.</span>sum
            <span class="apidocSignatureSpan">(array, prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.symbolPart">
            function <span class="apidocSignatureSpan">typescript.</span>symbolPart
            <span class="apidocSignatureSpan">(text, symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.symbolToDisplayParts">
            function <span class="apidocSignatureSpan">typescript.</span>symbolToDisplayParts
            <span class="apidocSignatureSpan">(typeChecker, symbol, enclosingDeclaration, meaning, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textChangeRangeIsUnchanged">
            function <span class="apidocSignatureSpan">typescript.</span>textChangeRangeIsUnchanged
            <span class="apidocSignatureSpan">(range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textChangeRangeNewSpan">
            function <span class="apidocSignatureSpan">typescript.</span>textChangeRangeNewSpan
            <span class="apidocSignatureSpan">(range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textOrKeywordPart">
            function <span class="apidocSignatureSpan">typescript.</span>textOrKeywordPart
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textPart">
            function <span class="apidocSignatureSpan">typescript.</span>textPart
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanContainsPosition">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanContainsPosition
            <span class="apidocSignatureSpan">(span, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanContainsTextSpan">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanContainsTextSpan
            <span class="apidocSignatureSpan">(span, other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanEnd">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanEnd
            <span class="apidocSignatureSpan">(span)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanIntersection">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanIntersection
            <span class="apidocSignatureSpan">(span1, span2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanIntersectsWith">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanIntersectsWith
            <span class="apidocSignatureSpan">(span, start, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanIntersectsWithPosition">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanIntersectsWithPosition
            <span class="apidocSignatureSpan">(span, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanIntersectsWithTextSpan">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanIntersectsWithTextSpan
            <span class="apidocSignatureSpan">(span, other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanIsEmpty">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanIsEmpty
            <span class="apidocSignatureSpan">(span)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanOverlap">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanOverlap
            <span class="apidocSignatureSpan">(span1, span2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.textSpanOverlapsWith">
            function <span class="apidocSignatureSpan">typescript.</span>textSpanOverlapsWith
            <span class="apidocSignatureSpan">(span, other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.timestamp">
            function <span class="apidocSignatureSpan">typescript.</span>timestamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.toEditorSettings">
            function <span class="apidocSignatureSpan">typescript.</span>toEditorSettings
            <span class="apidocSignatureSpan">(optionsAsMap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.toPath">
            function <span class="apidocSignatureSpan">typescript.</span>toPath
            <span class="apidocSignatureSpan">(fileName, basePath, getCanonicalFileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.tokenIsIdentifierOrKeyword">
            function <span class="apidocSignatureSpan">typescript.</span>tokenIsIdentifierOrKeyword
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.tokenToString">
            function <span class="apidocSignatureSpan">typescript.</span>tokenToString
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.trace">
            function <span class="apidocSignatureSpan">typescript.</span>trace
            <span class="apidocSignatureSpan">(host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformES2015">
            function <span class="apidocSignatureSpan">typescript.</span>transformES2015
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformES2015Module">
            function <span class="apidocSignatureSpan">typescript.</span>transformES2015Module
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformES2016">
            function <span class="apidocSignatureSpan">typescript.</span>transformES2016
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformES2017">
            function <span class="apidocSignatureSpan">typescript.</span>transformES2017
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformES5">
            function <span class="apidocSignatureSpan">typescript.</span>transformES5
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformESNext">
            function <span class="apidocSignatureSpan">typescript.</span>transformESNext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformFiles">
            function <span class="apidocSignatureSpan">typescript.</span>transformFiles
            <span class="apidocSignatureSpan">(resolver, host, sourceFiles, transformers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformGenerators">
            function <span class="apidocSignatureSpan">typescript.</span>transformGenerators
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformJsx">
            function <span class="apidocSignatureSpan">typescript.</span>transformJsx
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformModule">
            function <span class="apidocSignatureSpan">typescript.</span>transformModule
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformSystemModule">
            function <span class="apidocSignatureSpan">typescript.</span>transformSystemModule
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transformTypeScript">
            function <span class="apidocSignatureSpan">typescript.</span>transformTypeScript
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transpile">
            function <span class="apidocSignatureSpan">typescript.</span>transpile
            <span class="apidocSignatureSpan">(input, compilerOptions, fileName, diagnostics, moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.transpileModule">
            function <span class="apidocSignatureSpan">typescript.</span>transpileModule
            <span class="apidocSignatureSpan">(input, transpileOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.tryExtractTypeScriptExtension">
            function <span class="apidocSignatureSpan">typescript.</span>tryExtractTypeScriptExtension
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.tryGetClassExtendingExpressionWithTypeArguments">
            function <span class="apidocSignatureSpan">typescript.</span>tryGetClassExtendingExpressionWithTypeArguments
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.tryGetExtensionFromPath">
            function <span class="apidocSignatureSpan">typescript.</span>tryGetExtensionFromPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.tryGetModuleNameFromFile">
            function <span class="apidocSignatureSpan">typescript.</span>tryGetModuleNameFromFile
            <span class="apidocSignatureSpan">(file, host, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.tryParsePattern">
            function <span class="apidocSignatureSpan">typescript.</span>tryParsePattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.tryRemoveExtension">
            function <span class="apidocSignatureSpan">typescript.</span>tryRemoveExtension
            <span class="apidocSignatureSpan">(path, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.tryResolveScriptReference">
            function <span class="apidocSignatureSpan">typescript.</span>tryResolveScriptReference
            <span class="apidocSignatureSpan">(host, sourceFile, reference)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.typeDirectiveIsEqualTo">
            function <span class="apidocSignatureSpan">typescript.</span>typeDirectiveIsEqualTo
            <span class="apidocSignatureSpan">(oldResolution, newResolution)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.typeToDisplayParts">
            function <span class="apidocSignatureSpan">typescript.</span>typeToDisplayParts
            <span class="apidocSignatureSpan">(typechecker, type, enclosingDeclaration, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.unescapeIdentifier">
            function <span class="apidocSignatureSpan">typescript.</span>unescapeIdentifier
            <span class="apidocSignatureSpan">(identifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.unorderedRemoveItem">
            function <span class="apidocSignatureSpan">typescript.</span>unorderedRemoveItem
            <span class="apidocSignatureSpan">(array, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.unorderedRemoveItemAt">
            function <span class="apidocSignatureSpan">typescript.</span>unorderedRemoveItemAt
            <span class="apidocSignatureSpan">(array, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.unwrapInnermostStatmentOfLabel">
            function <span class="apidocSignatureSpan">typescript.</span>unwrapInnermostStatmentOfLabel
            <span class="apidocSignatureSpan">(node, beforeUnwrapLabelCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateArrayBindingPattern">
            function <span class="apidocSignatureSpan">typescript.</span>updateArrayBindingPattern
            <span class="apidocSignatureSpan">(node, elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateArrayLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>updateArrayLiteral
            <span class="apidocSignatureSpan">(node, elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateArrowFunction">
            function <span class="apidocSignatureSpan">typescript.</span>updateArrowFunction
            <span class="apidocSignatureSpan">(node, modifiers, typeParameters, parameters, type, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateAsExpression">
            function <span class="apidocSignatureSpan">typescript.</span>updateAsExpression
            <span class="apidocSignatureSpan">(node, expression, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateAwait">
            function <span class="apidocSignatureSpan">typescript.</span>updateAwait
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateBinary">
            function <span class="apidocSignatureSpan">typescript.</span>updateBinary
            <span class="apidocSignatureSpan">(node, left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateBindingElement">
            function <span class="apidocSignatureSpan">typescript.</span>updateBindingElement
            <span class="apidocSignatureSpan">(node, dotDotDotToken, propertyName, name, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateBlock">
            function <span class="apidocSignatureSpan">typescript.</span>updateBlock
            <span class="apidocSignatureSpan">(node, statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateBreak">
            function <span class="apidocSignatureSpan">typescript.</span>updateBreak
            <span class="apidocSignatureSpan">(node, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateBundle">
            function <span class="apidocSignatureSpan">typescript.</span>updateBundle
            <span class="apidocSignatureSpan">(node, sourceFiles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateCall">
            function <span class="apidocSignatureSpan">typescript.</span>updateCall
            <span class="apidocSignatureSpan">(node, expression, typeArguments, argumentsArray)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateCaseBlock">
            function <span class="apidocSignatureSpan">typescript.</span>updateCaseBlock
            <span class="apidocSignatureSpan">(node, clauses)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateCaseClause">
            function <span class="apidocSignatureSpan">typescript.</span>updateCaseClause
            <span class="apidocSignatureSpan">(node, expression, statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateCatchClause">
            function <span class="apidocSignatureSpan">typescript.</span>updateCatchClause
            <span class="apidocSignatureSpan">(node, variableDeclaration, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateClassDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>updateClassDeclaration
            <span class="apidocSignatureSpan">(node, decorators, modifiers, name, typeParameters, heritageClauses, members)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateClassExpression">
            function <span class="apidocSignatureSpan">typescript.</span>updateClassExpression
            <span class="apidocSignatureSpan">(node, modifiers, name, typeParameters, heritageClauses, members)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateComputedPropertyName">
            function <span class="apidocSignatureSpan">typescript.</span>updateComputedPropertyName
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateConditional">
            function <span class="apidocSignatureSpan">typescript.</span>updateConditional
            <span class="apidocSignatureSpan">(node, condition, whenTrue, whenFalse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateConstructor">
            function <span class="apidocSignatureSpan">typescript.</span>updateConstructor
            <span class="apidocSignatureSpan">(node, decorators, modifiers, parameters, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateContinue">
            function <span class="apidocSignatureSpan">typescript.</span>updateContinue
            <span class="apidocSignatureSpan">(node, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateDecorator">
            function <span class="apidocSignatureSpan">typescript.</span>updateDecorator
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateDefaultClause">
            function <span class="apidocSignatureSpan">typescript.</span>updateDefaultClause
            <span class="apidocSignatureSpan">(node, statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateDelete">
            function <span class="apidocSignatureSpan">typescript.</span>updateDelete
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateDo">
            function <span class="apidocSignatureSpan">typescript.</span>updateDo
            <span class="apidocSignatureSpan">(node, statement, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateElementAccess">
            function <span class="apidocSignatureSpan">typescript.</span>updateElementAccess
            <span class="apidocSignatureSpan">(node, expression, argumentExpression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateEnumDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>updateEnumDeclaration
            <span class="apidocSignatureSpan">(node, decorators, modifiers, name, members)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateEnumMember">
            function <span class="apidocSignatureSpan">typescript.</span>updateEnumMember
            <span class="apidocSignatureSpan">(node, name, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateExportAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>updateExportAssignment
            <span class="apidocSignatureSpan">(node, decorators, modifiers, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateExportDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>updateExportDeclaration
            <span class="apidocSignatureSpan">(node, decorators, modifiers, exportClause, moduleSpecifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateExportSpecifier">
            function <span class="apidocSignatureSpan">typescript.</span>updateExportSpecifier
            <span class="apidocSignatureSpan">(node, name, propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateExpressionWithTypeArguments">
            function <span class="apidocSignatureSpan">typescript.</span>updateExpressionWithTypeArguments
            <span class="apidocSignatureSpan">(node, typeArguments, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateExternalModuleReference">
            function <span class="apidocSignatureSpan">typescript.</span>updateExternalModuleReference
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateFor">
            function <span class="apidocSignatureSpan">typescript.</span>updateFor
            <span class="apidocSignatureSpan">(node, initializer, condition, incrementor, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateForIn">
            function <span class="apidocSignatureSpan">typescript.</span>updateForIn
            <span class="apidocSignatureSpan">(node, initializer, expression, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateForOf">
            function <span class="apidocSignatureSpan">typescript.</span>updateForOf
            <span class="apidocSignatureSpan">(node, initializer, expression, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateFunctionDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>updateFunctionDeclaration
            <span class="apidocSignatureSpan">(node, decorators, modifiers, name, typeParameters, parameters, type, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateFunctionExpression">
            function <span class="apidocSignatureSpan">typescript.</span>updateFunctionExpression
            <span class="apidocSignatureSpan">(node, modifiers, name, typeParameters, parameters, type, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateGetAccessor">
            function <span class="apidocSignatureSpan">typescript.</span>updateGetAccessor
            <span class="apidocSignatureSpan">(node, decorators, modifiers, name, parameters, type, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateHeritageClause">
            function <span class="apidocSignatureSpan">typescript.</span>updateHeritageClause
            <span class="apidocSignatureSpan">(node, types)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateIf">
            function <span class="apidocSignatureSpan">typescript.</span>updateIf
            <span class="apidocSignatureSpan">(node, expression, thenStatement, elseStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateImportClause">
            function <span class="apidocSignatureSpan">typescript.</span>updateImportClause
            <span class="apidocSignatureSpan">(node, name, namedBindings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateImportDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>updateImportDeclaration
            <span class="apidocSignatureSpan">(node, decorators, modifiers, importClause, moduleSpecifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateImportEqualsDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>updateImportEqualsDeclaration
            <span class="apidocSignatureSpan">(node, decorators, modifiers, name, moduleReference)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateImportSpecifier">
            function <span class="apidocSignatureSpan">typescript.</span>updateImportSpecifier
            <span class="apidocSignatureSpan">(node, propertyName, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateJsxAttribute">
            function <span class="apidocSignatureSpan">typescript.</span>updateJsxAttribute
            <span class="apidocSignatureSpan">(node, name, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateJsxClosingElement">
            function <span class="apidocSignatureSpan">typescript.</span>updateJsxClosingElement
            <span class="apidocSignatureSpan">(node, tagName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateJsxElement">
            function <span class="apidocSignatureSpan">typescript.</span>updateJsxElement
            <span class="apidocSignatureSpan">(node, openingElement, children, closingElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateJsxExpression">
            function <span class="apidocSignatureSpan">typescript.</span>updateJsxExpression
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateJsxOpeningElement">
            function <span class="apidocSignatureSpan">typescript.</span>updateJsxOpeningElement
            <span class="apidocSignatureSpan">(node, tagName, attributes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateJsxSelfClosingElement">
            function <span class="apidocSignatureSpan">typescript.</span>updateJsxSelfClosingElement
            <span class="apidocSignatureSpan">(node, tagName, attributes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateJsxSpreadAttribute">
            function <span class="apidocSignatureSpan">typescript.</span>updateJsxSpreadAttribute
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateLabel">
            function <span class="apidocSignatureSpan">typescript.</span>updateLabel
            <span class="apidocSignatureSpan">(node, label, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateLanguageServiceSourceFile">
            function <span class="apidocSignatureSpan">typescript.</span>updateLanguageServiceSourceFile
            <span class="apidocSignatureSpan">(sourceFile, scriptSnapshot, version, textChangeRange, aggressiveChecks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateMethod">
            function <span class="apidocSignatureSpan">typescript.</span>updateMethod
            <span class="apidocSignatureSpan">(node, decorators, modifiers, name, typeParameters, parameters, type, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateModuleBlock">
            function <span class="apidocSignatureSpan">typescript.</span>updateModuleBlock
            <span class="apidocSignatureSpan">(node, statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateModuleDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>updateModuleDeclaration
            <span class="apidocSignatureSpan">(node, decorators, modifiers, name, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateNamedExports">
            function <span class="apidocSignatureSpan">typescript.</span>updateNamedExports
            <span class="apidocSignatureSpan">(node, elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateNamedImports">
            function <span class="apidocSignatureSpan">typescript.</span>updateNamedImports
            <span class="apidocSignatureSpan">(node, elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateNamespaceImport">
            function <span class="apidocSignatureSpan">typescript.</span>updateNamespaceImport
            <span class="apidocSignatureSpan">(node, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateNew">
            function <span class="apidocSignatureSpan">typescript.</span>updateNew
            <span class="apidocSignatureSpan">(node, expression, typeArguments, argumentsArray)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateNode">
            function <span class="apidocSignatureSpan">typescript.</span>updateNode
            <span class="apidocSignatureSpan">(updated, original)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateNonNullExpression">
            function <span class="apidocSignatureSpan">typescript.</span>updateNonNullExpression
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateObjectBindingPattern">
            function <span class="apidocSignatureSpan">typescript.</span>updateObjectBindingPattern
            <span class="apidocSignatureSpan">(node, elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateObjectLiteral">
            function <span class="apidocSignatureSpan">typescript.</span>updateObjectLiteral
            <span class="apidocSignatureSpan">(node, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateParameter">
            function <span class="apidocSignatureSpan">typescript.</span>updateParameter
            <span class="apidocSignatureSpan">(node, decorators, modifiers, dotDotDotToken, name, type, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateParen">
            function <span class="apidocSignatureSpan">typescript.</span>updateParen
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updatePartiallyEmittedExpression">
            function <span class="apidocSignatureSpan">typescript.</span>updatePartiallyEmittedExpression
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updatePostfix">
            function <span class="apidocSignatureSpan">typescript.</span>updatePostfix
            <span class="apidocSignatureSpan">(node, operand)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updatePrefix">
            function <span class="apidocSignatureSpan">typescript.</span>updatePrefix
            <span class="apidocSignatureSpan">(node, operand)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateProperty">
            function <span class="apidocSignatureSpan">typescript.</span>updateProperty
            <span class="apidocSignatureSpan">(node, decorators, modifiers, name, type, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updatePropertyAccess">
            function <span class="apidocSignatureSpan">typescript.</span>updatePropertyAccess
            <span class="apidocSignatureSpan">(node, expression, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updatePropertyAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>updatePropertyAssignment
            <span class="apidocSignatureSpan">(node, name, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateQualifiedName">
            function <span class="apidocSignatureSpan">typescript.</span>updateQualifiedName
            <span class="apidocSignatureSpan">(node, left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateReturn">
            function <span class="apidocSignatureSpan">typescript.</span>updateReturn
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateSetAccessor">
            function <span class="apidocSignatureSpan">typescript.</span>updateSetAccessor
            <span class="apidocSignatureSpan">(node, decorators, modifiers, name, parameters, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateShorthandPropertyAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>updateShorthandPropertyAssignment
            <span class="apidocSignatureSpan">(node, name, objectAssignmentInitializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateSourceFile">
            function <span class="apidocSignatureSpan">typescript.</span>updateSourceFile
            <span class="apidocSignatureSpan">(sourceFile, newText, textChangeRange, aggressiveChecks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateSourceFileNode">
            function <span class="apidocSignatureSpan">typescript.</span>updateSourceFileNode
            <span class="apidocSignatureSpan">(node, statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateSpread">
            function <span class="apidocSignatureSpan">typescript.</span>updateSpread
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateSpreadAssignment">
            function <span class="apidocSignatureSpan">typescript.</span>updateSpreadAssignment
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateStatement">
            function <span class="apidocSignatureSpan">typescript.</span>updateStatement
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateSwitch">
            function <span class="apidocSignatureSpan">typescript.</span>updateSwitch
            <span class="apidocSignatureSpan">(node, expression, caseBlock)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateTaggedTemplate">
            function <span class="apidocSignatureSpan">typescript.</span>updateTaggedTemplate
            <span class="apidocSignatureSpan">(node, tag, template)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateTemplateExpression">
            function <span class="apidocSignatureSpan">typescript.</span>updateTemplateExpression
            <span class="apidocSignatureSpan">(node, head, templateSpans)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateTemplateSpan">
            function <span class="apidocSignatureSpan">typescript.</span>updateTemplateSpan
            <span class="apidocSignatureSpan">(node, expression, literal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateThrow">
            function <span class="apidocSignatureSpan">typescript.</span>updateThrow
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateTry">
            function <span class="apidocSignatureSpan">typescript.</span>updateTry
            <span class="apidocSignatureSpan">(node, tryBlock, catchClause, finallyBlock)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateTypeAssertion">
            function <span class="apidocSignatureSpan">typescript.</span>updateTypeAssertion
            <span class="apidocSignatureSpan">(node, type, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateTypeOf">
            function <span class="apidocSignatureSpan">typescript.</span>updateTypeOf
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateVariableDeclaration">
            function <span class="apidocSignatureSpan">typescript.</span>updateVariableDeclaration
            <span class="apidocSignatureSpan">(node, name, type, initializer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateVariableDeclarationList">
            function <span class="apidocSignatureSpan">typescript.</span>updateVariableDeclarationList
            <span class="apidocSignatureSpan">(node, declarations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateVariableStatement">
            function <span class="apidocSignatureSpan">typescript.</span>updateVariableStatement
            <span class="apidocSignatureSpan">(node, modifiers, declarationList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateVoid">
            function <span class="apidocSignatureSpan">typescript.</span>updateVoid
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateWhile">
            function <span class="apidocSignatureSpan">typescript.</span>updateWhile
            <span class="apidocSignatureSpan">(node, expression, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateWith">
            function <span class="apidocSignatureSpan">typescript.</span>updateWith
            <span class="apidocSignatureSpan">(node, expression, statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.updateYield">
            function <span class="apidocSignatureSpan">typescript.</span>updateYield
            <span class="apidocSignatureSpan">(node, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.validateLocaleAndSetLanguage">
            function <span class="apidocSignatureSpan">typescript.</span>validateLocaleAndSetLanguage
            <span class="apidocSignatureSpan">(locale, sys, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.visitEachChild">
            function <span class="apidocSignatureSpan">typescript.</span>visitEachChild
            <span class="apidocSignatureSpan">(node, visitor, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.visitFunctionBody">
            function <span class="apidocSignatureSpan">typescript.</span>visitFunctionBody
            <span class="apidocSignatureSpan">(node, visitor, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.visitLexicalEnvironment">
            function <span class="apidocSignatureSpan">typescript.</span>visitLexicalEnvironment
            <span class="apidocSignatureSpan">(statements, visitor, context, start, ensureUseStrict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.visitNode">
            function <span class="apidocSignatureSpan">typescript.</span>visitNode
            <span class="apidocSignatureSpan">(node, visitor, test, optional, lift)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.visitNodes">
            function <span class="apidocSignatureSpan">typescript.</span>visitNodes
            <span class="apidocSignatureSpan">(nodes, visitor, test, start, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.visitParameterList">
            function <span class="apidocSignatureSpan">typescript.</span>visitParameterList
            <span class="apidocSignatureSpan">(nodes, visitor, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.writeCommentRange">
            function <span class="apidocSignatureSpan">typescript.</span>writeCommentRange
            <span class="apidocSignatureSpan">(text, lineMap, writer, commentPos, commentEnd, newLine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.writeDeclarationFile">
            function <span class="apidocSignatureSpan">typescript.</span>writeDeclarationFile
            <span class="apidocSignatureSpan">(declarationFilePath, sourceFileOrBundle, host, resolver, emitterDiagnostics, emitOnlyDtsFiles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.writeFile">
            function <span class="apidocSignatureSpan">typescript.</span>writeFile
            <span class="apidocSignatureSpan">(host, diagnostics, fileName, data, writeByteOrderMark, sourceFiles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.zipWith">
            function <span class="apidocSignatureSpan">typescript.</span>zipWith
            <span class="apidocSignatureSpan">(arrayA, arrayB, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>AssertionLevel</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>AssignmentKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>Associativity</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>BreakpointResolver</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>CharacterCodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>CheckFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ClassificationType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>Comparison</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>Completions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>CoreServicesShimHostAdapter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>Debug</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>DiagnosticCategory</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>DiagnosticStyle</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>Diagnostics</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>DocumentHighlights</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>EmitFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>EmitHint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>EndOfLineState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ExitStatus</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>Extension</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ExtensionPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ExternalEmitHelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>FindAllReferences</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>FlattenLevel</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>FlowFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>GeneratedIdentifierKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>GoToDefinition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>GoToImplementation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>HighlightSpanKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>IndentStyle</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>IndexKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>JsDoc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>JsTyping</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>JsxEmit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>JsxFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>LanguageServiceShimHostAdapter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>LanguageVariant</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ModifierFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ModuleInstanceState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ModuleKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ModuleResolutionKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>NavigateTo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>NavigationBar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>NewLineKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>NodeCheckFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>NodeFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>NumericLiteralFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ObjectFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>OuterExpressionKinds</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>OutliningElementsCollector</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>OutputFileType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>PatternMatchKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>RelationComparisonResult</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>Rename</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ScriptElementKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ScriptElementKindModifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ScriptKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ScriptSnapshot</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>ScriptTarget</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SemanticMeaning</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SignatureHelp</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SignatureKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SpecialPropertyAssignmentKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SymbolAccessibility</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SymbolDisplay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SymbolDisplayPartKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SymbolFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SymbolFormatFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SyntaxKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>SyntheticSymbolKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>Ternary</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>TokenClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>TransformFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>TypeFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>TypeFormatFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>TypePredicateKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>TypeReferenceSerializationKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>TypeScriptServicesFactory.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>WatchDirectoryFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>codefix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>collator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>compileOnSaveCommandLineOption</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>defaultInitCompilerOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>emptyArray</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.FormattingContext.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.Rule.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.RuleDescriptor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.RuleOperation.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.RuleOperationContext.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.Rules.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.RulesBucket.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.RulesBucketConstructionState.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.RulesMap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.RulesProvider.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.Shared</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.Shared.TokenAllAccess.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.Shared.TokenRange.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.Shared.TokenRangeAccess.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.Shared.TokenSingleValueAccess.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.Shared.TokenValuesAccess.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>formatting.SmartIndenter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>fullTripleSlashAMDReferencePathRegEx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>fullTripleSlashReferencePathRegEx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>fullTripleSlashReferenceTypeReferenceDirectiveRegEx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>objectAllocator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>optionDeclarations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>performance</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>scanner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>supportedJavascriptExtensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>supportedTypeScriptExtensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>supportedTypescriptExtensionsForExtractExtension</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>sys</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>typeAcquisitionDeclarations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.</span>unchangedTextChangeRange</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">typescript.</span>directorySeparator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">typescript.</span>externalHelpersModuleNameText</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">typescript.</span>servicesVersion</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">typescript.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.BreakpointResolver">module typescript.BreakpointResolver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.BreakpointResolver.spanInSourceFileAtLocation">
            function <span class="apidocSignatureSpan">typescript.BreakpointResolver.</span>spanInSourceFileAtLocation
            <span class="apidocSignatureSpan">(sourceFile, position)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.Completions">module typescript.Completions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Completions.getCompletionEntryDetails">
            function <span class="apidocSignatureSpan">typescript.Completions.</span>getCompletionEntryDetails
            <span class="apidocSignatureSpan">(typeChecker, log, compilerOptions, sourceFile, position, entryName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Completions.getCompletionEntrySymbol">
            function <span class="apidocSignatureSpan">typescript.Completions.</span>getCompletionEntrySymbol
            <span class="apidocSignatureSpan">(typeChecker, log, compilerOptions, sourceFile, position, entryName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Completions.getCompletionsAtPosition">
            function <span class="apidocSignatureSpan">typescript.Completions.</span>getCompletionsAtPosition
            <span class="apidocSignatureSpan">(host, typeChecker, log, compilerOptions, sourceFile, position)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.CoreServicesShimHostAdapter">module typescript.CoreServicesShimHostAdapter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.CoreServicesShimHostAdapter.CoreServicesShimHostAdapter">
            function <span class="apidocSignatureSpan">typescript.</span>CoreServicesShimHostAdapter
            <span class="apidocSignatureSpan">(shimHost)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.CoreServicesShimHostAdapter.prototype">module typescript.CoreServicesShimHostAdapter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.fileExists">
            function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>fileExists
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.getDirectories">
            function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>getDirectories
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.readDirectory">
            function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>readDirectory
            <span class="apidocSignatureSpan">(rootDir, extensions, exclude, include, depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.readDirectoryFallback">
            function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>readDirectoryFallback
            <span class="apidocSignatureSpan">(rootDir, extension, exclude)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.readFile">
            function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>readFile
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.Debug">module typescript.Debug</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.assert">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>assert
            <span class="apidocSignatureSpan">(expression, message, verboseDebugInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.assertEachNode">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>assertEachNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.assertMissingNode">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>assertMissingNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.assertNode">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>assertNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.assertOptionalNode">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>assertOptionalNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.assertOptionalToken">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>assertOptionalToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.fail">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>fail
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.failBadSyntaxKind">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>failBadSyntaxKind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.failNotOptional">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>failNotOptional
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Debug.shouldAssert">
            function <span class="apidocSignatureSpan">typescript.Debug.</span>shouldAssert
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">typescript.Debug.</span>currentAssertionLevel</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.DocumentHighlights">module typescript.DocumentHighlights</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.DocumentHighlights.getDocumentHighlights">
            function <span class="apidocSignatureSpan">typescript.DocumentHighlights.</span>getDocumentHighlights
            <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFile, position, sourceFilesToSearch)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.FindAllReferences">module typescript.FindAllReferences</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.FindAllReferences.convertReferences">
            function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>convertReferences
            <span class="apidocSignatureSpan">(referenceSymbols)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.FindAllReferences.findReferencedSymbols">
            function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>findReferencedSymbols
            <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFiles, sourceFile, position, findInStrings, findInComments, isForRename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.FindAllReferences.getReferenceEntriesForShorthandPropertyAssignment">
            function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>getReferenceEntriesForShorthandPropertyAssignment
            <span class="apidocSignatureSpan">(node, typeChecker, result)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.FindAllReferences.getReferenceEntryFromNode">
            function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>getReferenceEntryFromNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.FindAllReferences.getReferencedSymbolsForNode">
            function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>getReferencedSymbolsForNode
            <span class="apidocSignatureSpan">(typeChecker, cancellationToken, node, sourceFiles, findInStrings, findInComments, isForRename , implementations)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.GoToDefinition">module typescript.GoToDefinition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.GoToDefinition.getDefinitionAtPosition">
            function <span class="apidocSignatureSpan">typescript.GoToDefinition.</span>getDefinitionAtPosition
            <span class="apidocSignatureSpan">(program, sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.GoToDefinition.getTypeDefinitionAtPosition">
            function <span class="apidocSignatureSpan">typescript.GoToDefinition.</span>getTypeDefinitionAtPosition
            <span class="apidocSignatureSpan">(typeChecker, sourceFile, position)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.GoToImplementation">module typescript.GoToImplementation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.GoToImplementation.getImplementationAtPosition">
            function <span class="apidocSignatureSpan">typescript.GoToImplementation.</span>getImplementationAtPosition
            <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFiles, node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.JsDoc">module typescript.JsDoc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.JsDoc.getAllJsDocCompletionEntries">
            function <span class="apidocSignatureSpan">typescript.JsDoc.</span>getAllJsDocCompletionEntries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.JsDoc.getDocCommentTemplateAtPosition">
            function <span class="apidocSignatureSpan">typescript.JsDoc.</span>getDocCommentTemplateAtPosition
            <span class="apidocSignatureSpan">(newLine, sourceFile, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.JsDoc.getJsDocCommentsFromDeclarations">
            function <span class="apidocSignatureSpan">typescript.JsDoc.</span>getJsDocCommentsFromDeclarations
            <span class="apidocSignatureSpan">(declarations)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.JsTyping">module typescript.JsTyping</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.JsTyping.discoverTypings">
            function <span class="apidocSignatureSpan">typescript.JsTyping.</span>discoverTypings
            <span class="apidocSignatureSpan">(host, fileNames, projectRootPath, safeListPath, packageNameToTypingLocation, typeAcquisition, unresolvedImports )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.JsTyping.</span>nodeCoreModuleList</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.LanguageServiceShimHostAdapter">module typescript.LanguageServiceShimHostAdapter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.LanguageServiceShimHostAdapter">
            function <span class="apidocSignatureSpan">typescript.</span>LanguageServiceShimHostAdapter
            <span class="apidocSignatureSpan">(shimHost)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.LanguageServiceShimHostAdapter.prototype">module typescript.LanguageServiceShimHostAdapter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.error">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>error
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.fileExists">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>fileExists
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getCancellationToken">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getCancellationToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getCompilationSettings">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getCompilationSettings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getCurrentDirectory">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getCurrentDirectory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getDefaultLibFileName">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getDefaultLibFileName
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getDirectories">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getDirectories
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getLocalizedDiagnosticMessages">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getLocalizedDiagnosticMessages
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getProjectVersion">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getProjectVersion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptFileNames">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getScriptFileNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptKind">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getScriptKind
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptSnapshot">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getScriptSnapshot
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptVersion">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getScriptVersion
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getTypeRootsVersion">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getTypeRootsVersion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.log">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>log
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.readDirectory">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>readDirectory
            <span class="apidocSignatureSpan">(path, extensions, exclude, include, depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.readFile">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>readFile
            <span class="apidocSignatureSpan">(path, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.trace">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>trace
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.useCaseSensitiveFileNames">
            function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>useCaseSensitiveFileNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.NavigateTo">module typescript.NavigateTo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.NavigateTo.getNavigateToItems">
            function <span class="apidocSignatureSpan">typescript.NavigateTo.</span>getNavigateToItems
            <span class="apidocSignatureSpan">(sourceFiles, checker, cancellationToken, searchValue, maxResultCount, excludeDtsFiles)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.NavigationBar">module typescript.NavigationBar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.NavigationBar.getNavigationBarItems">
            function <span class="apidocSignatureSpan">typescript.NavigationBar.</span>getNavigationBarItems
            <span class="apidocSignatureSpan">(sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.NavigationBar.getNavigationTree">
            function <span class="apidocSignatureSpan">typescript.NavigationBar.</span>getNavigationTree
            <span class="apidocSignatureSpan">(sourceFile)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.OutliningElementsCollector">module typescript.OutliningElementsCollector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.OutliningElementsCollector.collectElements">
            function <span class="apidocSignatureSpan">typescript.OutliningElementsCollector.</span>collectElements
            <span class="apidocSignatureSpan">(sourceFile)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.Rename">module typescript.Rename</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.Rename.getRenameInfo">
            function <span class="apidocSignatureSpan">typescript.Rename.</span>getRenameInfo
            <span class="apidocSignatureSpan">(typeChecker, defaultLibFileName, getCanonicalFileName, sourceFile, position)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.ScriptSnapshot">module typescript.ScriptSnapshot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.ScriptSnapshot.fromString">
            function <span class="apidocSignatureSpan">typescript.ScriptSnapshot.</span>fromString
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.SignatureHelp">module typescript.SignatureHelp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.SignatureHelp.getContainingArgumentInfo">
            function <span class="apidocSignatureSpan">typescript.SignatureHelp.</span>getContainingArgumentInfo
            <span class="apidocSignatureSpan">(node, position, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.SignatureHelp.getImmediatelyContainingArgumentInfo">
            function <span class="apidocSignatureSpan">typescript.SignatureHelp.</span>getImmediatelyContainingArgumentInfo
            <span class="apidocSignatureSpan">(node, position, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.SignatureHelp.getSignatureHelpItems">
            function <span class="apidocSignatureSpan">typescript.SignatureHelp.</span>getSignatureHelpItems
            <span class="apidocSignatureSpan">(program, sourceFile, position, cancellationToken)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.SignatureHelp.</span>ArgumentListKind</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.SymbolDisplay">module typescript.SymbolDisplay</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind">
            function <span class="apidocSignatureSpan">typescript.SymbolDisplay.</span>getSymbolDisplayPartsDocumentationAndSymbolKind
            <span class="apidocSignatureSpan">(typeChecker, symbol, sourceFile, enclosingDeclaration, location, semanticMeaning )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.SymbolDisplay.getSymbolKind">
            function <span class="apidocSignatureSpan">typescript.SymbolDisplay.</span>getSymbolKind
            <span class="apidocSignatureSpan">(typeChecker, symbol, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.SymbolDisplay.getSymbolModifiers">
            function <span class="apidocSignatureSpan">typescript.SymbolDisplay.</span>getSymbolModifiers
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.TypeScriptServicesFactory">module typescript.TypeScriptServicesFactory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TypeScriptServicesFactory.TypeScriptServicesFactory">
            function <span class="apidocSignatureSpan">typescript.</span>TypeScriptServicesFactory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.TypeScriptServicesFactory.prototype">module typescript.TypeScriptServicesFactory.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.close">
            function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.createClassifierShim">
            function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>createClassifierShim
            <span class="apidocSignatureSpan">(logger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.createCoreServicesShim">
            function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>createCoreServicesShim
            <span class="apidocSignatureSpan">(host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.createLanguageServiceShim">
            function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>createLanguageServiceShim
            <span class="apidocSignatureSpan">(host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.getServicesVersion">
            function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>getServicesVersion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.registerShim">
            function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>registerShim
            <span class="apidocSignatureSpan">(shim)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.unregisterShim">
            function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>unregisterShim
            <span class="apidocSignatureSpan">(shim)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.codefix">module typescript.codefix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.codefix.getFixes">
            function <span class="apidocSignatureSpan">typescript.codefix.</span>getFixes
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.codefix.getMissingMembersInsertion">
            function <span class="apidocSignatureSpan">typescript.codefix.</span>getMissingMembersInsertion
            <span class="apidocSignatureSpan">(classDeclaration, possiblyMissingSymbols, checker, newlineChar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.codefix.getStubbedMethod">
            function <span class="apidocSignatureSpan">typescript.codefix.</span>getStubbedMethod
            <span class="apidocSignatureSpan">(visibility, name, sigString, newlineChar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.codefix.getSupportedErrorCodes">
            function <span class="apidocSignatureSpan">typescript.codefix.</span>getSupportedErrorCodes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.codefix.registerCodeFix">
            function <span class="apidocSignatureSpan">typescript.codefix.</span>registerCodeFix
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting">module typescript.formatting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>FormattingContext
            <span class="apidocSignatureSpan">(sourceFile, formattingRequestKind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rule">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>Rule
            <span class="apidocSignatureSpan">(Descriptor, Operation, Flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleDescriptor">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleDescriptor
            <span class="apidocSignatureSpan">(LeftTokenRange, RightTokenRange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperation">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleOperation
            <span class="apidocSignatureSpan">(Context, Action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperationContext">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleOperationContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>Rules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucket">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesBucket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucketConstructionState">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesBucketConstructionState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesMap">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesProvider">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesProvider
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.formatDocument">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>formatDocument
            <span class="apidocSignatureSpan">(sourceFile, rulesProvider, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.formatOnClosingCurly">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>formatOnClosingCurly
            <span class="apidocSignatureSpan">(position, sourceFile, rulesProvider, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.formatOnEnter">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>formatOnEnter
            <span class="apidocSignatureSpan">(position, sourceFile, rulesProvider, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.formatOnSemicolon">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>formatOnSemicolon
            <span class="apidocSignatureSpan">(position, sourceFile, rulesProvider, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.formatSelection">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>formatSelection
            <span class="apidocSignatureSpan">(start, end, sourceFile, rulesProvider, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.getFormattingScanner">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>getFormattingScanner
            <span class="apidocSignatureSpan">(sourceFile, startPos, endPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.getIndentationString">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>getIndentationString
            <span class="apidocSignatureSpan">(indentation, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.formatting.</span>FormattingRequestKind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.formatting.</span>RuleAction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.formatting.</span>RuleFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.formatting.</span>RulesPosition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.formatting.</span>Shared</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.formatting.</span>SmartIndenter</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.FormattingContext">module typescript.formatting.FormattingContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext.FormattingContext">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>FormattingContext
            <span class="apidocSignatureSpan">(sourceFile, formattingRequestKind)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.FormattingContext.prototype">module typescript.formatting.FormattingContext.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext.prototype.BlockIsOnOneLine">
            function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>BlockIsOnOneLine
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext.prototype.ContextNodeAllOnSameLine">
            function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>ContextNodeAllOnSameLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext.prototype.ContextNodeBlockIsOnOneLine">
            function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>ContextNodeBlockIsOnOneLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext.prototype.NextNodeAllOnSameLine">
            function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>NextNodeAllOnSameLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext.prototype.NextNodeBlockIsOnOneLine">
            function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>NextNodeBlockIsOnOneLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext.prototype.NodeIsOnOneLine">
            function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>NodeIsOnOneLine
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext.prototype.TokensAreOnSameLine">
            function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>TokensAreOnSameLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.FormattingContext.prototype.updateContext">
            function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>updateContext
            <span class="apidocSignatureSpan">(currentRange, currentTokenParent, nextRange, nextTokenParent, commonParent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Rule">module typescript.formatting.Rule</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rule.Rule">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>Rule
            <span class="apidocSignatureSpan">(Descriptor, Operation, Flag)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Rule.prototype">module typescript.formatting.Rule.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rule.prototype.toString">
            function <span class="apidocSignatureSpan">typescript.formatting.Rule.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RuleDescriptor">module typescript.formatting.RuleDescriptor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleDescriptor.RuleDescriptor">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleDescriptor
            <span class="apidocSignatureSpan">(LeftTokenRange, RightTokenRange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleDescriptor.create1">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.</span>create1
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleDescriptor.create2">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.</span>create2
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleDescriptor.create3">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.</span>create3
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleDescriptor.create4">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.</span>create4
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RuleDescriptor.prototype">module typescript.formatting.RuleDescriptor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleDescriptor.prototype.toString">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RuleOperation">module typescript.formatting.RuleOperation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperation.RuleOperation">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleOperation
            <span class="apidocSignatureSpan">(Context, Action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperation.create1">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleOperation.</span>create1
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperation.create2">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleOperation.</span>create2
            <span class="apidocSignatureSpan">(context, action)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RuleOperation.prototype">module typescript.formatting.RuleOperation.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperation.prototype.toString">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleOperation.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RuleOperationContext">module typescript.formatting.RuleOperationContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperationContext.RuleOperationContext">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleOperationContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.formatting.RuleOperationContext.</span>Any</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RuleOperationContext.prototype">module typescript.formatting.RuleOperationContext.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperationContext.prototype.InContext">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleOperationContext.prototype.</span>InContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RuleOperationContext.prototype.IsAny">
            function <span class="apidocSignatureSpan">typescript.formatting.RuleOperationContext.prototype.</span>IsAny
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Rules">module typescript.formatting.Rules</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.Rules">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>Rules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsAfterCodeBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsAfterCodeBlockContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsArrowFunctionContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsArrowFunctionContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsBeforeBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBeforeBlockContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsBeforeMultilineBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBeforeMultilineBlockContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsBinaryOpContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBinaryOpContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBlockContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsBraceWrappedContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBraceWrappedContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsConditionalOperatorContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsConditionalOperatorContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsControlDeclContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsControlDeclContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsEndOfDecoratorContextOnSameLine">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsEndOfDecoratorContextOnSameLine
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsForContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsForContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsFunctionCallContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsFunctionCallContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsFunctionCallOrNewContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsFunctionCallOrNewContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsFunctionDeclContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsFunctionDeclContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsFunctionDeclarationOrFunctionExpressionContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsFunctionDeclarationOrFunctionExpressionContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsJsxAttributeContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsJsxAttributeContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsJsxExpressionContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsJsxExpressionContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsJsxSelfClosingElementContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsJsxSelfClosingElementContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsModuleDeclContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsModuleDeclContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsMultilineBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsMultilineBlockContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNewContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNewContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNextTokenNotCloseBracket">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNextTokenNotCloseBracket
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNextTokenParentJsxAttribute">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNextTokenParentJsxAttribute
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNonJsxElementContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNonJsxElementContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNonJsxSameLineTokenContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNonJsxSameLineTokenContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNonNullAssertionContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNonNullAssertionContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNotBeforeBlockInFunctionDeclarationContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNotBeforeBlockInFunctionDeclarationContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNotBinaryOpContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNotBinaryOpContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNotForContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNotForContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsNotFormatOnEnter">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNotFormatOnEnter
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsObjectContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsObjectContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsObjectTypeContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsObjectTypeContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsPreviousTokenNotComma">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsPreviousTokenNotComma
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsSameLineTokenOrBeforeMultilineBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsSameLineTokenOrBeforeMultilineBlockContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsSingleLineBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsSingleLineBlockContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsStartOfVariableDeclarationList">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsStartOfVariableDeclarationList
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsTypeArgumentOrParameterOrAssertion">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsTypeArgumentOrParameterOrAssertion
            <span class="apidocSignatureSpan">(token, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsTypeArgumentOrParameterOrAssertionContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsTypeArgumentOrParameterOrAssertionContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsTypeAssertionContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsTypeAssertionContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsTypeScriptDeclWithBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsTypeScriptDeclWithBlockContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsVoidOpContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsVoidOpContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.IsYieldOrYieldStarWithOperand">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsYieldOrYieldStarWithOperand
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.NodeIsBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>NodeIsBlockContext
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.NodeIsInDecoratorContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>NodeIsInDecoratorContext
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.NodeIsTypeScriptDeclWithBlockContext">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>NodeIsTypeScriptDeclWithBlockContext
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Rules.prototype">module typescript.formatting.Rules.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Rules.prototype.getRuleName">
            function <span class="apidocSignatureSpan">typescript.formatting.Rules.prototype.</span>getRuleName
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RulesBucket">module typescript.formatting.RulesBucket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucket.RulesBucket">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesBucket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RulesBucket.prototype">module typescript.formatting.RulesBucket.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucket.prototype.AddRule">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesBucket.prototype.</span>AddRule
            <span class="apidocSignatureSpan">(rule, specificTokens, constructionState, rulesBucketIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucket.prototype.Rules">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesBucket.prototype.</span>Rules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RulesBucketConstructionState">module typescript.formatting.RulesBucketConstructionState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucketConstructionState.RulesBucketConstructionState">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesBucketConstructionState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RulesBucketConstructionState.prototype">module typescript.formatting.RulesBucketConstructionState.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucketConstructionState.prototype.GetInsertionIndex">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesBucketConstructionState.prototype.</span>GetInsertionIndex
            <span class="apidocSignatureSpan">(maskPosition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesBucketConstructionState.prototype.IncreaseInsertionIndex">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesBucketConstructionState.prototype.</span>IncreaseInsertionIndex
            <span class="apidocSignatureSpan">(maskPosition)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RulesMap">module typescript.formatting.RulesMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesMap.RulesMap">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesMap.create">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.</span>create
            <span class="apidocSignatureSpan">(rules)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RulesMap.prototype">module typescript.formatting.RulesMap.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesMap.prototype.FillRule">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>FillRule
            <span class="apidocSignatureSpan">(rule, rulesBucketConstructionStateList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesMap.prototype.FillRules">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>FillRules
            <span class="apidocSignatureSpan">(rules, rulesBucketConstructionStateList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesMap.prototype.GetRule">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>GetRule
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesMap.prototype.GetRuleBucketIndex">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>GetRuleBucketIndex
            <span class="apidocSignatureSpan">(row, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesMap.prototype.Initialize">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>Initialize
            <span class="apidocSignatureSpan">(rules)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RulesProvider">module typescript.formatting.RulesProvider</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesProvider.RulesProvider">
            function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesProvider
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.RulesProvider.prototype">module typescript.formatting.RulesProvider.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesProvider.prototype.createActiveRules">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>createActiveRules
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesProvider.prototype.ensureUpToDate">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>ensureUpToDate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesProvider.prototype.getRuleByName">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>getRuleByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesProvider.prototype.getRuleName">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>getRuleName
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.RulesProvider.prototype.getRulesMap">
            function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>getRulesMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Shared">module typescript.formatting.Shared</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenAllAccess">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenAllAccess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenRange">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenRange
            <span class="apidocSignatureSpan">(tokenAccess)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenRangeAccess">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenRangeAccess
            <span class="apidocSignatureSpan">(from, to, except)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenSingleValueAccess">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenSingleValueAccess
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenValuesAccess">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenValuesAccess
            <span class="apidocSignatureSpan">(tks)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Shared.TokenAllAccess.prototype">module typescript.formatting.Shared.TokenAllAccess.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenAllAccess.prototype.Contains">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenAllAccess.prototype.</span>Contains
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenAllAccess.prototype.GetTokens">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenAllAccess.prototype.</span>GetTokens
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenAllAccess.prototype.toString">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenAllAccess.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Shared.TokenRange.prototype">module typescript.formatting.Shared.TokenRange.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenRange.prototype.Contains">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRange.prototype.</span>Contains
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenRange.prototype.GetTokens">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRange.prototype.</span>GetTokens
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenRange.prototype.toString">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRange.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Shared.TokenRangeAccess.prototype">module typescript.formatting.Shared.TokenRangeAccess.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenRangeAccess.prototype.Contains">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRangeAccess.prototype.</span>Contains
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenRangeAccess.prototype.GetTokens">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRangeAccess.prototype.</span>GetTokens
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Shared.TokenSingleValueAccess.prototype">module typescript.formatting.Shared.TokenSingleValueAccess.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenSingleValueAccess.prototype.Contains">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenSingleValueAccess.prototype.</span>Contains
            <span class="apidocSignatureSpan">(tokenValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenSingleValueAccess.prototype.GetTokens">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenSingleValueAccess.prototype.</span>GetTokens
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.Shared.TokenValuesAccess.prototype">module typescript.formatting.Shared.TokenValuesAccess.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenValuesAccess.prototype.Contains">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenValuesAccess.prototype.</span>Contains
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.Shared.TokenValuesAccess.prototype.GetTokens">
            function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenValuesAccess.prototype.</span>GetTokens
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.formatting.SmartIndenter">module typescript.formatting.SmartIndenter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.SmartIndenter.childStartsOnTheSameLineWithElseInIfStatement">
            function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>childStartsOnTheSameLineWithElseInIfStatement
            <span class="apidocSignatureSpan">(parent, child, childStartLine, sourceFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.SmartIndenter.findFirstNonWhitespaceCharacterAndColumn">
            function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>findFirstNonWhitespaceCharacterAndColumn
            <span class="apidocSignatureSpan">(startPos, endPos, sourceFile, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.SmartIndenter.findFirstNonWhitespaceColumn">
            function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>findFirstNonWhitespaceColumn
            <span class="apidocSignatureSpan">(startPos, endPos, sourceFile, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.SmartIndenter.getBaseIndentation">
            function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>getBaseIndentation
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.SmartIndenter.getIndentation">
            function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>getIndentation
            <span class="apidocSignatureSpan">(position, sourceFile, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.SmartIndenter.getIndentationForNode">
            function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>getIndentationForNode
            <span class="apidocSignatureSpan">(n, ignoreActualIndentationRange, sourceFile, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.SmartIndenter.nodeWillIndentChild">
            function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>nodeWillIndentChild
            <span class="apidocSignatureSpan">(parent, child, indentByDefault)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.formatting.SmartIndenter.shouldIndentChildNode">
            function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>shouldIndentChildNode
            <span class="apidocSignatureSpan">(parent, child)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.objectAllocator">module typescript.objectAllocator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.objectAllocator.getIdentifierConstructor">
            function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getIdentifierConstructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.objectAllocator.getNodeConstructor">
            function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getNodeConstructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.objectAllocator.getSignatureConstructor">
            function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getSignatureConstructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.objectAllocator.getSourceFileConstructor">
            function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getSourceFileConstructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.objectAllocator.getSymbolConstructor">
            function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getSymbolConstructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.objectAllocator.getTokenConstructor">
            function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getTokenConstructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.objectAllocator.getTypeConstructor">
            function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getTypeConstructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.performance">module typescript.performance</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.performance.disable">
            function <span class="apidocSignatureSpan">typescript.performance.</span>disable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.performance.enable">
            function <span class="apidocSignatureSpan">typescript.performance.</span>enable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.performance.forEachMeasure">
            function <span class="apidocSignatureSpan">typescript.performance.</span>forEachMeasure
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.performance.getCount">
            function <span class="apidocSignatureSpan">typescript.performance.</span>getCount
            <span class="apidocSignatureSpan">(markName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.performance.getDuration">
            function <span class="apidocSignatureSpan">typescript.performance.</span>getDuration
            <span class="apidocSignatureSpan">(measureName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.performance.mark">
            function <span class="apidocSignatureSpan">typescript.performance.</span>mark
            <span class="apidocSignatureSpan">(markName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.performance.measure">
            function <span class="apidocSignatureSpan">typescript.performance.</span>measure
            <span class="apidocSignatureSpan">(measureName, startMarkName, endMarkName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.scanner">module typescript.scanner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.getStartPos">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>getStartPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.getText">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>getText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.getTextPos">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>getTextPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.getToken">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>getToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.getTokenPos">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>getTokenPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.getTokenText">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>getTokenText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.getTokenValue">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>getTokenValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.hasExtendedUnicodeEscape">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>hasExtendedUnicodeEscape
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.hasPrecedingLineBreak">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>hasPrecedingLineBreak
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.isIdentifier">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>isIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.isReservedWord">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>isReservedWord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.isUnterminated">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>isUnterminated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.lookAhead">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>lookAhead
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.reScanGreaterToken">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>reScanGreaterToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.reScanJsxToken">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>reScanJsxToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.reScanSlashToken">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>reScanSlashToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.reScanTemplateToken">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>reScanTemplateToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.scan">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>scan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.scanJSDocToken">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>scanJSDocToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.scanJsxAttributeValue">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>scanJsxAttributeValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.scanJsxIdentifier">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>scanJsxIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.scanJsxToken">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>scanJsxToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.scanRange">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>scanRange
            <span class="apidocSignatureSpan">(start, length, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.setLanguageVariant">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>setLanguageVariant
            <span class="apidocSignatureSpan">(variant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.setOnError">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>setOnError
            <span class="apidocSignatureSpan">(errorCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.setScriptTarget">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>setScriptTarget
            <span class="apidocSignatureSpan">(scriptTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.setText">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>setText
            <span class="apidocSignatureSpan">(newText, start, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.setTextPos">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>setTextPos
            <span class="apidocSignatureSpan">(textPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.scanner.tryScan">
            function <span class="apidocSignatureSpan">typescript.scanner.</span>tryScan
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.typescript.sys">module typescript.sys</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">typescript.sys.</span>useCaseSensitiveFileNames</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.clearTimeout">
            function <span class="apidocSignatureSpan">typescript.sys.</span>clearTimeout
            <span class="apidocSignatureSpan">(timer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.createDirectory">
            function <span class="apidocSignatureSpan">typescript.sys.</span>createDirectory
            <span class="apidocSignatureSpan">(directoryName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.createHash">
            function <span class="apidocSignatureSpan">typescript.sys.</span>createHash
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.directoryExists">
            function <span class="apidocSignatureSpan">typescript.sys.</span>directoryExists
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.exit">
            function <span class="apidocSignatureSpan">typescript.sys.</span>exit
            <span class="apidocSignatureSpan">(exitCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.fileExists">
            function <span class="apidocSignatureSpan">typescript.sys.</span>fileExists
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.getCurrentDirectory">
            function <span class="apidocSignatureSpan">typescript.sys.</span>getCurrentDirectory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.getDirectories">
            function <span class="apidocSignatureSpan">typescript.sys.</span>getDirectories
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.getEnvironmentVariable">
            function <span class="apidocSignatureSpan">typescript.sys.</span>getEnvironmentVariable
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.getExecutingFilePath">
            function <span class="apidocSignatureSpan">typescript.sys.</span>getExecutingFilePath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.getFileSize">
            function <span class="apidocSignatureSpan">typescript.sys.</span>getFileSize
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.getMemoryUsage">
            function <span class="apidocSignatureSpan">typescript.sys.</span>getMemoryUsage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.getModifiedTime">
            function <span class="apidocSignatureSpan">typescript.sys.</span>getModifiedTime
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.readDirectory">
            function <span class="apidocSignatureSpan">typescript.sys.</span>readDirectory
            <span class="apidocSignatureSpan">(path, extensions, excludes, includes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.readFile">
            function <span class="apidocSignatureSpan">typescript.sys.</span>readFile
            <span class="apidocSignatureSpan">(fileName, _encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.realpath">
            function <span class="apidocSignatureSpan">typescript.sys.</span>realpath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.resolvePath">
            function <span class="apidocSignatureSpan">typescript.sys.</span>resolvePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.setTimeout">
            function <span class="apidocSignatureSpan">typescript.sys.</span>setTimeout
            <span class="apidocSignatureSpan">(callback, after, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.tryEnableSourceMapsForHost">
            function <span class="apidocSignatureSpan">typescript.sys.</span>tryEnableSourceMapsForHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.watchDirectory">
            function <span class="apidocSignatureSpan">typescript.sys.</span>watchDirectory
            <span class="apidocSignatureSpan">(directoryName, callback, recursive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.watchFile">
            function <span class="apidocSignatureSpan">typescript.sys.</span>watchFile
            <span class="apidocSignatureSpan">(fileName, callback, pollingInterval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.write">
            function <span class="apidocSignatureSpan">typescript.sys.</span>write
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.typescript.sys.writeFile">
            function <span class="apidocSignatureSpan">typescript.sys.</span>writeFile
            <span class="apidocSignatureSpan">(path, data, writeBom)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">typescript.sys.</span>args</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">typescript.sys.</span>newLine</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript" id="apidoc.module.typescript">module typescript</a></h1>






    <h2>
        <a href="#apidoc.element.typescript.ClassificationTypeNames" id="apidoc.element.typescript.ClassificationTypeNames">
        function <span class="apidocSignatureSpan">typescript.</span>ClassificationTypeNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ClassificationTypeNames() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.CoreServicesShimHostAdapter" id="apidoc.element.typescript.CoreServicesShimHostAdapter">
        function <span class="apidocSignatureSpan">typescript.</span>CoreServicesShimHostAdapter
        <span class="apidocSignatureSpan">(shimHost)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CoreServicesShimHostAdapter(shimHost) {
    var _this = this;
    this.shimHost = shimHost;
    this.useCaseSensitiveFileNames = this.shimHost.useCaseSensitiveFileNames ? this.shimHost.useCaseSensitiveFileNames() : false
;
    if ("directoryExists" in this.shimHost) {
        this.directoryExists = function (directoryName) { return _this.shimHost.directoryExists(directoryName); };
    }
    if ("realpath" in this.shimHost) {
        this.realpath = function (path) { return _this.shimHost.realpath(path); };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter" id="apidoc.element.typescript.LanguageServiceShimHostAdapter">
        function <span class="apidocSignatureSpan">typescript.</span>LanguageServiceShimHostAdapter
        <span class="apidocSignatureSpan">(shimHost)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LanguageServiceShimHostAdapter(shimHost) {
    var _this = this;
    this.shimHost = shimHost;
    this.loggingEnabled = false;
    this.tracingEnabled = false;
    // if shimHost is a COM object then property check will become method call with no arguments.
    // 'in' does not have this effect.
    if ("getModuleResolutionsForFile" in this.shimHost) {
        this.resolveModuleNames = function (moduleNames, containingFile) {
            var resolutionsInFile = JSON.parse(_this.shimHost.getModuleResolutionsForFile(containingFile));
            return ts.map(moduleNames, function (name) {
                var result = ts.getProperty(resolutionsInFile, name);
                return result ? { resolvedFileName: result, extension: ts.extensionFromPath(result), isExternalLibraryImport: false
 } : undefined;
            });
        };
    }
    if ("directoryExists" in this.shimHost) {
        this.directoryExists = function (directoryName) { return _this.shimHost.directoryExists(directoryName); };
    }
    if ("getTypeReferenceDirectiveResolutionsForFile" in this.shimHost) {
        this.resolveTypeReferenceDirectives = function (typeDirectiveNames, containingFile) {
            var typeDirectivesForFile = JSON.parse(_this.shimHost.getTypeReferenceDirectiveResolutionsForFile(containingFile));
            return ts.map(typeDirectiveNames, function (name) { return ts.getProperty(typeDirectivesForFile, name); });
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.OperationCanceledException" id="apidoc.element.typescript.OperationCanceledException">
        function <span class="apidocSignatureSpan">typescript.</span>OperationCanceledException
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OperationCanceledException() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.TextChange" id="apidoc.element.typescript.TextChange">
        function <span class="apidocSignatureSpan">typescript.</span>TextChange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextChange() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.TypeScriptServicesFactory" id="apidoc.element.typescript.TypeScriptServicesFactory">
        function <span class="apidocSignatureSpan">typescript.</span>TypeScriptServicesFactory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TypeScriptServicesFactory() {
    this._shims = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.addEmitHelper" id="apidoc.element.typescript.addEmitHelper">
        function <span class="apidocSignatureSpan">typescript.</span>addEmitHelper
        <span class="apidocSignatureSpan">(node, helper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addEmitHelper(node, helper) {
    var emitNode = getOrCreateEmitNode(node);
    emitNode.helpers = ts.append(emitNode.helpers, helper);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.addEmitHelpers" id="apidoc.element.typescript.addEmitHelpers">
        function <span class="apidocSignatureSpan">typescript.</span>addEmitHelpers
        <span class="apidocSignatureSpan">(node, helpers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addEmitHelpers(node, helpers) {
    if (ts.some(helpers)) {
        var emitNode = getOrCreateEmitNode(node);
        for (var _i = 0, helpers_1 = helpers; _i &lt; helpers_1.length; _i++) {
            var helper = helpers_1[_i];
            if (!ts.contains(emitNode.helpers, helper)) {
                emitNode.helpers = ts.append(emitNode.helpers, helper);
            }
        }
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.addPrologueDirectives" id="apidoc.element.typescript.addPrologueDirectives">
        function <span class="apidocSignatureSpan">typescript.</span>addPrologueDirectives
        <span class="apidocSignatureSpan">(target, source, ensureUseStrict, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addPrologueDirectives(target, source, ensureUseStrict, visitor) {
    ts.Debug.assert(target.length === 0, "Prologue directives should be at the first statement in the target statements array");
    var foundUseStrict = false;
    var statementOffset = 0;
    var numStatements = source.length;
    while (statementOffset &lt; numStatements) {
        var statement = source[statementOffset];
        if (ts.isPrologueDirective(statement)) {
            if (isUseStrictPrologue(statement)) {
                foundUseStrict = true;
            }
            target.push(statement);
        }
        else {
            break;
        }
        statementOffset++;
    }
    if (ensureUseStrict &amp;&amp; !foundUseStrict) {
        target.push(startOnNewLine(ts.createStatement(ts.createLiteral("use strict"))));
    }
    while (statementOffset &lt; numStatements) {
        var statement = source[statementOffset];
        if (ts.getEmitFlags(statement) &amp; 524288 /* CustomPrologue */) {
            target.push(visitor ? ts.visitNode(statement, visitor, ts.isStatement) : statement);
        }
        else {
            break;
        }
        statementOffset++;
    }
    return statementOffset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.addRange" id="apidoc.element.typescript.addRange">
        function <span class="apidocSignatureSpan">typescript.</span>addRange
        <span class="apidocSignatureSpan">(to, from)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addRange(to, from) {
    if (from === undefined)
        return to;
    for (var _i = 0, from_1 = from; _i &lt; from_1.length; _i++) {
        var v = from_1[_i];
        to = append(to, v);
    }
    return to;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.adjustExtensionPriority" id="apidoc.element.typescript.adjustExtensionPriority">
        function <span class="apidocSignatureSpan">typescript.</span>adjustExtensionPriority
        <span class="apidocSignatureSpan">(extensionPriority, supportedExtensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function adjustExtensionPriority(extensionPriority, supportedExtensions) {
    if (extensionPriority &lt; 2 /* DeclarationAndJavaScriptFiles */) {
        return 0 /* TypeScriptFiles */;
    }
    else if (extensionPriority &lt; supportedExtensions.length) {
        return 2 /* DeclarationAndJavaScriptFiles */;
    }
    else {
        return supportedExtensions.length;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.aggregateTransformFlags" id="apidoc.element.typescript.aggregateTransformFlags">
        function <span class="apidocSignatureSpan">typescript.</span>aggregateTransformFlags
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function aggregateTransformFlags(node) {
    aggregateTransformFlagsForNode(node);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.append" id="apidoc.element.typescript.append">
        function <span class="apidocSignatureSpan">typescript.</span>append
        <span class="apidocSignatureSpan">(to, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function append(to, value) {
    if (value === undefined)
        return to;
    if (to === undefined)
        return [value];
    to.push(value);
    return to;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.arrayFrom" id="apidoc.element.typescript.arrayFrom">
        function <span class="apidocSignatureSpan">typescript.</span>arrayFrom
        <span class="apidocSignatureSpan">(iterator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayFrom(iterator) {
    var result = [];
    for (var _a = iterator.next(), value = _a.value, done = _a.done; !done; _b = iterator.next(), value = _b.value, done = _b.done
, _b) {
        result.push(value);
    }
    return result;
    var _b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.arrayIsEqualTo" id="apidoc.element.typescript.arrayIsEqualTo">
        function <span class="apidocSignatureSpan">typescript.</span>arrayIsEqualTo
        <span class="apidocSignatureSpan">(array1, array2, equaler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayIsEqualTo(array1, array2, equaler) {
    if (!array1 || !array2) {
        return array1 === array2;
    }
    if (array1.length !== array2.length) {
        return false;
    }
    for (var i = 0; i &lt; array1.length; i++) {
        var equals = equaler ? equaler(array1[i], array2[i]) : array1[i] === array2[i];
        if (!equals) {
            return false;
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.arrayToMap" id="apidoc.element.typescript.arrayToMap">
        function <span class="apidocSignatureSpan">typescript.</span>arrayToMap
        <span class="apidocSignatureSpan">(array, makeKey, makeValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayToMap(array, makeKey, makeValue) {
    var result = createMap();
    for (var _i = 0, array_8 = array; _i &lt; array_8.length; _i++) {
        var value = array_8[_i];
        result.set(makeKey(value), makeValue ? makeValue(value) : value);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.assign" id="apidoc.element.typescript.assign">
        function <span class="apidocSignatureSpan">typescript.</span>assign
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assign(t) {
    var args = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var _a = 0, args_1 = args; _a &lt; args_1.length; _a++) {
        var arg = args_1[_a];
        for (var _b = 0, _c = getOwnKeys(arg); _b &lt; _c.length; _b++) {
            var p = _c[_b];
            t[p] = arg[p];
        }
    }
    return t;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.binarySearch" id="apidoc.element.typescript.binarySearch">
        function <span class="apidocSignatureSpan">typescript.</span>binarySearch
        <span class="apidocSignatureSpan">(array, value, comparer, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function binarySearch(array, value, comparer, offset) {
    if (!array || array.length === 0) {
        return -1;
    }
    var low = offset || 0;
    var high = array.length - 1;
    comparer = comparer !== undefined
        ? comparer
        : function (v1, v2) { return (v1 &lt; v2 ? -1 : (v1 &gt; v2 ? 1 : 0)); };
    while (low &lt;= high) {
        var middle = low + ((high - low) &gt;&gt; 1);
        var midValue = array[middle];
        if (comparer(midValue, value) === 0) {
            return middle;
        }
        else if (comparer(midValue, value) &gt; 0) {
            high = middle - 1;
        }
        else {
            low = middle + 1;
        }
    }
    return ~low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.bindSourceFile" id="apidoc.element.typescript.bindSourceFile">
        function <span class="apidocSignatureSpan">typescript.</span>bindSourceFile
        <span class="apidocSignatureSpan">(file, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bindSourceFile(file, options) {
    ts.performance.mark("beforeBind");
    binder(file, options);
    ts.performance.mark("afterBind");
    ts.performance.measure("Bind", "beforeBind", "afterBind");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.breakIntoCharacterSpans" id="apidoc.element.typescript.breakIntoCharacterSpans">
        function <span class="apidocSignatureSpan">typescript.</span>breakIntoCharacterSpans
        <span class="apidocSignatureSpan">(identifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function breakIntoCharacterSpans(identifier) {
    return breakIntoSpans(identifier, /*word:*/ false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.breakIntoWordSpans" id="apidoc.element.typescript.breakIntoWordSpans">
        function <span class="apidocSignatureSpan">typescript.</span>breakIntoWordSpans
        <span class="apidocSignatureSpan">(identifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function breakIntoWordSpans(identifier) {
    return breakIntoSpans(identifier, /*word:*/ true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.chain" id="apidoc.element.typescript.chain">
        function <span class="apidocSignatureSpan">typescript.</span>chain
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chain(a, b, c, d, e) {
    if (e) {
        var args_2 = [];
        for (var i = 0; i &lt; arguments.length; i++) {
            args_2[i] = arguments[i];
        }
        return function (t) { return compose.apply(void 0, map(args_2, function (f) { return f(t); })); };
    }
    else if (d) {
        return function (t) { return compose(a(t), b(t), c(t), d(t)); };
    }
    else if (c) {
        return function (t) { return compose(a(t), b(t), c(t)); };
    }
    else if (b) {
        return function (t) { return compose(a(t), b(t)); };
    }
    else if (a) {
        return function (t) { return compose(a(t)); };
    }
    else {
        return function (_) { return function (u) { return u; }; };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.chainDiagnosticMessages" id="apidoc.element.typescript.chainDiagnosticMessages">
        function <span class="apidocSignatureSpan">typescript.</span>chainDiagnosticMessages
        <span class="apidocSignatureSpan">(details, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chainDiagnosticMessages(details, message) {
    var text = getLocaleSpecificMessage(message);
    if (arguments.length &gt; 2) {
        text = formatStringFromArgs(text, arguments, 2);
    }
    return {
        messageText: text,
        category: message.category,
        code: message.code,
        next: details
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.changeExtension" id="apidoc.element.typescript.changeExtension">
        function <span class="apidocSignatureSpan">typescript.</span>changeExtension
        <span class="apidocSignatureSpan">(path, newExtension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function changeExtension(path, newExtension) {
    return (removeFileExtension(path) + newExtension);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.changesAffectModuleResolution" id="apidoc.element.typescript.changesAffectModuleResolution">
        function <span class="apidocSignatureSpan">typescript.</span>changesAffectModuleResolution
        <span class="apidocSignatureSpan">(oldOptions, newOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function changesAffectModuleResolution(oldOptions, newOptions) {
    return !oldOptions ||
        (oldOptions.module !== newOptions.module) ||
        (oldOptions.moduleResolution !== newOptions.moduleResolution) ||
        (oldOptions.noResolve !== newOptions.noResolve) ||
        (oldOptions.target !== newOptions.target) ||
        (oldOptions.noLib !== newOptions.noLib) ||
        (oldOptions.jsx !== newOptions.jsx) ||
        (oldOptions.allowJs !== newOptions.allowJs) ||
        (oldOptions.rootDir !== newOptions.rootDir) ||
        (oldOptions.configFilePath !== newOptions.configFilePath) ||
        (oldOptions.baseUrl !== newOptions.baseUrl) ||
        (oldOptions.maxNodeModuleJsDepth !== newOptions.maxNodeModuleJsDepth) ||
        !arrayIsEqualTo(oldOptions.lib, newOptions.lib) ||
        !arrayIsEqualTo(oldOptions.typeRoots, newOptions.typeRoots) ||
        !arrayIsEqualTo(oldOptions.rootDirs, newOptions.rootDirs) ||
        !equalOwnProperties(oldOptions.paths, newOptions.paths);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.childIsDecorated" id="apidoc.element.typescript.childIsDecorated">
        function <span class="apidocSignatureSpan">typescript.</span>childIsDecorated
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function childIsDecorated(node) {
    switch (node.kind) {
        case 228 /* ClassDeclaration */:
            return ts.forEach(node.members, nodeOrChildIsDecorated);
        case 150 /* MethodDeclaration */:
        case 153 /* SetAccessor */:
            return ts.forEach(node.parameters, nodeIsDecorated);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.classicNameResolver" id="apidoc.element.typescript.classicNameResolver">
        function <span class="apidocSignatureSpan">typescript.</span>classicNameResolver
        <span class="apidocSignatureSpan">(moduleName, containingFile, compilerOptions, host, cache)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function classicNameResolver(moduleName, containingFile, compilerOptions, host, cache) {
    var traceEnabled = isTraceEnabled(compilerOptions, host);
    var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled };
    var failedLookupLocations = [];
    var containingDirectory = ts.getDirectoryPath(containingFile);
    var resolved = tryResolve(Extensions.TypeScript) || tryResolve(Extensions.JavaScript);
    return createResolvedModuleWithFailedLookupLocations(resolved &amp;&amp; resolved.value, /*isExternalLibraryImport*/ false, failedLookupLocations
);
    function tryResolve(extensions) {
        var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFile
, failedLookupLocations, state);
        if (resolvedUsingSettings) {
            return { value: resolvedUsingSettings };
        }
        var perModuleNameCache = cache &amp;&amp; cache.getOrCreateCacheForModuleName(moduleName);
        if (moduleHasNonRelativeName(moduleName)) {
            // Climb up parent directories looking for a module.
            var resolved_3 = forEachAncestorDirectory(containingDirectory, function (directory) {
                var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, directory, traceEnabled
, host);
                if (resolutionFromCache) {
                    return resolutionFromCache;
                }
                var searchName = ts.normalizePath(ts.combinePaths(directory, moduleName));
                return toSearchResult(loadModuleFromFile(extensions, searchName, failedLookupLocations, /*onlyRecordFailures*/ false
, state));
            });
            if (resolved_3) {
                return resolved_3;
            }
            if (extensions === Extensions.TypeScript) {
                // If we didn't find the file normally, look it up in @types.
                return loadModuleFromNodeModulesAtTypes(moduleName, containingDirectory, failedLookupLocations, state);
            }
        }
        else {
            var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
            return toSearchResult(loadModuleFromFile(extensions, candidate, failedLookupLocations, /*onlyRecordFailures*/ false,
state));
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.climbPastPropertyAccess" id="apidoc.element.typescript.climbPastPropertyAccess">
        function <span class="apidocSignatureSpan">typescript.</span>climbPastPropertyAccess
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function climbPastPropertyAccess(node) {
    return isRightSideOfPropertyAccess(node) ? node.parent : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.clone" id="apidoc.element.typescript.clone">
        function <span class="apidocSignatureSpan">typescript.</span>clone
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clone(object) {
    var result = {};
    for (var id in object) {
        if (hasOwnProperty.call(object, id)) {
            result[id] = object[id];
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.cloneMap" id="apidoc.element.typescript.cloneMap">
        function <span class="apidocSignatureSpan">typescript.</span>cloneMap
        <span class="apidocSignatureSpan">(map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cloneMap(map) {
    var clone = createMap();
    copyEntries(map, clone);
    return clone;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.collapseRangeToEnd" id="apidoc.element.typescript.collapseRangeToEnd">
        function <span class="apidocSignatureSpan">typescript.</span>collapseRangeToEnd
        <span class="apidocSignatureSpan">(range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function collapseRangeToEnd(range) {
    return isCollapsedRange(range) ? range : moveRangePos(range, range.end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.collapseRangeToStart" id="apidoc.element.typescript.collapseRangeToStart">
        function <span class="apidocSignatureSpan">typescript.</span>collapseRangeToStart
        <span class="apidocSignatureSpan">(range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function collapseRangeToStart(range) {
    return isCollapsedRange(range) ? range : moveRangeEnd(range, range.pos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.collapseTextChangeRangesAcrossMultipleVersions" id="apidoc.element.typescript.collapseTextChangeRangesAcrossMultipleVersions">
        function <span class="apidocSignatureSpan">typescript.</span>collapseTextChangeRangesAcrossMultipleVersions
        <span class="apidocSignatureSpan">(changes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function collapseTextChangeRangesAcrossMultipleVersions(changes) {
    if (changes.length === 0) {
        return ts.unchangedTextChangeRange;
    }
    if (changes.length === 1) {
        return changes[0];
    }
    // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }
    // as it makes things much easier to reason about.
    var change0 = changes[0];
    var oldStartN = change0.span.start;
    var oldEndN = textSpanEnd(change0.span);
    var newEndN = oldStartN + change0.newLength;
    for (var i = 1; i &lt; changes.length; i++) {
        var nextChange = changes[i];
        // Consider the following case:
        // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting
        // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.
        // i.e. the span starting at 30 with length 30 is increased to length 40.
        //
        //      0         10        20        30        40        50        60        70        80        90        100
        //      -------------------------------------------------------------------------------------------------------
        //                |                                                 /
        //                |                                            /----
        //  T1            |                                       /----
        //                |                                  /----
        //                |                             /----
        //      -------------------------------------------------------------------------------------------------------
        //                                     |                            \
        //                                     |                               \
        //   T2                                |                                 \
        //                                     |                                   \
        //                                     |                                      \
        //      -------------------------------------------------------------------------------------------------------
        //
        // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial
        // it's just the min of the old and new starts.  i.e.:
        //
        //      0         10        20        30        40        50        60        70        80        90        100
        //      ------------------------------------------------------------*------------------------------------------
        //                |                                                 /
        //                |                                            /----
        //  T1            |                                       /----
        //                |                                  /----
        //                |                             /----
        //      ----------------------------------------$-------------------$------------------------------------------
        //                .                    |                            \
        //                .                    |                               \
        //   T2           .                    |                                 \
        //                .                    |                                   \
        //                .                    |                                      \
        //      ----------------------------------------------------------------------*--------------------------------
        //
        // (Note the dots represent the newly inferred start.
        // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the
        // absolute positions at the asterisks, and the relative change between the dollar signs. Basically, we see
        // which if the two $'s precedes the other, and we move that one forward until t ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.collectExternalModuleInfo" id="apidoc.element.typescript.collectExternalModuleInfo">
        function <span class="apidocSignatureSpan">typescript.</span>collectExternalModuleInfo
        <span class="apidocSignatureSpan">(sourceFile, resolver, compilerOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function collectExternalModuleInfo(sourceFile, resolver, compilerOptions) {
    var externalImports = [];
    var exportSpecifiers = ts.createMultiMap();
    var exportedBindings = [];
    var uniqueExports = ts.createMap();
    var exportedNames;
    var hasExportDefault = false;
    var exportEquals = undefined;
    var hasExportStarsToExportValues = false;
    var externalHelpersModuleName = getOrCreateExternalHelpersModuleNameIfNeeded(sourceFile, compilerOptions);
    var externalHelpersImportDeclaration = externalHelpersModuleName &amp;&amp; ts.createImportDeclaration(
    /*decorators*/ undefined,
    /*modifiers*/ undefined, ts.createImportClause(/*name*/ undefined, ts.createNamespaceImport(externalHelpersModuleName)), ts.
createLiteral(ts.externalHelpersModuleNameText));
    if (externalHelpersImportDeclaration) {
        externalImports.push(externalHelpersImportDeclaration);
    }
    for (var _i = 0, _a = sourceFile.statements; _i &lt; _a.length; _i++) {
        var node = _a[_i];
        switch (node.kind) {
            case 237 /* ImportDeclaration */:
                // import "mod"
                // import x from "mod"
                // import * as x from "mod"
                // import { x, y } from "mod"
                externalImports.push(node);
                break;
            case 236 /* ImportEqualsDeclaration */:
                if (node.moduleReference.kind === 247 /* ExternalModuleReference */) {
                    // import x = require("mod")
                    externalImports.push(node);
                }
                break;
            case 243 /* ExportDeclaration */:
                if (node.moduleSpecifier) {
                    if (!node.exportClause) {
                        // export * from "mod"
                        externalImports.push(node);
                        hasExportStarsToExportValues = true;
                    }
                    else {
                        // export { x, y } from "mod"
                        externalImports.push(node);
                    }
                }
                else {
                    // export { x, y }
                    for (var _b = 0, _c = node.exportClause.elements; _b &lt; _c.length; _b++) {
                        var specifier = _c[_b];
                        if (!uniqueExports.get(specifier.name.text)) {
                            var name = specifier.propertyName || specifier.name;
                            exportSpecifiers.add(name.text, specifier);
                            var decl = resolver.getReferencedImportDeclaration(name)
                                || resolver.getReferencedValueDeclaration(name);
                            if (decl) {
                                multiMapSparseArrayAdd(exportedBindings, ts.getOriginalNodeId(decl), specifier.name);
                            }
                            uniqueExports.set(specifier.name.text, true);
                            exportedNames = ts.append(exportedNames, specifier.name);
                        }
                    }
                }
                break;
            case 242 /* ExportAssignment */:
                if (node.isExportEquals &amp;&amp; !exportEquals) {
                    // export = x
                    exportEquals = node;
                }
                break;
            case 207 /* VariableStatement */:
                if (ts.hasModifier(node, 1 /* Export */)) {
                    for (var _d = 0, _e = node.declarationList.declarations; _d &lt; _e.length; _d++) {
                        var decl = _e[_d];
                        exportedNames = collectExportedVariableInfo(decl, uniqueExports, exportedNames);
                    }
                }
                break;
            case 227 /* FunctionDeclaration */:
                if (ts.hasModifier(node, 1 /* Export */)) {
                    if (ts.hasModifier(node, 512 /* Default */)) {
                        // export default function() { }
                        if (!hasExportDefault) {
                            multiMapSparseArrayAdd(exportedBindings, ts.getOr ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.combinePaths" id="apidoc.element.typescript.combinePaths">
        function <span class="apidocSignatureSpan">typescript.</span>combinePaths
        <span class="apidocSignatureSpan">(path1, path2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function combinePaths(path1, path2) {
    if (!(path1 &amp;&amp; path1.length))
        return path2;
    if (!(path2 &amp;&amp; path2.length))
        return path1;
    if (getRootLength(path2) !== 0)
        return path2;
    if (path1.charAt(path1.length - 1) === ts.directorySeparator)
        return path1 + path2;
    return path1 + ts.directorySeparator + path2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.compact" id="apidoc.element.typescript.compact">
        function <span class="apidocSignatureSpan">typescript.</span>compact
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compact(array) {
    var result;
    if (array) {
        for (var i = 0; i &lt; array.length; i++) {
            var v = array[i];
            if (result || !v) {
                if (!result) {
                    result = array.slice(0, i);
                }
                if (v) {
                    result.push(v);
                }
            }
        }
    }
    return result || array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.compareDataObjects" id="apidoc.element.typescript.compareDataObjects">
        function <span class="apidocSignatureSpan">typescript.</span>compareDataObjects
        <span class="apidocSignatureSpan">(dst, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareDataObjects(dst, src) {
    for (var e in dst) {
        if (typeof dst[e] === "object") {
            if (!compareDataObjects(dst[e], src[e])) {
                return false;
            }
        }
        else if (typeof dst[e] !== "function") {
            if (dst[e] !== src[e]) {
                return false;
            }
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.compareDiagnostics" id="apidoc.element.typescript.compareDiagnostics">
        function <span class="apidocSignatureSpan">typescript.</span>compareDiagnostics
        <span class="apidocSignatureSpan">(d1, d2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareDiagnostics(d1, d2) {
    return compareValues(getDiagnosticFileName(d1), getDiagnosticFileName(d2)) ||
        compareValues(d1.start, d2.start) ||
        compareValues(d1.length, d2.length) ||
        compareValues(d1.code, d2.code) ||
        compareMessageText(d1.messageText, d2.messageText) ||
        0 /* EqualTo */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.compareEmitHelpers" id="apidoc.element.typescript.compareEmitHelpers">
        function <span class="apidocSignatureSpan">typescript.</span>compareEmitHelpers
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareEmitHelpers(x, y) {
    if (x === y)
        return 0 /* EqualTo */;
    if (x.priority === y.priority)
        return 0 /* EqualTo */;
    if (x.priority === undefined)
        return 1 /* GreaterThan */;
    if (y.priority === undefined)
        return -1 /* LessThan */;
    return ts.compareValues(x.priority, y.priority);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.comparePaths" id="apidoc.element.typescript.comparePaths">
        function <span class="apidocSignatureSpan">typescript.</span>comparePaths
        <span class="apidocSignatureSpan">(a, b, currentDirectory, ignoreCase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function comparePaths(a, b, currentDirectory, ignoreCase) {
    if (a === b)
        return 0 /* EqualTo */;
    if (a === undefined)
        return -1 /* LessThan */;
    if (b === undefined)
        return 1 /* GreaterThan */;
    a = removeTrailingDirectorySeparator(a);
    b = removeTrailingDirectorySeparator(b);
    var aComponents = getNormalizedPathComponents(a, currentDirectory);
    var bComponents = getNormalizedPathComponents(b, currentDirectory);
    var sharedLength = Math.min(aComponents.length, bComponents.length);
    for (var i = 0; i &lt; sharedLength; i++) {
        var result = compareStrings(aComponents[i], bComponents[i], ignoreCase);
        if (result !== 0 /* EqualTo */) {
            return result;
        }
    }
    return compareValues(aComponents.length, bComponents.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.compareStrings" id="apidoc.element.typescript.compareStrings">
        function <span class="apidocSignatureSpan">typescript.</span>compareStrings
        <span class="apidocSignatureSpan">(a, b, ignoreCase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareStrings(a, b, ignoreCase) {
    if (a === b)
        return 0 /* EqualTo */;
    if (a === undefined)
        return -1 /* LessThan */;
    if (b === undefined)
        return 1 /* GreaterThan */;
    if (ignoreCase) {
        // Checking if "collator exists indicates that Intl is available.
        // We still have to check if "collator.compare" is correct. If it is not, use "String.localeComapre"
        if (ts.collator) {
            var result = ts.localeCompareIsCorrect ?
                ts.collator.compare(a, b) :
                a.localeCompare(b, /*locales*/ undefined, { usage: "sort", sensitivity: "accent" }); // accent means a &nbsp; b, a &nbsp;
a, a = A
            return result &lt; 0 ? -1 /* LessThan */ : result &gt; 0 ? 1 /* GreaterThan */ : 0 /* EqualTo */;
        }
        a = a.toUpperCase();
        b = b.toUpperCase();
        if (a === b)
            return 0 /* EqualTo */;
    }
    return a &lt; b ? -1 /* LessThan */ : 1 /* GreaterThan */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.compareStringsCaseInsensitive" id="apidoc.element.typescript.compareStringsCaseInsensitive">
        function <span class="apidocSignatureSpan">typescript.</span>compareStringsCaseInsensitive
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareStringsCaseInsensitive(a, b) {
    return compareStrings(a, b, /*ignoreCase*/ true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.compareValues" id="apidoc.element.typescript.compareValues">
        function <span class="apidocSignatureSpan">typescript.</span>compareValues
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareValues(a, b) {
    if (a === b)
        return 0 /* EqualTo */;
    if (a === undefined)
        return -1 /* LessThan */;
    if (b === undefined)
        return 1 /* GreaterThan */;
    return a &lt; b ? -1 /* LessThan */ : 1 /* GreaterThan */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.compose" id="apidoc.element.typescript.compose">
        function <span class="apidocSignatureSpan">typescript.</span>compose
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compose(a, b, c, d, e) {
    if (e) {
        var args_3 = [];
        for (var i = 0; i &lt; arguments.length; i++) {
            args_3[i] = arguments[i];
        }
        return function (t) { return reduceLeft(args_3, function (u, f) { return f(u); }, t); };
    }
    else if (d) {
        return function (t) { return d(c(b(a(t)))); };
    }
    else if (c) {
        return function (t) { return c(b(a(t))); };
    }
    else if (b) {
        return function (t) { return b(a(t)); };
    }
    else if (a) {
        return function (t) { return a(t); };
    }
    else {
        return function (t) { return t; };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.computeCommonSourceDirectoryOfFilenames" id="apidoc.element.typescript.computeCommonSourceDirectoryOfFilenames">
        function <span class="apidocSignatureSpan">typescript.</span>computeCommonSourceDirectoryOfFilenames
        <span class="apidocSignatureSpan">(fileNames, currentDirectory, getCanonicalFileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeCommonSourceDirectoryOfFilenames(fileNames, currentDirectory, getCanonicalFileName) {
    var commonPathComponents;
    var failed = ts.forEach(fileNames, function (sourceFile) {
        // Each file contributes into common source file path
        var sourcePathComponents = ts.getNormalizedPathComponents(sourceFile, currentDirectory);
        sourcePathComponents.pop(); // The base file name is not part of the common directory path
        if (!commonPathComponents) {
            // first file
            commonPathComponents = sourcePathComponents;
            return;
        }
        var n = Math.min(commonPathComponents.length, sourcePathComponents.length);
        for (var i = 0; i &lt; n; i++) {
            if (getCanonicalFileName(commonPathComponents[i]) !== getCanonicalFileName(sourcePathComponents[i])) {
                if (i === 0) {
                    // Failed to find any common path component
                    return true;
                }
                // New common path found that is 0 -&gt; i-1
                commonPathComponents.length = i;
                break;
            }
        }
        // If the sourcePathComponents was shorter than the commonPathComponents, truncate to the sourcePathComponents
        if (sourcePathComponents.length &lt; commonPathComponents.length) {
            commonPathComponents.length = sourcePathComponents.length;
        }
    });
    // A common path can not be found when paths span multiple drives on windows, for example
    if (failed) {
        return "";
    }
    if (!commonPathComponents) {
        return currentDirectory;
    }
    return ts.getNormalizedPathFromPathComponents(commonPathComponents);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.computeLineAndCharacterOfPosition" id="apidoc.element.typescript.computeLineAndCharacterOfPosition">
        function <span class="apidocSignatureSpan">typescript.</span>computeLineAndCharacterOfPosition
        <span class="apidocSignatureSpan">(lineStarts, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeLineAndCharacterOfPosition(lineStarts, position) {
    var lineNumber = ts.binarySearch(lineStarts, position);
    if (lineNumber &lt; 0) {
        // If the actual position was not found,
        // the binary search returns the 2's-complement of the next line start
        // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
        // then the search will return -2.
        //
        // We want the index of the previous line start, so we subtract 1.
        // Review 2's-complement if this is confusing.
        lineNumber = ~lineNumber - 1;
        ts.Debug.assert(lineNumber !== -1, "position cannot precede the beginning of the file");
    }
    return {
        line: lineNumber,
        character: position - lineStarts[lineNumber]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.computeLineStarts" id="apidoc.element.typescript.computeLineStarts">
        function <span class="apidocSignatureSpan">typescript.</span>computeLineStarts
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeLineStarts(text) {
    var result = new Array();
    var pos = 0;
    var lineStart = 0;
    while (pos &lt; text.length) {
        var ch = text.charCodeAt(pos);
        pos++;
        switch (ch) {
            case 13 /* carriageReturn */:
                if (text.charCodeAt(pos) === 10 /* lineFeed */) {
                    pos++;
                }
            case 10 /* lineFeed */:
                result.push(lineStart);
                lineStart = pos;
                break;
            default:
                if (ch &gt; 127 /* maxAsciiCharacter */ &amp;&amp; isLineBreak(ch)) {
                    result.push(lineStart);
                    lineStart = pos;
                }
                break;
        }
    }
    result.push(lineStart);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.computePositionOfLineAndCharacter" id="apidoc.element.typescript.computePositionOfLineAndCharacter">
        function <span class="apidocSignatureSpan">typescript.</span>computePositionOfLineAndCharacter
        <span class="apidocSignatureSpan">(lineStarts, line, character)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computePositionOfLineAndCharacter(lineStarts, line, character) {
    ts.Debug.assert(line &gt;= 0 &amp;&amp; line &lt; lineStarts.length);
    return lineStarts[line] + character;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.computeTransformFlagsForNode" id="apidoc.element.typescript.computeTransformFlagsForNode">
        function <span class="apidocSignatureSpan">typescript.</span>computeTransformFlagsForNode
        <span class="apidocSignatureSpan">(node, subtreeFlags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeTransformFlagsForNode(node, subtreeFlags) {
    var kind = node.kind;
    switch (kind) {
        case 180 /* CallExpression */:
            return computeCallExpression(node, subtreeFlags);
        case 181 /* NewExpression */:
            return computeNewExpression(node, subtreeFlags);
        case 232 /* ModuleDeclaration */:
            return computeModuleDeclaration(node, subtreeFlags);
        case 184 /* ParenthesizedExpression */:
            return computeParenthesizedExpression(node, subtreeFlags);
        case 193 /* BinaryExpression */:
            return computeBinaryExpression(node, subtreeFlags);
        case 209 /* ExpressionStatement */:
            return computeExpressionStatement(node, subtreeFlags);
        case 145 /* Parameter */:
            return computeParameter(node, subtreeFlags);
        case 186 /* ArrowFunction */:
            return computeArrowFunction(node, subtreeFlags);
        case 185 /* FunctionExpression */:
            return computeFunctionExpression(node, subtreeFlags);
        case 227 /* FunctionDeclaration */:
            return computeFunctionDeclaration(node, subtreeFlags);
        case 225 /* VariableDeclaration */:
            return computeVariableDeclaration(node, subtreeFlags);
        case 226 /* VariableDeclarationList */:
            return computeVariableDeclarationList(node, subtreeFlags);
        case 207 /* VariableStatement */:
            return computeVariableStatement(node, subtreeFlags);
        case 221 /* LabeledStatement */:
            return computeLabeledStatement(node, subtreeFlags);
        case 228 /* ClassDeclaration */:
            return computeClassDeclaration(node, subtreeFlags);
        case 198 /* ClassExpression */:
            return computeClassExpression(node, subtreeFlags);
        case 257 /* HeritageClause */:
            return computeHeritageClause(node, subtreeFlags);
        case 258 /* CatchClause */:
            return computeCatchClause(node, subtreeFlags);
        case 200 /* ExpressionWithTypeArguments */:
            return computeExpressionWithTypeArguments(node, subtreeFlags);
        case 151 /* Constructor */:
            return computeConstructor(node, subtreeFlags);
        case 148 /* PropertyDeclaration */:
            return computePropertyDeclaration(node, subtreeFlags);
        case 150 /* MethodDeclaration */:
            return computeMethod(node, subtreeFlags);
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
            return computeAccessor(node, subtreeFlags);
        case 236 /* ImportEqualsDeclaration */:
            return computeImportEquals(node, subtreeFlags);
        case 178 /* PropertyAccessExpression */:
            return computePropertyAccess(node, subtreeFlags);
        default:
            return computeOther(node, kind, subtreeFlags);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.concatenate" id="apidoc.element.typescript.concatenate">
        function <span class="apidocSignatureSpan">typescript.</span>concatenate
        <span class="apidocSignatureSpan">(array1, array2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatenate(array1, array2) {
    if (!some(array2))
        return array1;
    if (!some(array1))
        return array2;
    return array1.concat(array2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.concatenateDiagnosticMessageChains" id="apidoc.element.typescript.concatenateDiagnosticMessageChains">
        function <span class="apidocSignatureSpan">typescript.</span>concatenateDiagnosticMessageChains
        <span class="apidocSignatureSpan">(headChain, tailChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatenateDiagnosticMessageChains(headChain, tailChain) {
    var lastChain = headChain;
    while (lastChain.next) {
        lastChain = lastChain.next;
    }
    lastChain.next = tailChain;
    return headChain;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.contains" id="apidoc.element.typescript.contains">
        function <span class="apidocSignatureSpan">typescript.</span>contains
        <span class="apidocSignatureSpan">(array, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function contains(array, value) {
    if (array) {
        for (var _i = 0, array_1 = array; _i &lt; array_1.length; _i++) {
            var v = array_1[_i];
            if (v === value) {
                return true;
            }
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.containsParseError" id="apidoc.element.typescript.containsParseError">
        function <span class="apidocSignatureSpan">typescript.</span>containsParseError
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function containsParseError(node) {
    aggregateChildData(node);
    return (node.flags &amp; 131072 /* ThisNodeOrAnySubNodesHasError */) !== 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.containsPath" id="apidoc.element.typescript.containsPath">
        function <span class="apidocSignatureSpan">typescript.</span>containsPath
        <span class="apidocSignatureSpan">(parent, child, currentDirectory, ignoreCase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function containsPath(parent, child, currentDirectory, ignoreCase) {
    if (parent === undefined || child === undefined)
        return false;
    if (parent === child)
        return true;
    parent = removeTrailingDirectorySeparator(parent);
    child = removeTrailingDirectorySeparator(child);
    if (parent === child)
        return true;
    var parentComponents = getNormalizedPathComponents(parent, currentDirectory);
    var childComponents = getNormalizedPathComponents(child, currentDirectory);
    if (childComponents.length &lt; parentComponents.length) {
        return false;
    }
    for (var i = 0; i &lt; parentComponents.length; i++) {
        var result = compareStrings(parentComponents[i], childComponents[i], ignoreCase);
        if (result !== 0 /* EqualTo */) {
            return false;
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertCompileOnSaveOptionFromJson" id="apidoc.element.typescript.convertCompileOnSaveOptionFromJson">
        function <span class="apidocSignatureSpan">typescript.</span>convertCompileOnSaveOptionFromJson
        <span class="apidocSignatureSpan">(jsonOption, basePath, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertCompileOnSaveOptionFromJson(jsonOption, basePath, errors) {
    if (!ts.hasProperty(jsonOption, ts.compileOnSaveCommandLineOption.name)) {
        return false;
    }
    var result = convertJsonOption(ts.compileOnSaveCommandLineOption, jsonOption["compileOnSave"], basePath, errors);
    if (typeof result === "boolean" &amp;&amp; result) {
        return result;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertCompilerOptionsFromJson" id="apidoc.element.typescript.convertCompilerOptionsFromJson">
        function <span class="apidocSignatureSpan">typescript.</span>convertCompilerOptionsFromJson
        <span class="apidocSignatureSpan">(jsonOptions, basePath, configFileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertCompilerOptionsFromJson(jsonOptions, basePath, configFileName) {
    var errors = [];
    var options = convertCompilerOptionsFromJsonWorker(jsonOptions, basePath, errors, configFileName);
    return { options: options, errors: errors };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertEnableAutoDiscoveryToEnable" id="apidoc.element.typescript.convertEnableAutoDiscoveryToEnable">
        function <span class="apidocSignatureSpan">typescript.</span>convertEnableAutoDiscoveryToEnable
        <span class="apidocSignatureSpan">(typeAcquisition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertEnableAutoDiscoveryToEnable(typeAcquisition) {
    // Convert deprecated typingOptions.enableAutoDiscovery to typeAcquisition.enable
    if (typeAcquisition &amp;&amp; typeAcquisition.enableAutoDiscovery !== undefined &amp;&amp; typeAcquisition.enable === undefined) {
        var result = {
            enable: typeAcquisition.enableAutoDiscovery,
            include: typeAcquisition.include || [],
            exclude: typeAcquisition.exclude || []
        };
        return result;
    }
    return typeAcquisition;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToArray" id="apidoc.element.typescript.convertToArray">
        function <span class="apidocSignatureSpan">typescript.</span>convertToArray
        <span class="apidocSignatureSpan">(iterator, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToArray(iterator, f) {
    var result = [];
    for (var _a = iterator.next(), value = _a.value, done = _a.done; !done; _b = iterator.next(), value = _b.value, done = _b.done
, _b) {
        result.push(f(value));
    }
    return result;
    var _b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToArrayAssignmentElement" id="apidoc.element.typescript.convertToArrayAssignmentElement">
        function <span class="apidocSignatureSpan">typescript.</span>convertToArrayAssignmentElement
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToArrayAssignmentElement(element) {
    if (ts.isBindingElement(element)) {
        if (element.dotDotDotToken) {
            ts.Debug.assertNode(element.name, ts.isIdentifier);
            return ts.setOriginalNode(ts.setTextRange(ts.createSpread(element.name), element), element);
        }
        var expression = convertToAssignmentElementTarget(element.name);
        return element.initializer
            ? ts.setOriginalNode(ts.setTextRange(ts.createAssignment(expression, element.initializer), element), element)
            : expression;
    }
    ts.Debug.assertNode(element, ts.isExpression);
    return element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToArrayAssignmentPattern" id="apidoc.element.typescript.convertToArrayAssignmentPattern">
        function <span class="apidocSignatureSpan">typescript.</span>convertToArrayAssignmentPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToArrayAssignmentPattern(node) {
    if (ts.isArrayBindingPattern(node)) {
        return ts.setOriginalNode(ts.setTextRange(ts.createArrayLiteral(ts.map(node.elements, convertToArrayAssignmentElement)),
node), node);
    }
    ts.Debug.assertNode(node, ts.isArrayLiteralExpression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToAssignmentElementTarget" id="apidoc.element.typescript.convertToAssignmentElementTarget">
        function <span class="apidocSignatureSpan">typescript.</span>convertToAssignmentElementTarget
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToAssignmentElementTarget(node) {
    if (ts.isBindingPattern(node)) {
        return convertToAssignmentPattern(node);
    }
    ts.Debug.assertNode(node, ts.isExpression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToAssignmentPattern" id="apidoc.element.typescript.convertToAssignmentPattern">
        function <span class="apidocSignatureSpan">typescript.</span>convertToAssignmentPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToAssignmentPattern(node) {
    switch (node.kind) {
        case 174 /* ArrayBindingPattern */:
        case 176 /* ArrayLiteralExpression */:
            return convertToArrayAssignmentPattern(node);
        case 173 /* ObjectBindingPattern */:
        case 177 /* ObjectLiteralExpression */:
            return convertToObjectAssignmentPattern(node);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToBase64" id="apidoc.element.typescript.convertToBase64">
        function <span class="apidocSignatureSpan">typescript.</span>convertToBase64
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToBase64(input) {
    var result = "";
    var charCodes = getExpandedCharCodes(input);
    var i = 0;
    var length = charCodes.length;
    var byte1, byte2, byte3, byte4;
    while (i &lt; length) {
        // Convert every 6-bits in the input 3 character points
        // into a base64 digit
        byte1 = charCodes[i] &gt;&gt; 2;
        byte2 = (charCodes[i] &amp; 3) &lt;&lt; 4 | charCodes[i + 1] &gt;&gt; 4;
        byte3 = (charCodes[i + 1] &amp; 15) &lt;&lt; 2 | charCodes[i + 2] &gt;&gt; 6;
        byte4 = charCodes[i + 2] &amp; 63;
        // We are out of characters in the input, set the extra
        // digits to 64 (padding character).
        if (i + 1 &gt;= length) {
            byte3 = byte4 = 64;
        }
        else if (i + 2 &gt;= length) {
            byte4 = 64;
        }
        // Write to the output
        result += base64Digits.charAt(byte1) + base64Digits.charAt(byte2) + base64Digits.charAt(byte3) + base64Digits.charAt(byte4
);
        i += 3;
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToFunctionBody" id="apidoc.element.typescript.convertToFunctionBody">
        function <span class="apidocSignatureSpan">typescript.</span>convertToFunctionBody
        <span class="apidocSignatureSpan">(node, multiLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToFunctionBody(node, multiLine) {
    return ts.isBlock(node) ? node : ts.setTextRange(ts.createBlock([ts.setTextRange(ts.createReturn(node), node)], multiLine),
node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToObjectAssignmentElement" id="apidoc.element.typescript.convertToObjectAssignmentElement">
        function <span class="apidocSignatureSpan">typescript.</span>convertToObjectAssignmentElement
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToObjectAssignmentElement(element) {
    if (ts.isBindingElement(element)) {
        if (element.dotDotDotToken) {
            ts.Debug.assertNode(element.name, ts.isIdentifier);
            return ts.setOriginalNode(ts.setTextRange(ts.createSpreadAssignment(element.name), element), element);
        }
        if (element.propertyName) {
            var expression = convertToAssignmentElementTarget(element.name);
            return ts.setOriginalNode(ts.setTextRange(ts.createPropertyAssignment(element.propertyName, element.initializer ? ts
.createAssignment(expression, element.initializer) : expression), element), element);
        }
        ts.Debug.assertNode(element.name, ts.isIdentifier);
        return ts.setOriginalNode(ts.setTextRange(ts.createShorthandPropertyAssignment(element.name, element.initializer), element
), element);
    }
    ts.Debug.assertNode(element, ts.isObjectLiteralElementLike);
    return element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToObjectAssignmentPattern" id="apidoc.element.typescript.convertToObjectAssignmentPattern">
        function <span class="apidocSignatureSpan">typescript.</span>convertToObjectAssignmentPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToObjectAssignmentPattern(node) {
    if (ts.isObjectBindingPattern(node)) {
        return ts.setOriginalNode(ts.setTextRange(ts.createObjectLiteral(ts.map(node.elements, convertToObjectAssignmentElement)),
node), node);
    }
    ts.Debug.assertNode(node, ts.isObjectLiteralExpression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertToRelativePath" id="apidoc.element.typescript.convertToRelativePath">
        function <span class="apidocSignatureSpan">typescript.</span>convertToRelativePath
        <span class="apidocSignatureSpan">(absoluteOrRelativePath, basePath, getCanonicalFileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertToRelativePath(absoluteOrRelativePath, basePath, getCanonicalFileName) {
    return !isRootedDiskPath(absoluteOrRelativePath)
        ? absoluteOrRelativePath
        : getRelativePathToDirectoryOrUrl(basePath, absoluteOrRelativePath, basePath, getCanonicalFileName, /*isAbsolutePathAnUrl
*/ false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.convertTypeAcquisitionFromJson" id="apidoc.element.typescript.convertTypeAcquisitionFromJson">
        function <span class="apidocSignatureSpan">typescript.</span>convertTypeAcquisitionFromJson
        <span class="apidocSignatureSpan">(jsonOptions, basePath, configFileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertTypeAcquisitionFromJson(jsonOptions, basePath, configFileName) {
    var errors = [];
    var options = convertTypeAcquisitionFromJsonWorker(jsonOptions, basePath, errors, configFileName);
    return { options: options, errors: errors };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.copyEntries" id="apidoc.element.typescript.copyEntries">
        function <span class="apidocSignatureSpan">typescript.</span>copyEntries
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyEntries(source, target) {
    source.forEach(function (value, key) {
        target.set(key, value);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.couldStartTrivia" id="apidoc.element.typescript.couldStartTrivia">
        function <span class="apidocSignatureSpan">typescript.</span>couldStartTrivia
        <span class="apidocSignatureSpan">(text, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function couldStartTrivia(text, pos) {
    // Keep in sync with skipTrivia
    var ch = text.charCodeAt(pos);
    switch (ch) {
        case 13 /* carriageReturn */:
        case 10 /* lineFeed */:
        case 9 /* tab */:
        case 11 /* verticalTab */:
        case 12 /* formFeed */:
        case 32 /* space */:
        case 47 /* slash */:
        // starts of normal trivia
        case 60 /* lessThan */:
        case 61 /* equals */:
        case 62 /* greaterThan */:
            // Starts of conflict marker trivia
            return true;
        case 35 /* hash */:
            // Only if its the beginning can we have #! trivia
            return pos === 0;
        default:
            return ch &gt; 127 /* maxAsciiCharacter */;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.countWhere" id="apidoc.element.typescript.countWhere">
        function <span class="apidocSignatureSpan">typescript.</span>countWhere
        <span class="apidocSignatureSpan">(array, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function countWhere(array, predicate) {
    var count = 0;
    if (array) {
        for (var i = 0; i &lt; array.length; i++) {
            var v = array[i];
            if (predicate(v, i)) {
                count++;
            }
        }
    }
    return count;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createAdd" id="apidoc.element.typescript.createAdd">
        function <span class="apidocSignatureSpan">typescript.</span>createAdd
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createAdd(left, right) {
    return createBinary(left, 36 /* PlusToken */, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createArrayBindingPattern" id="apidoc.element.typescript.createArrayBindingPattern">
        function <span class="apidocSignatureSpan">typescript.</span>createArrayBindingPattern
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createArrayBindingPattern(elements) {
    var node = createSynthesizedNode(174 /* ArrayBindingPattern */);
    node.elements = createNodeArray(elements);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createArrayConcat" id="apidoc.element.typescript.createArrayConcat">
        function <span class="apidocSignatureSpan">typescript.</span>createArrayConcat
        <span class="apidocSignatureSpan">(array, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createArrayConcat(array, values) {
    return ts.createCall(ts.createPropertyAccess(array, "concat"),
    /*typeArguments*/ undefined, values);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createArrayLiteral" id="apidoc.element.typescript.createArrayLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>createArrayLiteral
        <span class="apidocSignatureSpan">(elements, multiLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createArrayLiteral(elements, multiLine) {
    var node = createSynthesizedNode(176 /* ArrayLiteralExpression */);
    node.elements = ts.parenthesizeListElements(createNodeArray(elements));
    if (multiLine) {
        node.multiLine = true;
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createArraySlice" id="apidoc.element.typescript.createArraySlice">
        function <span class="apidocSignatureSpan">typescript.</span>createArraySlice
        <span class="apidocSignatureSpan">(array, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createArraySlice(array, start) {
    var argumentsList = [];
    if (start !== undefined) {
        argumentsList.push(typeof start === "number" ? ts.createLiteral(start) : start);
    }
    return ts.createCall(ts.createPropertyAccess(array, "slice"), /*typeArguments*/ undefined, argumentsList);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createArrowFunction" id="apidoc.element.typescript.createArrowFunction">
        function <span class="apidocSignatureSpan">typescript.</span>createArrowFunction
        <span class="apidocSignatureSpan">(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body) {
    var node = createSynthesizedNode(186 /* ArrowFunction */);
    node.modifiers = asNodeArray(modifiers);
    node.typeParameters = asNodeArray(typeParameters);
    node.parameters = createNodeArray(parameters);
    node.type = type;
    node.equalsGreaterThanToken = equalsGreaterThanToken || createToken(35 /* EqualsGreaterThanToken */);
    node.body = ts.parenthesizeConciseBody(body);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createAsExpression" id="apidoc.element.typescript.createAsExpression">
        function <span class="apidocSignatureSpan">typescript.</span>createAsExpression
        <span class="apidocSignatureSpan">(expression, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createAsExpression(expression, type) {
    var node = createSynthesizedNode(201 /* AsExpression */);
    node.expression = expression;
    node.type = type;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createAssignHelper" id="apidoc.element.typescript.createAssignHelper">
        function <span class="apidocSignatureSpan">typescript.</span>createAssignHelper
        <span class="apidocSignatureSpan">(context, attributesSegments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createAssignHelper(context, attributesSegments) {
    if (context.getCompilerOptions().target &gt;= 2 /* ES2015 */) {
        return ts.createCall(ts.createPropertyAccess(ts.createIdentifier("Object"), "assign"),
        /*typeArguments*/ undefined, attributesSegments);
    }
    context.requestEmitHelper(assignHelper);
    return ts.createCall(ts.getHelperName("__assign"),
    /*typeArguments*/ undefined, attributesSegments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createAssignment" id="apidoc.element.typescript.createAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>createAssignment
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createAssignment(left, right) {
    return createBinary(left, 57 /* EqualsToken */, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createAwait" id="apidoc.element.typescript.createAwait">
        function <span class="apidocSignatureSpan">typescript.</span>createAwait
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createAwait(expression) {
    var node = createSynthesizedNode(190 /* AwaitExpression */);
    node.expression = ts.parenthesizePrefixOperand(expression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createBinary" id="apidoc.element.typescript.createBinary">
        function <span class="apidocSignatureSpan">typescript.</span>createBinary
        <span class="apidocSignatureSpan">(left, operator, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBinary(left, operator, right) {
    var node = createSynthesizedNode(193 /* BinaryExpression */);
    var operatorToken = asToken(operator);
    var operatorKind = operatorToken.kind;
    node.left = ts.parenthesizeBinaryOperand(operatorKind, left, /*isLeftSideOfBinary*/ true, /*leftOperand*/ undefined);
    node.operatorToken = operatorToken;
    node.right = ts.parenthesizeBinaryOperand(operatorKind, right, /*isLeftSideOfBinary*/ false, node.left);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createBindingElement" id="apidoc.element.typescript.createBindingElement">
        function <span class="apidocSignatureSpan">typescript.</span>createBindingElement
        <span class="apidocSignatureSpan">(propertyName, dotDotDotToken, name, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBindingElement(propertyName, dotDotDotToken, name, initializer) {
    var node = createSynthesizedNode(175 /* BindingElement */);
    node.propertyName = asName(propertyName);
    node.dotDotDotToken = dotDotDotToken;
    node.name = asName(name);
    node.initializer = initializer;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createBlock" id="apidoc.element.typescript.createBlock">
        function <span class="apidocSignatureSpan">typescript.</span>createBlock
        <span class="apidocSignatureSpan">(statements, multiLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBlock(statements, multiLine) {
    var block = createSynthesizedNode(206 /* Block */);
    block.statements = createNodeArray(statements);
    if (multiLine)
        block.multiLine = multiLine;
    return block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createBreak" id="apidoc.element.typescript.createBreak">
        function <span class="apidocSignatureSpan">typescript.</span>createBreak
        <span class="apidocSignatureSpan">(label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBreak(label) {
    var node = createSynthesizedNode(217 /* BreakStatement */);
    node.label = asName(label);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createBundle" id="apidoc.element.typescript.createBundle">
        function <span class="apidocSignatureSpan">typescript.</span>createBundle
        <span class="apidocSignatureSpan">(sourceFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBundle(sourceFiles) {
    var node = ts.createNode(264 /* Bundle */);
    node.sourceFiles = sourceFiles;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCall" id="apidoc.element.typescript.createCall">
        function <span class="apidocSignatureSpan">typescript.</span>createCall
        <span class="apidocSignatureSpan">(expression, typeArguments, argumentsArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCall(expression, typeArguments, argumentsArray) {
    var node = createSynthesizedNode(180 /* CallExpression */);
    node.expression = ts.parenthesizeForAccess(expression);
    node.typeArguments = asNodeArray(typeArguments);
    node.arguments = ts.parenthesizeListElements(createNodeArray(argumentsArray));
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCallBinding" id="apidoc.element.typescript.createCallBinding">
        function <span class="apidocSignatureSpan">typescript.</span>createCallBinding
        <span class="apidocSignatureSpan">(expression, recordTempVariable, languageVersion, cacheIdentifiers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCallBinding(expression, recordTempVariable, languageVersion, cacheIdentifiers) {
    var callee = skipOuterExpressions(expression, 7<span class="apidocCodeCommentSpan"> /* All */);
    var thisArg;
    var target;
    if (ts.isSuperProperty(callee)) {
        thisArg = ts.createThis();
        target = callee;
    }
    else if (callee.kind === 96 /* SuperKeyword */) {
        thisArg = ts.createThis();
        target = languageVersion &lt; 2 /* ES2015 */
</span>            ? ts.setTextRange(ts.createIdentifier("_super"), callee)
            : callee;
    }
    else {
        switch (callee.kind) {
            case 178 /* PropertyAccessExpression */: {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    // for `a.b()` target is `(_a = a).b` and thisArg is `_a`
                    thisArg = ts.createTempVariable(recordTempVariable);
                    target = ts.createPropertyAccess(ts.setTextRange(ts.createAssignment(thisArg, callee.expression), callee.expression
), callee.name);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
                break;
            }
            case 179 /* ElementAccessExpression */: {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    // for `a[b]()` target is `(_a = a)[b]` and thisArg is `_a`
                    thisArg = ts.createTempVariable(recordTempVariable);
                    target = ts.createElementAccess(ts.setTextRange(ts.createAssignment(thisArg, callee.expression), callee.expression
), callee.argumentExpression);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
                break;
            }
            default: {
                // for `a()` target is `a` and thisArg is `void 0`
                thisArg = ts.createVoidZero();
                target = parenthesizeForAccess(expression);
                break;
            }
        }
    }
    return { target: target, thisArg: thisArg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCaseBlock" id="apidoc.element.typescript.createCaseBlock">
        function <span class="apidocSignatureSpan">typescript.</span>createCaseBlock
        <span class="apidocSignatureSpan">(clauses)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCaseBlock(clauses) {
    var node = createSynthesizedNode(234 /* CaseBlock */);
    node.clauses = createNodeArray(clauses);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCaseClause" id="apidoc.element.typescript.createCaseClause">
        function <span class="apidocSignatureSpan">typescript.</span>createCaseClause
        <span class="apidocSignatureSpan">(expression, statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCaseClause(expression, statements) {
    var node = createSynthesizedNode(255 /* CaseClause */);
    node.expression = ts.parenthesizeExpressionForList(expression);
    node.statements = createNodeArray(statements);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCatchClause" id="apidoc.element.typescript.createCatchClause">
        function <span class="apidocSignatureSpan">typescript.</span>createCatchClause
        <span class="apidocSignatureSpan">(variableDeclaration, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCatchClause(variableDeclaration, block) {
    var node = createSynthesizedNode(258 /* CatchClause */);
    node.variableDeclaration = typeof variableDeclaration === "string" ? createVariableDeclaration(variableDeclaration) : variableDeclaration
;
    node.block = block;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createClassDeclaration" id="apidoc.element.typescript.createClassDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>createClassDeclaration
        <span class="apidocSignatureSpan">(decorators, modifiers, name, typeParameters, heritageClauses, members)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members) {
    var node = createSynthesizedNode(228 /* ClassDeclaration */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.name = asName(name);
    node.typeParameters = asNodeArray(typeParameters);
    node.heritageClauses = asNodeArray(heritageClauses);
    node.members = createNodeArray(members);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createClassExpression" id="apidoc.element.typescript.createClassExpression">
        function <span class="apidocSignatureSpan">typescript.</span>createClassExpression
        <span class="apidocSignatureSpan">(modifiers, name, typeParameters, heritageClauses, members)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createClassExpression(modifiers, name, typeParameters, heritageClauses, members) {
    var node = createSynthesizedNode(198 /* ClassExpression */);
    node.decorators = undefined;
    node.modifiers = asNodeArray(modifiers);
    node.name = asName(name);
    node.typeParameters = asNodeArray(typeParameters);
    node.heritageClauses = asNodeArray(heritageClauses);
    node.members = createNodeArray(members);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createClassifier" id="apidoc.element.typescript.createClassifier">
        function <span class="apidocSignatureSpan">typescript.</span>createClassifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createClassifier() {
    var scanner = ts.createScanner(5<span class="apidocCodeCommentSpan"> /* Latest */, /*skipTrivia*/ false);
    /// We do not have a full parser support to know when we should parse a regex or not
    /// If we consider every slash token to be a regex, we could be missing cases like "1/2/3", where
    /// we have a series of divide operator. this list allows us to be more accurate by ruling out
    /// locations where a regexp cannot exist.
    var noRegexTable = [];
    noRegexTable[70 /* Identifier */] = true;
    noRegexTable[9 /* StringLiteral */] = true;
    noRegexTable[8 /* NumericLiteral */] = true;
    noRegexTable[11 /* RegularExpressionLiteral */] = true;
    noRegexTable[98 /* ThisKeyword */] = true;
    noRegexTable[42 /* PlusPlusToken */] = true;
    noRegexTable[43 /* MinusMinusToken */] = true;
    noRegexTable[19 /* CloseParenToken */] = true;
    noRegexTable[21 /* CloseBracketToken */] = true;
    noRegexTable[17 /* CloseBraceToken */] = true;
    noRegexTable[100 /* TrueKeyword */] = true;
    noRegexTable[85 /* FalseKeyword */] = true;
    // Just a stack of TemplateHeads and OpenCurlyBraces, used to perform rudimentary (inexact)
    // classification on template strings. Because of the context free nature of templates,
    // the only precise way to classify a template portion would be by propagating the stack across
    // lines, just as we do with the end-of-line state. However, this is a burden for implementers,
    // and the behavior is entirely subsumed by the syntactic classifier anyway, so we instead
    // flatten any nesting when the template stack is non-empty and encode it in the end-of-line state.
    // Situations in which this fails are
    //  1) When template strings are nested across different lines:
    //          `hello ${ `world
    //          ` }`
    //
    //     Where on the second line, you will get the closing of a template,
    //     a closing curly, and a new template.
    //
    //  2) When substitution expressions have curly braces and the curly brace falls on the next line:
    //          `hello ${ () =&gt; {
    //          return "world" } } `
    //
    //     Where on the second line, you will get the 'return' keyword,
    //     a string literal, and a template end consisting of '} } `'.
    var templateStack = [];
    /** Returns true if 'keyword2' can legally follow 'keyword1' in any language construct. */
</span>    function canFollow(keyword1, keyword2) {
        if (ts.isAccessibilityModifier(keyword1)) {
            if (keyword2 === 124 /* GetKeyword */ ||
                keyword2 === 134 /* SetKeyword */ ||
                keyword2 === 122 /* ConstructorKeyword */ ||
                keyword2 === 114 /* StaticKeyword */) {
                // Allow things like "public get", "public constructor" and "public static".
                // These are all legal.
                return true;
            }
            // Any other keyword following "public" is actually an identifier an not a real
            // keyword.
            return false;
        }
        // Assume any other keyword combination is legal.  This can be refined in the future
        // if there are more cases we want the classifier to be better at.
        return true;
    }
    function convertClassifications(classifications, text) {
        var entries = [];
        var dense = classifications.spans;
        var lastEnd = 0;
        for (var i = 0; i &lt; dense.length; i += 3) {
            var start = dense[i];
            var length_4 = dense[i + 1];
            var type = dense[i + 2];
            // Make a whitespace entry between the last item and this one.
            if (lastEnd &gt;= 0) {
                var whitespaceLength_1 = start - lastEnd;
                if (whitespaceLength_1 &gt; 0) {
                    entries.push({ length: whitespaceLength_1, classification: ts.TokenClass.Whitespace });
                }
            }
            entries.push({ length: length_4, classification: convertClassification(type) });
            lastEnd = start + length_4;
        }
        var whitespaceLength = tex ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createComma" id="apidoc.element.typescript.createComma">
        function <span class="apidocSignatureSpan">typescript.</span>createComma
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createComma(left, right) {
    return createBinary(left, 25 /* CommaToken */, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCommentWriter" id="apidoc.element.typescript.createCommentWriter">
        function <span class="apidocSignatureSpan">typescript.</span>createCommentWriter
        <span class="apidocSignatureSpan">(printerOptions, emitPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCommentWriter(printerOptions, emitPos) {
    var extendedDiagnostics = printerOptions.extendedDiagnostics;
    var newLine = ts.getNewLineCharacter(printerOptions);
    var writer;
    var containerPos = -1;
    var containerEnd = -1;
    var declarationListContainerEnd = -1;
    var currentSourceFile;
    var currentText;
    var currentLineMap;
    var detachedCommentsInfo;
    var hasWrittenComment = false;
    var disabled = printerOptions.removeComments;
    return {
        reset: reset,
        setWriter: setWriter,
        setSourceFile: setSourceFile,
        emitNodeWithComments: emitNodeWithComments,
        emitBodyWithDetachedComments: emitBodyWithDetachedComments,
        emitTrailingCommentsOfPosition: emitTrailingCommentsOfPosition,
        emitLeadingCommentsOfPosition: emitLeadingCommentsOfPosition,
    };
    function emitNodeWithComments(hint, node, emitCallback) {
        if (disabled) {
            emitCallback(hint, node);
            return;
        }
        if (node) {
            var _a = ts.getCommentRange(node), pos = _a.pos, end = _a.end;
            var emitFlags = ts.getEmitFlags(node);
            if ((pos &lt; 0 &amp;&amp; end &lt; 0) || (pos === end)) {
                // Both pos and end are synthesized, so just emit the node without comments.
                if (emitFlags &amp; 2048 /* NoNestedComments */) {
                    disabled = true;
                    emitCallback(hint, node);
                    disabled = false;
                }
                else {
                    emitCallback(hint, node);
                }
            }
            else {
                if (extendedDiagnostics) {
                    ts.performance.mark("preEmitNodeWithComment");
                }
                var isEmittedNode = node.kind !== 296 /* NotEmittedStatement */;
                var skipLeadingComments = pos &lt; 0 || (emitFlags &amp; 512 /* NoLeadingComments */) !== 0;
                var skipTrailingComments = end &lt; 0 || (emitFlags &amp; 1024 /* NoTrailingComments */) !== 0;
                // Emit leading comments if the position is not synthesized and the node
                // has not opted out from emitting leading comments.
                if (!skipLeadingComments) {
                    emitLeadingComments(pos, isEmittedNode);
                }
                // Save current container state on the stack.
                var savedContainerPos = containerPos;
                var savedContainerEnd = containerEnd;
                var savedDeclarationListContainerEnd = declarationListContainerEnd;
                if (!skipLeadingComments) {
                    containerPos = pos;
                }
                if (!skipTrailingComments) {
                    containerEnd = end;
                    // To avoid invalid comment emit in a down-level binding pattern, we
                    // keep track of the last declaration list container's end
                    if (node.kind === 226 /* VariableDeclarationList */) {
                        declarationListContainerEnd = end;
                    }
                }
                if (extendedDiagnostics) {
                    ts.performance.measure("commentTime", "preEmitNodeWithComment");
                }
                if (emitFlags &amp; 2048 /* NoNestedComments */) {
                    disabled = true;
                    emitCallback(hint, node);
                    disabled = false;
                }
                else {
                    emitCallback(hint, node);
                }
                if (extendedDiagnostics) {
                    ts.performance.mark("beginEmitNodeWithComment");
                }
                // Restore previous container state.
                containerPos = savedContainerPos;
                containerEnd = savedContainerEnd;
                declarationListContainerEnd = savedDeclarationListContainerEnd;
                // Emit trailing comments if the position is not synthesized and the node
                // has not opted out from emitting leading comments and is an emitted node. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCompilerDiagnostic" id="apidoc.element.typescript.createCompilerDiagnostic">
        function <span class="apidocSignatureSpan">typescript.</span>createCompilerDiagnostic
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCompilerDiagnostic(message) {
    var text = getLocaleSpecificMessage(message);
    if (arguments.length &gt; 1) {
        text = formatStringFromArgs(text, arguments, 1);
    }
    return {
        file: undefined,
        start: undefined,
        length: undefined,
        messageText: text,
        category: message.category,
        code: message.code
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCompilerDiagnosticForInvalidCustomType" id="apidoc.element.typescript.createCompilerDiagnosticForInvalidCustomType">
        function <span class="apidocSignatureSpan">typescript.</span>createCompilerDiagnosticForInvalidCustomType
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCompilerDiagnosticForInvalidCustomType(opt) {
    var namesOfType = ts.arrayFrom(opt.type.keys()).map(function (key) { return "'" + key + "'"; }).join(", ");
    return ts.createCompilerDiagnostic(ts.Diagnostics.Argument_for_0_option_must_be_Colon_1, "--" + opt.name, namesOfType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCompilerDiagnosticFromMessageChain" id="apidoc.element.typescript.createCompilerDiagnosticFromMessageChain">
        function <span class="apidocSignatureSpan">typescript.</span>createCompilerDiagnosticFromMessageChain
        <span class="apidocSignatureSpan">(chain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCompilerDiagnosticFromMessageChain(chain) {
    return {
        file: undefined,
        start: undefined,
        length: undefined,
        code: chain.code,
        category: chain.category,
        messageText: chain.next ? chain : chain.messageText
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createCompilerHost" id="apidoc.element.typescript.createCompilerHost">
        function <span class="apidocSignatureSpan">typescript.</span>createCompilerHost
        <span class="apidocSignatureSpan">(options, setParentNodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCompilerHost(options, setParentNodes) {
    var existingDirectories = ts.createMap();
    function getCanonicalFileName(fileName) {
        // if underlying system can distinguish between two files whose names differs only in cases then file name already in canonical
 form.
        // otherwise use toLowerCase as a canonical form.
        return ts.sys.useCaseSensitiveFileNames ? fileName : fileName.toLowerCase();
    }
    // returned by CScript sys environment
    var unsupportedFileEncodingErrorCode = -2147024809;
    function getSourceFile(fileName, languageVersion, onError) {
        var text;
        try {
            ts.performance.mark("beforeIORead");
            text = ts.sys.readFile(fileName, options.charset);
            ts.performance.mark("afterIORead");
            ts.performance.measure("I/O Read", "beforeIORead", "afterIORead");
        }
        catch (e) {
            if (onError) {
                onError(e.number === unsupportedFileEncodingErrorCode
                    ? ts.createCompilerDiagnostic(ts.Diagnostics.Unsupported_file_encoding).messageText
                    : e.message);
            }
            text = "";
        }
        return text !== undefined ? ts.createSourceFile(fileName, text, languageVersion, setParentNodes) : undefined;
    }
    function directoryExists(directoryPath) {
        if (existingDirectories.has(directoryPath)) {
            return true;
        }
        if (ts.sys.directoryExists(directoryPath)) {
            existingDirectories.set(directoryPath, true);
            return true;
        }
        return false;
    }
    function ensureDirectoriesExist(directoryPath) {
        if (directoryPath.length &gt; ts.getRootLength(directoryPath) &amp;&amp; !directoryExists(directoryPath)) {
            var parentDirectory = ts.getDirectoryPath(directoryPath);
            ensureDirectoriesExist(parentDirectory);
            ts.sys.createDirectory(directoryPath);
        }
    }
    var outputFingerprints;
    function writeFileIfUpdated(fileName, data, writeByteOrderMark) {
        if (!outputFingerprints) {
            outputFingerprints = ts.createMap();
        }
        var hash = ts.sys.createHash(data);
        var mtimeBefore = ts.sys.getModifiedTime(fileName);
        if (mtimeBefore) {
            var fingerprint = outputFingerprints.get(fileName);
            // If output has not been changed, and the file has no external modification
            if (fingerprint &amp;&amp;
                fingerprint.byteOrderMark === writeByteOrderMark &amp;&amp;
                fingerprint.hash === hash &amp;&amp;
                fingerprint.mtime.getTime() === mtimeBefore.getTime()) {
                return;
            }
        }
        ts.sys.writeFile(fileName, data, writeByteOrderMark);
        var mtimeAfter = ts.sys.getModifiedTime(fileName);
        outputFingerprints.set(fileName, {
            hash: hash,
            byteOrderMark: writeByteOrderMark,
            mtime: mtimeAfter
        });
    }
    function writeFile(fileName, data, writeByteOrderMark, onError) {
        try {
            ts.performance.mark("beforeIOWrite");
            ensureDirectoriesExist(ts.getDirectoryPath(ts.normalizePath(fileName)));
            if (ts.isWatchSet(options) &amp;&amp; ts.sys.createHash &amp;&amp; ts.sys.getModifiedTime) {
                writeFileIfUpdated(fileName, data, writeByteOrderMark);
            }
            else {
                ts.sys.writeFile(fileName, data, writeByteOrderMark);
            }
            ts.performance.mark("afterIOWrite");
            ts.performance.measure("I/O Write", "beforeIOWrite", "afterIOWrite");
        }
        catch (e) {
            if (onError) {
                onError(e.message);
            }
        }
    }
    function getDefaultLibLocation() {
        return ts.getDirectoryPath(ts.normalizePath(ts.sys.getExecutingFilePath()));
    }
    var newLine = ts.getNewLineCharacter(options);
    var realpath = ts.sys.realpath &amp;&amp; (function (path) { return ts.sys.realpath(path); });
    return {
        getSourceFile: getSourceFile,
        getDefaultLibLocation: ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createComputedPropertyName" id="apidoc.element.typescript.createComputedPropertyName">
        function <span class="apidocSignatureSpan">typescript.</span>createComputedPropertyName
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createComputedPropertyName(expression) {
    var node = createSynthesizedNode(143 /* ComputedPropertyName */);
    node.expression = expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createConditional" id="apidoc.element.typescript.createConditional">
        function <span class="apidocSignatureSpan">typescript.</span>createConditional
        <span class="apidocSignatureSpan">(condition, questionTokenOrWhenTrue, whenTrueOrWhenFalse, colonToken, whenFalse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createConditional(condition, questionTokenOrWhenTrue, whenTrueOrWhenFalse, colonToken, whenFalse) {
    var node = createSynthesizedNode(194 /* ConditionalExpression */);
    node.condition = ts.parenthesizeForConditionalHead(condition);
    node.questionToken = whenFalse ? questionTokenOrWhenTrue : createToken(54 /* QuestionToken */);
    node.whenTrue = ts.parenthesizeSubexpressionOfConditionalExpression(whenFalse ? whenTrueOrWhenFalse : questionTokenOrWhenTrue
);
    node.colonToken = whenFalse ? colonToken : createToken(55 /* ColonToken */);
    node.whenFalse = ts.parenthesizeSubexpressionOfConditionalExpression(whenFalse ? whenFalse : whenTrueOrWhenFalse);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createConstructor" id="apidoc.element.typescript.createConstructor">
        function <span class="apidocSignatureSpan">typescript.</span>createConstructor
        <span class="apidocSignatureSpan">(decorators, modifiers, parameters, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createConstructor(decorators, modifiers, parameters, body) {
    var node = createSynthesizedNode(151 /* Constructor */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.typeParameters = undefined;
    node.parameters = createNodeArray(parameters);
    node.type = undefined;
    node.body = body;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createContinue" id="apidoc.element.typescript.createContinue">
        function <span class="apidocSignatureSpan">typescript.</span>createContinue
        <span class="apidocSignatureSpan">(label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createContinue(label) {
    var node = createSynthesizedNode(216 /* ContinueStatement */);
    node.label = asName(label);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createDecorator" id="apidoc.element.typescript.createDecorator">
        function <span class="apidocSignatureSpan">typescript.</span>createDecorator
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDecorator(expression) {
    var node = createSynthesizedNode(146 /* Decorator */);
    node.expression = ts.parenthesizeForAccess(expression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createDefaultClause" id="apidoc.element.typescript.createDefaultClause">
        function <span class="apidocSignatureSpan">typescript.</span>createDefaultClause
        <span class="apidocSignatureSpan">(statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDefaultClause(statements) {
    var node = createSynthesizedNode(256 /* DefaultClause */);
    node.statements = createNodeArray(statements);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createDelete" id="apidoc.element.typescript.createDelete">
        function <span class="apidocSignatureSpan">typescript.</span>createDelete
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDelete(expression) {
    var node = createSynthesizedNode(187 /* DeleteExpression */);
    node.expression = ts.parenthesizePrefixOperand(expression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createDiagnosticCollection" id="apidoc.element.typescript.createDiagnosticCollection">
        function <span class="apidocSignatureSpan">typescript.</span>createDiagnosticCollection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDiagnosticCollection() {
    var nonFileDiagnostics = [];
    var fileDiagnostics = ts.createMap();
    var diagnosticsModified = false;
    var modificationCount = 0;
    return {
        add: add,
        getGlobalDiagnostics: getGlobalDiagnostics,
        getDiagnostics: getDiagnostics,
        getModificationCount: getModificationCount,
        reattachFileDiagnostics: reattachFileDiagnostics
    };
    function getModificationCount() {
        return modificationCount;
    }
    function reattachFileDiagnostics(newFile) {
        ts.forEach(fileDiagnostics.get(newFile.fileName), function (diagnostic) { return diagnostic.file = newFile; });
    }
    function add(diagnostic) {
        var diagnostics;
        if (diagnostic.file) {
            diagnostics = fileDiagnostics.get(diagnostic.file.fileName);
            if (!diagnostics) {
                diagnostics = [];
                fileDiagnostics.set(diagnostic.file.fileName, diagnostics);
            }
        }
        else {
            diagnostics = nonFileDiagnostics;
        }
        diagnostics.push(diagnostic);
        diagnosticsModified = true;
        modificationCount++;
    }
    function getGlobalDiagnostics() {
        sortAndDeduplicate();
        return nonFileDiagnostics;
    }
    function getDiagnostics(fileName) {
        sortAndDeduplicate();
        if (fileName) {
            return fileDiagnostics.get(fileName) || [];
        }
        var allDiagnostics = [];
        function pushDiagnostic(d) {
            allDiagnostics.push(d);
        }
        ts.forEach(nonFileDiagnostics, pushDiagnostic);
        fileDiagnostics.forEach(function (diagnostics) {
            ts.forEach(diagnostics, pushDiagnostic);
        });
        return ts.sortAndDeduplicateDiagnostics(allDiagnostics);
    }
    function sortAndDeduplicate() {
        if (!diagnosticsModified) {
            return;
        }
        diagnosticsModified = false;
        nonFileDiagnostics = ts.sortAndDeduplicateDiagnostics(nonFileDiagnostics);
        fileDiagnostics.forEach(function (diagnostics, key) {
            fileDiagnostics.set(key, ts.sortAndDeduplicateDiagnostics(diagnostics));
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createDiagnosticForNode" id="apidoc.element.typescript.createDiagnosticForNode">
        function <span class="apidocSignatureSpan">typescript.</span>createDiagnosticForNode
        <span class="apidocSignatureSpan">(node, message, arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDiagnosticForNode(node, message, arg0, arg1, arg2) {
    var sourceFile = getSourceFileOfNode(node);
    return createDiagnosticForNodeInSourceFile(sourceFile, node, message, arg0, arg1, arg2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createDiagnosticForNodeFromMessageChain" id="apidoc.element.typescript.createDiagnosticForNodeFromMessageChain">
        function <span class="apidocSignatureSpan">typescript.</span>createDiagnosticForNodeFromMessageChain
        <span class="apidocSignatureSpan">(node, messageChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDiagnosticForNodeFromMessageChain(node, messageChain) {
    var sourceFile = getSourceFileOfNode(node);
    var span = getErrorSpanForNode(sourceFile, node);
    return {
        file: sourceFile,
        start: span.start,
        length: span.length,
        code: messageChain.code,
        category: messageChain.category,
        messageText: messageChain.next ? messageChain : messageChain.messageText
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createDiagnosticForNodeInSourceFile" id="apidoc.element.typescript.createDiagnosticForNodeInSourceFile">
        function <span class="apidocSignatureSpan">typescript.</span>createDiagnosticForNodeInSourceFile
        <span class="apidocSignatureSpan">(sourceFile, node, message, arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDiagnosticForNodeInSourceFile(sourceFile, node, message, arg0, arg1, arg2) {
    var span = getErrorSpanForNode(sourceFile, node);
    return ts.createFileDiagnostic(sourceFile, span.start, span.length, message, arg0, arg1, arg2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createDo" id="apidoc.element.typescript.createDo">
        function <span class="apidocSignatureSpan">typescript.</span>createDo
        <span class="apidocSignatureSpan">(statement, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDo(statement, expression) {
    var node = createSynthesizedNode(211 /* DoStatement */);
    node.statement = statement;
    node.expression = expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createDocumentRegistry" id="apidoc.element.typescript.createDocumentRegistry">
        function <span class="apidocSignatureSpan">typescript.</span>createDocumentRegistry
        <span class="apidocSignatureSpan">(useCaseSensitiveFileNames, currentDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDocumentRegistry(useCaseSensitiveFileNames, currentDirectory) {
    if (currentDirectory === void 0) { currentDirectory = ""; }
    // Maps from compiler setting target (ES3, ES5, etc.) to all the cached documents we have
    // for those settings.
    var buckets = ts.createMap();
    var getCanonicalFileName = ts.createGetCanonicalFileName(!!useCaseSensitiveFileNames);
    function getKeyForCompilationSettings(settings) {
        return "_" + settings.target + "|" + settings.module + "|" + settings.noResolve + "|" + settings.jsx + "|" + settings.allowJs
 + "|" + settings.baseUrl + "|" + JSON.stringify(settings.typeRoots) + "|" + JSON.stringify(settings.rootDirs) + "|" + JSON.stringify
(settings.paths);
    }
    function getBucketForCompilationSettings(key, createIfMissing) {
        var bucket = buckets.get(key);
        if (!bucket &amp;&amp; createIfMissing) {
            buckets.set(key, bucket = ts.createFileMap());
        }
        return bucket;
    }
    function reportStats() {
        var bucketInfoArray = ts.arrayFrom(buckets.keys()).filter(function (name) { return name &amp;&amp; name.charAt(0) === "_"; }).map
(function (name) {
            var entries = buckets.get(name);
            var sourceFiles = [];
            entries.forEachValue(function (key, entry) {
                sourceFiles.push({
                    name: key,
                    refCount: entry.languageServiceRefCount,
                    references: entry.owners.slice(0)
                });
            });
            sourceFiles.sort(function (x, y) { return y.refCount - x.refCount; });
            return {
                bucket: name,
                sourceFiles: sourceFiles
            };
        });
        return JSON.stringify(bucketInfoArray, undefined, 2);
    }
    function acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
        var path = ts.toPath(fileName, currentDirectory, getCanonicalFileName);
        var key = getKeyForCompilationSettings(compilationSettings);
        return acquireDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind);
    }
    function acquireDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
        return acquireOrUpdateDocument(fileName, path, compilationSettings, key, scriptSnapshot, version, /*acquiring*/ true, scriptKind
);
    }
    function updateDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
        var path = ts.toPath(fileName, currentDirectory, getCanonicalFileName);
        var key = getKeyForCompilationSettings(compilationSettings);
        return updateDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind);
    }
    function updateDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
        return acquireOrUpdateDocument(fileName, path, compilationSettings, key, scriptSnapshot, version, /*acquiring*/ false, scriptKind
);
    }
    function acquireOrUpdateDocument(fileName, path, compilationSettings, key, scriptSnapshot, version, acquiring, scriptKind) {
        var bucket = getBucketForCompilationSettings(key, /*createIfMissing*/ true);
        var entry = bucket.get(path);
        if (!entry) {
            ts.Debug.assert(acquiring, "How could we be trying to update a document that the registry doesn't have?");
            // Have never seen this file with these settings.  Create a new source file for it.
            var sourceFile = ts.createLanguageServiceSourceFile(fileName, scriptSnapshot, compilationSettings.target, version, /*
setNodeParents*/ false, scriptKind);
            entry = {
                sourceFile: sourceFile,
                languageServiceRefCount: 0,
                owners: []
            };
            bucket.set(path, entry);
        }
        else {
            // We have an entry for this file.  However, it may be for a different version of
            // the script snapshot.  If so, update it appropriately.  Otherwise, we ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createElementAccess" id="apidoc.element.typescript.createElementAccess">
        function <span class="apidocSignatureSpan">typescript.</span>createElementAccess
        <span class="apidocSignatureSpan">(expression, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createElementAccess(expression, index) {
    var node = createSynthesizedNode(179 /* ElementAccessExpression */);
    node.expression = ts.parenthesizeForAccess(expression);
    node.argumentExpression = asExpression(index);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createEmptyStatement" id="apidoc.element.typescript.createEmptyStatement">
        function <span class="apidocSignatureSpan">typescript.</span>createEmptyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createEmptyStatement() {
    return createSynthesizedNode(208 /* EmptyStatement */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createEndOfDeclarationMarker" id="apidoc.element.typescript.createEndOfDeclarationMarker">
        function <span class="apidocSignatureSpan">typescript.</span>createEndOfDeclarationMarker
        <span class="apidocSignatureSpan">(original)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createEndOfDeclarationMarker(original) {
    var node = createSynthesizedNode(299 /* EndOfDeclarationMarker */);
    node.emitNode = {};
    node.original = original;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createEnumDeclaration" id="apidoc.element.typescript.createEnumDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>createEnumDeclaration
        <span class="apidocSignatureSpan">(decorators, modifiers, name, members)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createEnumDeclaration(decorators, modifiers, name, members) {
    var node = createSynthesizedNode(231 /* EnumDeclaration */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.name = asName(name);
    node.members = createNodeArray(members);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createEnumMember" id="apidoc.element.typescript.createEnumMember">
        function <span class="apidocSignatureSpan">typescript.</span>createEnumMember
        <span class="apidocSignatureSpan">(name, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createEnumMember(name, initializer) {
    var node = createSynthesizedNode(262 /* EnumMember */);
    node.name = asName(name);
    node.initializer = initializer &amp;&amp; ts.parenthesizeExpressionForList(initializer);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExportAssignment" id="apidoc.element.typescript.createExportAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>createExportAssignment
        <span class="apidocSignatureSpan">(decorators, modifiers, isExportEquals, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExportAssignment(decorators, modifiers, isExportEquals, expression) {
    var node = createSynthesizedNode(242 /* ExportAssignment */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.isExportEquals = isExportEquals;
    node.expression = expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExportDeclaration" id="apidoc.element.typescript.createExportDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>createExportDeclaration
        <span class="apidocSignatureSpan">(decorators, modifiers, exportClause, moduleSpecifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExportDeclaration(decorators, modifiers, exportClause, moduleSpecifier) {
    var node = createSynthesizedNode(243 /* ExportDeclaration */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.exportClause = exportClause;
    node.moduleSpecifier = moduleSpecifier;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExportDefault" id="apidoc.element.typescript.createExportDefault">
        function <span class="apidocSignatureSpan">typescript.</span>createExportDefault
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExportDefault(expression) {
    return createExportAssignment(/*decorators*/ undefined, /*modifiers*/ undefined, /*isExportEquals*/ false, expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExportSpecifier" id="apidoc.element.typescript.createExportSpecifier">
        function <span class="apidocSignatureSpan">typescript.</span>createExportSpecifier
        <span class="apidocSignatureSpan">(name, propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExportSpecifier(name, propertyName) {
    var node = createSynthesizedNode(245 /* ExportSpecifier */);
    node.name = asName(name);
    node.propertyName = asName(propertyName);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExpressionForJsxElement" id="apidoc.element.typescript.createExpressionForJsxElement">
        function <span class="apidocSignatureSpan">typescript.</span>createExpressionForJsxElement
        <span class="apidocSignatureSpan">(jsxFactoryEntity, reactNamespace, tagName, props, children, parentElement, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExpressionForJsxElement(jsxFactoryEntity, reactNamespace, tagName, props, children, parentElement, location) {
    var argumentsList = [tagName];
    if (props) {
        argumentsList.push(props);
    }
    if (children &amp;&amp; children.length &gt; 0) {
        if (!props) {
            argumentsList.push(ts.createNull());
        }
        if (children.length &gt; 1) {
            for (var _i = 0, children_1 = children; _i &lt; children_1.length; _i++) {
                var child = children_1[_i];
                child.startsOnNewLine = true;
                argumentsList.push(child);
            }
        }
        else {
            argumentsList.push(children[0]);
        }
    }
    return ts.setTextRange(ts.createCall(createJsxFactoryExpression(jsxFactoryEntity, reactNamespace, parentElement),
    /*typeArguments*/ undefined, argumentsList), location);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExpressionForObjectLiteralElementLike" id="apidoc.element.typescript.createExpressionForObjectLiteralElementLike">
        function <span class="apidocSignatureSpan">typescript.</span>createExpressionForObjectLiteralElementLike
        <span class="apidocSignatureSpan">(node, property, receiver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExpressionForObjectLiteralElementLike(node, property, receiver) {
    switch (property.kind) {
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
            return createExpressionForAccessorDeclaration(node.properties, property, receiver, node.multiLine);
        case 259 /* PropertyAssignment */:
            return createExpressionForPropertyAssignment(property, receiver);
        case 260 /* ShorthandPropertyAssignment */:
            return createExpressionForShorthandPropertyAssignment(property, receiver);
        case 150 /* MethodDeclaration */:
            return createExpressionForMethodDeclaration(property, receiver);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExpressionForPropertyName" id="apidoc.element.typescript.createExpressionForPropertyName">
        function <span class="apidocSignatureSpan">typescript.</span>createExpressionForPropertyName
        <span class="apidocSignatureSpan">(memberName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExpressionForPropertyName(memberName) {
    if (ts.isIdentifier(memberName)) {
        return ts.createLiteral(memberName);
    }
    else if (ts.isComputedPropertyName(memberName)) {
        return ts.getMutableClone(memberName.expression);
    }
    else {
        return ts.getMutableClone(memberName);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExpressionFromEntityName" id="apidoc.element.typescript.createExpressionFromEntityName">
        function <span class="apidocSignatureSpan">typescript.</span>createExpressionFromEntityName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExpressionFromEntityName(node) {
    if (ts.isQualifiedName(node)) {
        var left = createExpressionFromEntityName(node.left);
        var right = ts.getMutableClone(node.right);
        return ts.setTextRange(ts.createPropertyAccess(left, right), node);
    }
    else {
        return ts.getMutableClone(node);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExpressionWithTypeArguments" id="apidoc.element.typescript.createExpressionWithTypeArguments">
        function <span class="apidocSignatureSpan">typescript.</span>createExpressionWithTypeArguments
        <span class="apidocSignatureSpan">(typeArguments, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExpressionWithTypeArguments(typeArguments, expression) {
    var node = createSynthesizedNode(200 /* ExpressionWithTypeArguments */);
    node.expression = ts.parenthesizeForAccess(expression);
    node.typeArguments = asNodeArray(typeArguments);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExternalModuleExport" id="apidoc.element.typescript.createExternalModuleExport">
        function <span class="apidocSignatureSpan">typescript.</span>createExternalModuleExport
        <span class="apidocSignatureSpan">(exportName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExternalModuleExport(exportName) {
    return createExportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, createNamedExports([createExportSpecifier(
exportName)]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createExternalModuleReference" id="apidoc.element.typescript.createExternalModuleReference">
        function <span class="apidocSignatureSpan">typescript.</span>createExternalModuleReference
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExternalModuleReference(expression) {
    var node = createSynthesizedNode(247 /* ExternalModuleReference */);
    node.expression = expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createFalse" id="apidoc.element.typescript.createFalse">
        function <span class="apidocSignatureSpan">typescript.</span>createFalse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFalse() {
    return createSynthesizedNode(85 /* FalseKeyword */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createFileDiagnostic" id="apidoc.element.typescript.createFileDiagnostic">
        function <span class="apidocSignatureSpan">typescript.</span>createFileDiagnostic
        <span class="apidocSignatureSpan">(file, start, length, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFileDiagnostic(file, start, length, message) {
    var end = start + length;
    Debug.assert(start &gt;= 0, "start must be non-negative, is " + start);
    Debug.assert(length &gt;= 0, "length must be non-negative, is " + length);
    if (file) {
        Debug.assert(start &lt;= file.text.length, "start must be within the bounds of the file. " + start + " &gt; " + file.text.length
);
        Debug.assert(end &lt;= file.text.length, "end must be the bounds of the file. " + end + " &gt; " + file.text.length);
    }
    var text = getLocaleSpecificMessage(message);
    if (arguments.length &gt; 4) {
        text = formatStringFromArgs(text, arguments, 4);
    }
    return {
        file: file,
        start: start,
        length: length,
        messageText: text,
        category: message.category,
        code: message.code,
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createFileMap" id="apidoc.element.typescript.createFileMap">
        function <span class="apidocSignatureSpan">typescript.</span>createFileMap
        <span class="apidocSignatureSpan">(keyMapper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFileMap(keyMapper) {
    var files = createMap();
    return {
        get: get,
        set: set,
        contains: contains,
        remove: remove,
        forEachValue: forEachValueInMap,
        getKeys: getKeys,
        clear: clear,
    };
    function forEachValueInMap(f) {
        files.forEach(function (file, key) {
            f(key, file);
        });
    }
    function getKeys() {
        return arrayFrom(files.keys());
    }
    // path should already be well-formed so it does not need to be normalized
    function get(path) {
        return files.get(toKey(path));
    }
    function set(path, value) {
        files.set(toKey(path), value);
    }
    function contains(path) {
        return files.has(toKey(path));
    }
    function remove(path) {
        files.delete(toKey(path));
    }
    function clear() {
        files.clear();
    }
    function toKey(path) {
        return keyMapper ? keyMapper(path) : path;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createFor" id="apidoc.element.typescript.createFor">
        function <span class="apidocSignatureSpan">typescript.</span>createFor
        <span class="apidocSignatureSpan">(initializer, condition, incrementor, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFor(initializer, condition, incrementor, statement) {
    var node = createSynthesizedNode(213 /* ForStatement */);
    node.initializer = initializer;
    node.condition = condition;
    node.incrementor = incrementor;
    node.statement = statement;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createForIn" id="apidoc.element.typescript.createForIn">
        function <span class="apidocSignatureSpan">typescript.</span>createForIn
        <span class="apidocSignatureSpan">(initializer, expression, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createForIn(initializer, expression, statement) {
    var node = createSynthesizedNode(214 /* ForInStatement */);
    node.initializer = initializer;
    node.expression = expression;
    node.statement = statement;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createForOf" id="apidoc.element.typescript.createForOf">
        function <span class="apidocSignatureSpan">typescript.</span>createForOf
        <span class="apidocSignatureSpan">(initializer, expression, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createForOf(initializer, expression, statement) {
    var node = createSynthesizedNode(215 /* ForOfStatement */);
    node.initializer = initializer;
    node.expression = expression;
    node.statement = statement;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createFunctionApply" id="apidoc.element.typescript.createFunctionApply">
        function <span class="apidocSignatureSpan">typescript.</span>createFunctionApply
        <span class="apidocSignatureSpan">(func, thisArg, argumentsExpression, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFunctionApply(func, thisArg, argumentsExpression, location) {
    return ts.setTextRange(ts.createCall(ts.createPropertyAccess(func, "apply"),
    /*typeArguments*/ undefined, [
        thisArg,
        argumentsExpression
    ]), location);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createFunctionCall" id="apidoc.element.typescript.createFunctionCall">
        function <span class="apidocSignatureSpan">typescript.</span>createFunctionCall
        <span class="apidocSignatureSpan">(func, thisArg, argumentsList, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFunctionCall(func, thisArg, argumentsList, location) {
    return ts.setTextRange(ts.createCall(ts.createPropertyAccess(func, "call"),
    /*typeArguments*/ undefined, [
        thisArg
    ].concat(argumentsList)), location);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createFunctionDeclaration" id="apidoc.element.typescript.createFunctionDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>createFunctionDeclaration
        <span class="apidocSignatureSpan">(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
    var node = createSynthesizedNode(227 /* FunctionDeclaration */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.asteriskToken = asteriskToken;
    node.name = asName(name);
    node.typeParameters = asNodeArray(typeParameters);
    node.parameters = createNodeArray(parameters);
    node.type = type;
    node.body = body;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createFunctionExpression" id="apidoc.element.typescript.createFunctionExpression">
        function <span class="apidocSignatureSpan">typescript.</span>createFunctionExpression
        <span class="apidocSignatureSpan">(modifiers, asteriskToken, name, typeParameters, parameters, type, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
    var node = createSynthesizedNode(185 /* FunctionExpression */);
    node.modifiers = asNodeArray(modifiers);
    node.asteriskToken = asteriskToken;
    node.name = asName(name);
    node.typeParameters = asNodeArray(typeParameters);
    node.parameters = createNodeArray(parameters);
    node.type = type;
    node.body = body;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createGetAccessor" id="apidoc.element.typescript.createGetAccessor">
        function <span class="apidocSignatureSpan">typescript.</span>createGetAccessor
        <span class="apidocSignatureSpan">(decorators, modifiers, name, parameters, type, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createGetAccessor(decorators, modifiers, name, parameters, type, body) {
    var node = createSynthesizedNode(152 /* GetAccessor */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.name = asName(name);
    node.typeParameters = undefined;
    node.parameters = createNodeArray(parameters);
    node.type = type;
    node.body = body;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createGetCanonicalFileName" id="apidoc.element.typescript.createGetCanonicalFileName">
        function <span class="apidocSignatureSpan">typescript.</span>createGetCanonicalFileName
        <span class="apidocSignatureSpan">(useCaseSensitiveFileNames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createGetCanonicalFileName(useCaseSensitiveFileNames) {
    return useCaseSensitiveFileNames
        ? (function (fileName) { return fileName; })
        : (function (fileName) { return fileName.toLowerCase(); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createHeritageClause" id="apidoc.element.typescript.createHeritageClause">
        function <span class="apidocSignatureSpan">typescript.</span>createHeritageClause
        <span class="apidocSignatureSpan">(token, types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createHeritageClause(token, types) {
    var node = createSynthesizedNode(257 /* HeritageClause */);
    node.token = token;
    node.types = createNodeArray(types);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createIdentifier" id="apidoc.element.typescript.createIdentifier">
        function <span class="apidocSignatureSpan">typescript.</span>createIdentifier
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createIdentifier(text) {
    var node = createSynthesizedNode(70 /* Identifier */);
    node.text = ts.escapeIdentifier(text);
    node.originalKeywordKind = text ? ts.stringToToken(text) : 0 /* Unknown */;
    node.autoGenerateKind = 0 /* None */;
    node.autoGenerateId = 0;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createIf" id="apidoc.element.typescript.createIf">
        function <span class="apidocSignatureSpan">typescript.</span>createIf
        <span class="apidocSignatureSpan">(expression, thenStatement, elseStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createIf(expression, thenStatement, elseStatement) {
    var node = createSynthesizedNode(210 /* IfStatement */);
    node.expression = expression;
    node.thenStatement = thenStatement;
    node.elseStatement = elseStatement;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createImportClause" id="apidoc.element.typescript.createImportClause">
        function <span class="apidocSignatureSpan">typescript.</span>createImportClause
        <span class="apidocSignatureSpan">(name, namedBindings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createImportClause(name, namedBindings) {
    var node = createSynthesizedNode(238 /* ImportClause */);
    node.name = name;
    node.namedBindings = namedBindings;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createImportDeclaration" id="apidoc.element.typescript.createImportDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>createImportDeclaration
        <span class="apidocSignatureSpan">(decorators, modifiers, importClause, moduleSpecifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier) {
    var node = createSynthesizedNode(237 /* ImportDeclaration */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.importClause = importClause;
    node.moduleSpecifier = moduleSpecifier;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createImportEqualsDeclaration" id="apidoc.element.typescript.createImportEqualsDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>createImportEqualsDeclaration
        <span class="apidocSignatureSpan">(decorators, modifiers, name, moduleReference)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createImportEqualsDeclaration(decorators, modifiers, name, moduleReference) {
    var node = createSynthesizedNode(236 /* ImportEqualsDeclaration */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.name = asName(name);
    node.moduleReference = moduleReference;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createImportSpecifier" id="apidoc.element.typescript.createImportSpecifier">
        function <span class="apidocSignatureSpan">typescript.</span>createImportSpecifier
        <span class="apidocSignatureSpan">(propertyName, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createImportSpecifier(propertyName, name) {
    var node = createSynthesizedNode(241 /* ImportSpecifier */);
    node.propertyName = propertyName;
    node.name = name;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createJsxAttribute" id="apidoc.element.typescript.createJsxAttribute">
        function <span class="apidocSignatureSpan">typescript.</span>createJsxAttribute
        <span class="apidocSignatureSpan">(name, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createJsxAttribute(name, initializer) {
    var node = createSynthesizedNode(252 /* JsxAttribute */);
    node.name = name;
    node.initializer = initializer;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createJsxClosingElement" id="apidoc.element.typescript.createJsxClosingElement">
        function <span class="apidocSignatureSpan">typescript.</span>createJsxClosingElement
        <span class="apidocSignatureSpan">(tagName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createJsxClosingElement(tagName) {
    var node = createSynthesizedNode(251 /* JsxClosingElement */);
    node.tagName = tagName;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createJsxElement" id="apidoc.element.typescript.createJsxElement">
        function <span class="apidocSignatureSpan">typescript.</span>createJsxElement
        <span class="apidocSignatureSpan">(openingElement, children, closingElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createJsxElement(openingElement, children, closingElement) {
    var node = createSynthesizedNode(248 /* JsxElement */);
    node.openingElement = openingElement;
    node.children = createNodeArray(children);
    node.closingElement = closingElement;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createJsxExpression" id="apidoc.element.typescript.createJsxExpression">
        function <span class="apidocSignatureSpan">typescript.</span>createJsxExpression
        <span class="apidocSignatureSpan">(expression, dotDotDotToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createJsxExpression(expression, dotDotDotToken) {
    var node = createSynthesizedNode(254 /* JsxExpression */);
    node.dotDotDotToken = dotDotDotToken;
    node.expression = expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createJsxOpeningElement" id="apidoc.element.typescript.createJsxOpeningElement">
        function <span class="apidocSignatureSpan">typescript.</span>createJsxOpeningElement
        <span class="apidocSignatureSpan">(tagName, attributes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createJsxOpeningElement(tagName, attributes) {
    var node = createSynthesizedNode(250 /* JsxOpeningElement */);
    node.tagName = tagName;
    node.attributes = createNodeArray(attributes);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createJsxSelfClosingElement" id="apidoc.element.typescript.createJsxSelfClosingElement">
        function <span class="apidocSignatureSpan">typescript.</span>createJsxSelfClosingElement
        <span class="apidocSignatureSpan">(tagName, attributes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createJsxSelfClosingElement(tagName, attributes) {
    var node = createSynthesizedNode(249 /* JsxSelfClosingElement */);
    node.tagName = tagName;
    node.attributes = createNodeArray(attributes);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createJsxSpreadAttribute" id="apidoc.element.typescript.createJsxSpreadAttribute">
        function <span class="apidocSignatureSpan">typescript.</span>createJsxSpreadAttribute
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createJsxSpreadAttribute(expression) {
    var node = createSynthesizedNode(253 /* JsxSpreadAttribute */);
    node.expression = expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createLabel" id="apidoc.element.typescript.createLabel">
        function <span class="apidocSignatureSpan">typescript.</span>createLabel
        <span class="apidocSignatureSpan">(label, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLabel(label, statement) {
    var node = createSynthesizedNode(221 /* LabeledStatement */);
    node.label = asName(label);
    node.statement = statement;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createLanguageService" id="apidoc.element.typescript.createLanguageService">
        function <span class="apidocSignatureSpan">typescript.</span>createLanguageService
        <span class="apidocSignatureSpan">(host, documentRegistry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLanguageService(host, documentRegistry) {
    if (documentRegistry === void 0) { documentRegistry = ts.createDocumentRegistry(host.useCaseSensitiveFileNames &amp;&amp; host.useCaseSensitiveFileNames
(), host.getCurrentDirectory()); }
    var syntaxTreeCache = new SyntaxTreeCache(host);
    var ruleProvider;
    var program;
    var lastProjectVersion;
    var lastTypesRootVersion = 0;
    var useCaseSensitivefileNames = host.useCaseSensitiveFileNames &amp;&amp; host.useCaseSensitiveFileNames();
    var cancellationToken = new CancellationTokenObject(host.getCancellationToken &amp;&amp; host.getCancellationToken());
    var currentDirectory = host.getCurrentDirectory();
    // Check if the localized messages json is set, otherwise query the host for it
    if (!ts.localizedDiagnosticMessages &amp;&amp; host.getLocalizedDiagnosticMessages) {
        ts.localizedDiagnosticMessages = host.getLocalizedDiagnosticMessages();
    }
    function log(message) {
        if (host.log) {
            host.log(message);
        }
    }
    var getCanonicalFileName = ts.createGetCanonicalFileName(useCaseSensitivefileNames);
    function getValidSourceFile(fileName) {
        var sourceFile = program.getSourceFile(fileName);
        if (!sourceFile) {
            throw new Error("Could not find file: '" + fileName + "'.");
        }
        return sourceFile;
    }
    function getRuleProvider(options) {
        // Ensure rules are initialized and up to date wrt to formatting options
        if (!ruleProvider) {
            ruleProvider = new ts.formatting.RulesProvider();
        }
        ruleProvider.ensureUpToDate(options);
        return ruleProvider;
    }
    function synchronizeHostData() {
        // perform fast check if host supports it
        if (host.getProjectVersion) {
            var hostProjectVersion = host.getProjectVersion();
            if (hostProjectVersion) {
                if (lastProjectVersion === hostProjectVersion) {
                    return;
                }
                lastProjectVersion = hostProjectVersion;
            }
        }
        var typeRootsVersion = host.getTypeRootsVersion ? host.getTypeRootsVersion() : 0;
        if (lastTypesRootVersion !== typeRootsVersion) {
            log("TypeRoots version has changed; provide new program");
            program = undefined;
            lastTypesRootVersion = typeRootsVersion;
        }
        // Get a fresh cache of the host information
        var hostCache = new HostCache(host, getCanonicalFileName);
        // If the program is already up-to-date, we can reuse it
        if (programUpToDate()) {
            return;
        }
        // IMPORTANT - It is critical from this moment onward that we do not check
        // cancellation tokens.  We are about to mutate source files from a previous program
        // instance.  If we cancel midway through, we may end up in an inconsistent state where
        // the program points to old source files that have been invalidated because of
        // incremental parsing.
        var oldSettings = program &amp;&amp; program.getCompilerOptions();
        var newSettings = hostCache.compilationSettings();
        var shouldCreateNewSourceFiles = oldSettings &amp;&amp;
            (oldSettings.target !== newSettings.target ||
                oldSettings.module !== newSettings.module ||
                oldSettings.moduleResolution !== newSettings.moduleResolution ||
                oldSettings.noResolve !== newSettings.noResolve ||
                oldSettings.jsx !== newSettings.jsx ||
                oldSettings.allowJs !== newSettings.allowJs ||
                oldSettings.disableSizeLimit !== oldSettings.disableSizeLimit ||
                oldSettings.baseUrl !== newSettings.baseUrl ||
                !ts.equalOwnProperties(oldSettings.paths, newSettings.paths));
        // Now create a new compiler
        var compilerHost = {
            getSourceFile: getOrCreateSourceFile,
            getSourceFileByPath: getOrCreateSourceFileByPath,
            getCancellationToken: function () { return cancellationToken; },
            getCanonic ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createLanguageServiceSourceFile" id="apidoc.element.typescript.createLanguageServiceSourceFile">
        function <span class="apidocSignatureSpan">typescript.</span>createLanguageServiceSourceFile
        <span class="apidocSignatureSpan">(fileName, scriptSnapshot, scriptTarget, version, setNodeParents, scriptKind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLanguageServiceSourceFile(fileName, scriptSnapshot, scriptTarget, version, setNodeParents, scriptKind) {
    var text = scriptSnapshot.getText(0, scriptSnapshot.getLength());
    var sourceFile = ts.createSourceFile(fileName, text, scriptTarget, setNodeParents, scriptKind);
    setSourceFileFields(sourceFile, scriptSnapshot, version);
    return sourceFile;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createLessThan" id="apidoc.element.typescript.createLessThan">
        function <span class="apidocSignatureSpan">typescript.</span>createLessThan
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLessThan(left, right) {
    return createBinary(left, 26 /* LessThanToken */, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createLiteral" id="apidoc.element.typescript.createLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>createLiteral
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLiteral(value) {
    if (typeof value === "number") {
        return createNumericLiteral(value + "");
    }
    if (typeof value === "boolean") {
        return value ? createTrue() : createFalse();
    }
    if (typeof value === "string") {
        return createStringLiteral(value);
    }
    return createLiteralFromNode(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createLogicalAnd" id="apidoc.element.typescript.createLogicalAnd">
        function <span class="apidocSignatureSpan">typescript.</span>createLogicalAnd
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLogicalAnd(left, right) {
    return createBinary(left, 52 /* AmpersandAmpersandToken */, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createLogicalNot" id="apidoc.element.typescript.createLogicalNot">
        function <span class="apidocSignatureSpan">typescript.</span>createLogicalNot
        <span class="apidocSignatureSpan">(operand)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLogicalNot(operand) {
    return createPrefix(50 /* ExclamationToken */, operand);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createLogicalOr" id="apidoc.element.typescript.createLogicalOr">
        function <span class="apidocSignatureSpan">typescript.</span>createLogicalOr
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLogicalOr(left, right) {
    return createBinary(left, 53 /* BarBarToken */, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createLoopVariable" id="apidoc.element.typescript.createLoopVariable">
        function <span class="apidocSignatureSpan">typescript.</span>createLoopVariable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLoopVariable() {
    var name = createIdentifier("");
    name.autoGenerateKind = 2 /* Loop */;
    name.autoGenerateId = nextAutoGenerateId;
    nextAutoGenerateId++;
    return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createMap" id="apidoc.element.typescript.createMap">
        function <span class="apidocSignatureSpan">typescript.</span>createMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMap() {
    return new MapCtr();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createMapFromTemplate" id="apidoc.element.typescript.createMapFromTemplate">
        function <span class="apidocSignatureSpan">typescript.</span>createMapFromTemplate
        <span class="apidocSignatureSpan">(template)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMapFromTemplate(template) {
    var map = new MapCtr();
    // Copies keys/values from template. Note that for..in will not throw if
    // template is undefined, and instead will just exit the loop.
    for (var key in template)
        if (hasOwnProperty.call(template, key)) {
            map.set(key, template[key]);
        }
    return map;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createMathPow" id="apidoc.element.typescript.createMathPow">
        function <span class="apidocSignatureSpan">typescript.</span>createMathPow
        <span class="apidocSignatureSpan">(left, right, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMathPow(left, right, location) {
    return ts.setTextRange(ts.createCall(ts.createPropertyAccess(ts.createIdentifier("Math"), "pow"),
    /*typeArguments*/ undefined, [left, right]), location);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createMemberAccessForPropertyName" id="apidoc.element.typescript.createMemberAccessForPropertyName">
        function <span class="apidocSignatureSpan">typescript.</span>createMemberAccessForPropertyName
        <span class="apidocSignatureSpan">(target, memberName, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMemberAccessForPropertyName(target, memberName, location) {
    if (ts.isComputedPropertyName(memberName)) {
        return ts.setTextRange(ts.createElementAccess(target, memberName.expression), location);
    }
    else {
        var expression = ts.setTextRange(ts.isIdentifier(memberName)
            ? ts.createPropertyAccess(target, memberName)
            : ts.createElementAccess(target, memberName), memberName);
        ts.getOrCreateEmitNode(expression).flags |= 64 /* NoNestedSourceMaps */;
        return expression;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createMergeDeclarationMarker" id="apidoc.element.typescript.createMergeDeclarationMarker">
        function <span class="apidocSignatureSpan">typescript.</span>createMergeDeclarationMarker
        <span class="apidocSignatureSpan">(original)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMergeDeclarationMarker(original) {
    var node = createSynthesizedNode(298 /* MergeDeclarationMarker */);
    node.emitNode = {};
    node.original = original;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createMethod" id="apidoc.element.typescript.createMethod">
        function <span class="apidocSignatureSpan">typescript.</span>createMethod
        <span class="apidocSignatureSpan">(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMethod(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
    var node = createSynthesizedNode(150 /* MethodDeclaration */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.asteriskToken = asteriskToken;
    node.name = asName(name);
    node.typeParameters = asNodeArray(typeParameters);
    node.parameters = createNodeArray(parameters);
    node.type = type;
    node.body = body;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createModuleBlock" id="apidoc.element.typescript.createModuleBlock">
        function <span class="apidocSignatureSpan">typescript.</span>createModuleBlock
        <span class="apidocSignatureSpan">(statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createModuleBlock(statements) {
    var node = createSynthesizedNode(234 /* CaseBlock */);
    node.statements = createNodeArray(statements);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createModuleDeclaration" id="apidoc.element.typescript.createModuleDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>createModuleDeclaration
        <span class="apidocSignatureSpan">(decorators, modifiers, name, body, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createModuleDeclaration(decorators, modifiers, name, body, flags) {
    var node = createSynthesizedNode(232 /* ModuleDeclaration */);
    node.flags |= flags;
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.name = name;
    node.body = body;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createModuleResolutionCache" id="apidoc.element.typescript.createModuleResolutionCache">
        function <span class="apidocSignatureSpan">typescript.</span>createModuleResolutionCache
        <span class="apidocSignatureSpan">(currentDirectory, getCanonicalFileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createModuleResolutionCache(currentDirectory, getCanonicalFileName) {
    var directoryToModuleNameMap = ts.createFileMap();
    var moduleNameToDirectoryMap = ts.createMap();
    return { getOrCreateCacheForDirectory: getOrCreateCacheForDirectory, getOrCreateCacheForModuleName: getOrCreateCacheForModuleName
 };
    function getOrCreateCacheForDirectory(directoryName) {
        var path = ts.toPath(directoryName, currentDirectory, getCanonicalFileName);
        var perFolderCache = directoryToModuleNameMap.get(path);
        if (!perFolderCache) {
            perFolderCache = ts.createMap();
            directoryToModuleNameMap.set(path, perFolderCache);
        }
        return perFolderCache;
    }
    function getOrCreateCacheForModuleName(nonRelativeModuleName) {
        if (!moduleHasNonRelativeName(nonRelativeModuleName)) {
            return undefined;
        }
        var perModuleNameCache = moduleNameToDirectoryMap.get(nonRelativeModuleName);
        if (!perModuleNameCache) {
            perModuleNameCache = createPerModuleNameCache();
            moduleNameToDirectoryMap.set(nonRelativeModuleName, perModuleNameCache);
        }
        return perModuleNameCache;
    }
    function createPerModuleNameCache() {
        var directoryPathMap = ts.createFileMap();
        return { get: get, set: set };
        function get(directory) {
            return directoryPathMap.get(ts.toPath(directory, currentDirectory, getCanonicalFileName));
        }
<span class="apidocCodeCommentSpan">        /**
         * At first this function add entry directory -&gt; module resolution result to the table.
         * Then it computes the set of parent folders for 'directory' that should have the same module resolution result
         * and for every parent folder in set it adds entry: parent -&gt; module resolution. .
         * Lets say we first directory name: /a/b/c/d/e and resolution result is: /a/b/bar.ts.
         * Set of parent folders that should have the same result will be:
         * [
         *     /a/b/c/d, /a/b/c, /a/b
         * ]
         * this means that request for module resolution from file in any of these folder will be immediately found in cache.
         */
</span>        function set(directory, result) {
            var path = ts.toPath(directory, currentDirectory, getCanonicalFileName);
            // if entry is already in cache do nothing
            if (directoryPathMap.contains(path)) {
                return;
            }
            directoryPathMap.set(path, result);
            var resolvedFileName = result.resolvedModule &amp;&amp; result.resolvedModule.resolvedFileName;
            // find common prefix between directory and resolved file name
            // this common prefix should be the shorted path that has the same resolution
            // directory: /a/b/c/d/e
            // resolvedFileName: /a/b/foo.d.ts
            var commonPrefix = getCommonPrefix(path, resolvedFileName);
            var current = path;
            while (true) {
                var parent = ts.getDirectoryPath(current);
                if (parent === current || directoryPathMap.contains(parent)) {
                    break;
                }
                directoryPathMap.set(parent, result);
                current = parent;
                if (current == commonPrefix) {
                    break;
                }
            }
        }
        function getCommonPrefix(directory, resolution) {
            if (resolution === undefined) {
                return undefined;
            }
            var resolutionDirectory = ts.toPath(ts.getDirectoryPath(resolution), currentDirectory, getCanonicalFileName);
            // find first position where directory and resolution differs
            var i = 0;
            while (i &lt; Math.min(directory.length, resolutionDirectory.length) &amp;&amp; directory.charCodeAt(i) === resolutionDirectory
.charCodeAt(i)) {
                i++;
            }
            // find last directory separator before position i
            var sep = directory.lastIndexOf(ts.directorySeparator, i);
            if (sep &lt; 0) {
                r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createMultiMap" id="apidoc.element.typescript.createMultiMap">
        function <span class="apidocSignatureSpan">typescript.</span>createMultiMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMultiMap() {
    var map = createMap();
    map.add = multiMapAdd;
    map.remove = multiMapRemove;
    return map;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNamedExports" id="apidoc.element.typescript.createNamedExports">
        function <span class="apidocSignatureSpan">typescript.</span>createNamedExports
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNamedExports(elements) {
    var node = createSynthesizedNode(244 /* NamedExports */);
    node.elements = createNodeArray(elements);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNamedImports" id="apidoc.element.typescript.createNamedImports">
        function <span class="apidocSignatureSpan">typescript.</span>createNamedImports
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNamedImports(elements) {
    var node = createSynthesizedNode(240 /* NamedImports */);
    node.elements = createNodeArray(elements);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNamespaceImport" id="apidoc.element.typescript.createNamespaceImport">
        function <span class="apidocSignatureSpan">typescript.</span>createNamespaceImport
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNamespaceImport(name) {
    var node = createSynthesizedNode(239 /* NamespaceImport */);
    node.name = name;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNew" id="apidoc.element.typescript.createNew">
        function <span class="apidocSignatureSpan">typescript.</span>createNew
        <span class="apidocSignatureSpan">(expression, typeArguments, argumentsArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNew(expression, typeArguments, argumentsArray) {
    var node = createSynthesizedNode(181 /* NewExpression */);
    node.expression = ts.parenthesizeForNew(expression);
    node.typeArguments = asNodeArray(typeArguments);
    node.arguments = argumentsArray ? ts.parenthesizeListElements(createNodeArray(argumentsArray)) : undefined;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNode" id="apidoc.element.typescript.createNode">
        function <span class="apidocSignatureSpan">typescript.</span>createNode
        <span class="apidocSignatureSpan">(kind, pos, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNode(kind, pos, end) {
    if (kind === 263 /* SourceFile */) {
        return new (SourceFileConstructor || (SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor()))(kind, pos,
end);
    }
    else if (kind === 70 /* Identifier */) {
        return new (IdentifierConstructor || (IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor()))(kind, pos,
end);
    }
    else if (kind &lt; 142 /* FirstNode */) {
        return new (TokenConstructor || (TokenConstructor = ts.objectAllocator.getTokenConstructor()))(kind, pos, end);
    }
    else {
        return new (NodeConstructor || (NodeConstructor = ts.objectAllocator.getNodeConstructor()))(kind, pos, end);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNodeArray" id="apidoc.element.typescript.createNodeArray">
        function <span class="apidocSignatureSpan">typescript.</span>createNodeArray
        <span class="apidocSignatureSpan">(elements, hasTrailingComma)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNodeArray(elements, hasTrailingComma) {
    if (elements) {
        if (ts.isNodeArray(elements)) {
            return elements;
        }
    }
    else {
        elements = [];
    }
    var array = elements;
    array.pos = -1;
    array.end = -1;
    array.hasTrailingComma = hasTrailingComma;
    return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNonNullExpression" id="apidoc.element.typescript.createNonNullExpression">
        function <span class="apidocSignatureSpan">typescript.</span>createNonNullExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNonNullExpression(expression) {
    var node = createSynthesizedNode(202 /* NonNullExpression */);
    node.expression = ts.parenthesizeForAccess(expression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNotEmittedStatement" id="apidoc.element.typescript.createNotEmittedStatement">
        function <span class="apidocSignatureSpan">typescript.</span>createNotEmittedStatement
        <span class="apidocSignatureSpan">(original)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNotEmittedStatement(original) {
    var node = createSynthesizedNode(296 /* NotEmittedStatement */);
    node.original = original;
    setTextRange(node, original);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNull" id="apidoc.element.typescript.createNull">
        function <span class="apidocSignatureSpan">typescript.</span>createNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNull() {
    return createSynthesizedNode(94 /* NullKeyword */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createNumericLiteral" id="apidoc.element.typescript.createNumericLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>createNumericLiteral
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createNumericLiteral(value) {
    var node = createSynthesizedNode(8 /* NumericLiteral */);
    node.text = value;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createObjectBindingPattern" id="apidoc.element.typescript.createObjectBindingPattern">
        function <span class="apidocSignatureSpan">typescript.</span>createObjectBindingPattern
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createObjectBindingPattern(elements) {
    var node = createSynthesizedNode(173 /* ObjectBindingPattern */);
    node.elements = createNodeArray(elements);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createObjectLiteral" id="apidoc.element.typescript.createObjectLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>createObjectLiteral
        <span class="apidocSignatureSpan">(properties, multiLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createObjectLiteral(properties, multiLine) {
    var node = createSynthesizedNode(177 /* ObjectLiteralExpression */);
    node.properties = createNodeArray(properties);
    if (multiLine) {
        node.multiLine = true;
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createOmittedExpression" id="apidoc.element.typescript.createOmittedExpression">
        function <span class="apidocSignatureSpan">typescript.</span>createOmittedExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createOmittedExpression() {
    return createSynthesizedNode(199 /* OmittedExpression */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createParameter" id="apidoc.element.typescript.createParameter">
        function <span class="apidocSignatureSpan">typescript.</span>createParameter
        <span class="apidocSignatureSpan">(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createParameter(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer) {
    var node = createSynthesizedNode(145 /* Parameter */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.dotDotDotToken = dotDotDotToken;
    node.name = asName(name);
    node.questionToken = questionToken;
    node.type = type;
    node.initializer = initializer ? ts.parenthesizeExpressionForList(initializer) : undefined;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createParen" id="apidoc.element.typescript.createParen">
        function <span class="apidocSignatureSpan">typescript.</span>createParen
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createParen(expression) {
    var node = createSynthesizedNode(184 /* ParenthesizedExpression */);
    node.expression = expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createPartiallyEmittedExpression" id="apidoc.element.typescript.createPartiallyEmittedExpression">
        function <span class="apidocSignatureSpan">typescript.</span>createPartiallyEmittedExpression
        <span class="apidocSignatureSpan">(expression, original)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPartiallyEmittedExpression(expression, original) {
    var node = createSynthesizedNode(297 /* PartiallyEmittedExpression */);
    node.expression = expression;
    node.original = original;
    setTextRange(node, original);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createPatternMatcher" id="apidoc.element.typescript.createPatternMatcher">
        function <span class="apidocSignatureSpan">typescript.</span>createPatternMatcher
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPatternMatcher(pattern) {
    // We'll often see the same candidate string many times when searching (For example, when
    // we see the name of a module that is used everywhere, or the name of an overload).  As
    // such, we cache the information we compute about the candidate for the life of this
    // pattern matcher so we don't have to compute it multiple times.
    var stringToWordSpans = ts.createMap();
    pattern = pattern.trim();
    var dotSeparatedSegments = pattern.split(".").map(function (p) { return createSegment(p.trim()); });
    var invalidPattern = dotSeparatedSegments.length === 0 || ts.forEach(dotSeparatedSegments, segmentIsInvalid);
    return {
        getMatches: getMatches,
        getMatchesForLastSegmentOfPattern: getMatchesForLastSegmentOfPattern,
        patternContainsDots: dotSeparatedSegments.length &gt; 1
    };
    // Quick checks so we can bail out when asked to match a candidate.
    function skipMatch(candidate) {
        return invalidPattern || !candidate;
    }
    function getMatchesForLastSegmentOfPattern(candidate) {
        if (skipMatch(candidate)) {
            return undefined;
        }
        return matchSegment(candidate, ts.lastOrUndefined(dotSeparatedSegments));
    }
    function getMatches(candidateContainers, candidate) {
        if (skipMatch(candidate)) {
            return undefined;
        }
        // First, check that the last part of the dot separated pattern matches the name of the
        // candidate.  If not, then there's no point in proceeding and doing the more
        // expensive work.
        var candidateMatch = matchSegment(candidate, ts.lastOrUndefined(dotSeparatedSegments));
        if (!candidateMatch) {
            return undefined;
        }
        candidateContainers = candidateContainers || [];
        // -1 because the last part was checked against the name, and only the rest
        // of the parts are checked against the container.
        if (dotSeparatedSegments.length - 1 &gt; candidateContainers.length) {
            // There weren't enough container parts to match against the pattern parts.
            // So this definitely doesn't match.
            return undefined;
        }
        // So far so good.  Now break up the container for the candidate and check if all
        // the dotted parts match up correctly.
        var totalMatch = candidateMatch;
        for (var i = dotSeparatedSegments.length - 2, j = candidateContainers.length - 1; i &gt;= 0; i -= 1, j -= 1) {
            var segment = dotSeparatedSegments[i];
            var containerName = candidateContainers[j];
            var containerMatch = matchSegment(containerName, segment);
            if (!containerMatch) {
                // This container didn't match the pattern piece.  So there's no match at all.
                return undefined;
            }
            ts.addRange(totalMatch, containerMatch);
        }
        // Success, this symbol's full name matched against the dotted name the user was asking
        // about.
        return totalMatch;
    }
    function getWordSpans(word) {
        var spans = stringToWordSpans.get(word);
        if (!spans) {
            stringToWordSpans.set(word, spans = breakIntoWordSpans(word));
        }
        return spans;
    }
    function matchTextChunk(candidate, chunk, punctuationStripped) {
        var index = indexOfIgnoringCase(candidate, chunk.textLowerCase);
        if (index === 0) {
            if (chunk.text.length === candidate.length) {
                // a) Check if the part matches the candidate entirely, in an case insensitive or
                //    sensitive manner.  If it does, return that there was an exact match.
                return createPatternMatch(PatternMatchKind.exact, punctuationStripped, /*isCaseSensitive:*/ candidate === chunk.
text);
            }
            else {
                // b) Check if the part is a prefix of the candidate, in a case insensitive or sensitive
                //    manner.  If it does, return that there was a prefix match.
                return creat ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createPostfix" id="apidoc.element.typescript.createPostfix">
        function <span class="apidocSignatureSpan">typescript.</span>createPostfix
        <span class="apidocSignatureSpan">(operand, operator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPostfix(operand, operator) {
    var node = createSynthesizedNode(192 /* PostfixUnaryExpression */);
    node.operand = ts.parenthesizePostfixOperand(operand);
    node.operator = operator;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createPostfixIncrement" id="apidoc.element.typescript.createPostfixIncrement">
        function <span class="apidocSignatureSpan">typescript.</span>createPostfixIncrement
        <span class="apidocSignatureSpan">(operand)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPostfixIncrement(operand) {
    return createPostfix(operand, 42 /* PlusPlusToken */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createPrefix" id="apidoc.element.typescript.createPrefix">
        function <span class="apidocSignatureSpan">typescript.</span>createPrefix
        <span class="apidocSignatureSpan">(operator, operand)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPrefix(operator, operand) {
    var node = createSynthesizedNode(191 /* PrefixUnaryExpression */);
    node.operator = operator;
    node.operand = ts.parenthesizePrefixOperand(operand);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createPrinter" id="apidoc.element.typescript.createPrinter">
        function <span class="apidocSignatureSpan">typescript.</span>createPrinter
        <span class="apidocSignatureSpan">(printerOptions, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPrinter(printerOptions, handlers) {
    if (printerOptions === void 0) { printerOptions = {}; }
    if (handlers === void 0) { handlers = {}; }
    var hasGlobalName = handlers.hasGlobalName, onEmitSourceMapOfNode = handlers.onEmitSourceMapOfNode, onEmitSourceMapOfToken =
handlers.onEmitSourceMapOfToken, onEmitSourceMapOfPosition = handlers.onEmitSourceMapOfPosition, onEmitNode = handlers.onEmitNode
, onEmitHelpers = handlers.onEmitHelpers, onSetSourceFile = handlers.onSetSourceFile, onSubstituteNode = handlers.onSubstituteNode
;
    var newLine = ts.getNewLineCharacter(printerOptions);
    var languageVersion = ts.getEmitScriptTarget(printerOptions);
    var comments = ts.createCommentWriter(printerOptions, onEmitSourceMapOfPosition);
    var emitNodeWithComments = comments.emitNodeWithComments, emitBodyWithDetachedComments = comments.emitBodyWithDetachedComments
, emitTrailingCommentsOfPosition = comments.emitTrailingCommentsOfPosition, emitLeadingCommentsOfPosition = comments.emitLeadingCommentsOfPosition
;
    var currentSourceFile;
    var nodeIdToGeneratedName; // Map of generated names for specific nodes.
    var autoGeneratedIdToGeneratedName; // Map of generated names for temp and loop variables.
    var generatedNames; // Set of names generated by the NameGenerator.
    var tempFlagsStack; // Stack of enclosing name generation scopes.
    var tempFlags; // TempFlags for the current name generation scope.
    var writer;
    var ownWriter;
    reset();
    return {
        // public API
        printNode: printNode,
        printFile: printFile,
        printBundle: printBundle,
        // internal API
        writeNode: writeNode,
        writeFile: writeFile,
        writeBundle: writeBundle
    };
    function printNode(hint, node, sourceFile) {
        switch (hint) {
            case 0 /* SourceFile */:
                ts.Debug.assert(ts.isSourceFile(node), "Expected a SourceFile node.");
                break;
            case 2 /* IdentifierName */:
                ts.Debug.assert(ts.isIdentifier(node), "Expected an Identifier node.");
                break;
            case 1 /* Expression */:
                ts.Debug.assert(ts.isExpression(node), "Expected an Expression node.");
                break;
        }
        switch (node.kind) {
            case 263 /* SourceFile */: return printFile(node);
            case 264 /* Bundle */: return printBundle(node);
        }
        writeNode(hint, node, sourceFile, beginPrint());
        return endPrint();
    }
    function printBundle(bundle) {
        writeBundle(bundle, beginPrint());
        return endPrint();
    }
    function printFile(sourceFile) {
        writeFile(sourceFile, beginPrint());
        return endPrint();
    }
    function writeNode(hint, node, sourceFile, output) {
        var previousWriter = writer;
        setWriter(output);
        print(hint, node, sourceFile);
        reset();
        writer = previousWriter;
    }
    function writeBundle(bundle, output) {
        var previousWriter = writer;
        setWriter(output);
        emitHelpersIndirect(bundle);
        for (var _a = 0, _b = bundle.sourceFiles; _a &lt; _b.length; _a++) {
            var sourceFile = _b[_a];
            print(0 /* SourceFile */, sourceFile, sourceFile);
        }
        reset();
        writer = previousWriter;
    }
    function writeFile(sourceFile, output) {
        var previousWriter = writer;
        setWriter(output);
        print(0 /* SourceFile */, sourceFile, sourceFile);
        reset();
        writer = previousWriter;
    }
    function beginPrint() {
        return ownWriter || (ownWriter = ts.createTextWriter(newLine));
    }
    function endPrint() {
        var text = ownWriter.getText();
        ownWriter.reset();
        return text;
    }
    function print(hint, node, sourceFile) {
        setSourceFile(sourceFile);
        pipelineEmitWithNotification(hint, node);
    }
    function setSourceFile(sourceFile) {
        currentSourceFile = sourceFile;
        comments.setSourceFile(sourceFile);
        if (onSetSour ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createProgram" id="apidoc.element.typescript.createProgram">
        function <span class="apidocSignatureSpan">typescript.</span>createProgram
        <span class="apidocSignatureSpan">(rootNames, options, host, oldProgram)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createProgram(rootNames, options, host, oldProgram) {
    var program;
    var files = [];
    var commonSourceDirectory;
    var diagnosticsProducingTypeChecker;
    var noDiagnosticsTypeChecker;
    var classifiableNames;
    var resolvedTypeReferenceDirectives = ts.createMap();
    var fileProcessingDiagnostics = ts.createDiagnosticCollection();
    // The below settings are to track if a .js file should be add to the program if loaded via searching under node_modules.
    // This works as imported modules are discovered recursively in a depth first manner, specifically:
    // - For each root file, findSourceFile is called.
    // - This calls processImportedModules for each module imported in the source file.
    // - This calls resolveModuleNames, and then calls findSourceFile for each resolved module.
    // As all these operations happen - and are nested - within the createProgram call, they close over the below variables.
    // The current resolution depth is tracked by incrementing/decrementing as the depth first search progresses.
    var maxNodeModuleJsDepth = typeof options.maxNodeModuleJsDepth === "number" ? options.maxNodeModuleJsDepth : 0;
    var currentNodeModulesDepth = 0;
    // If a module has some of its imports skipped due to being at the depth limit under node_modules, then track
    // this, as it may be imported at a shallower depth later, and then it will need its skipped imports processed.
    var modulesWithElidedImports = ts.createMap();
    // Track source files that are source files found by searching under node_modules, as these shouldn't be compiled.
    var sourceFilesFoundSearchingNodeModules = ts.createMap();
    ts.performance.mark("beforeProgram");
    host = host || createCompilerHost(options);
    var skipDefaultLib = options.noLib;
    var programDiagnostics = ts.createDiagnosticCollection();
    var currentDirectory = host.getCurrentDirectory();
    var supportedExtensions = ts.getSupportedExtensions(options);
    // Map storing if there is emit blocking diagnostics for given input
    var hasEmitBlockingDiagnostics = ts.createFileMap(getCanonicalFileName);
    var moduleResolutionCache;
    var resolveModuleNamesWorker;
    if (host.resolveModuleNames) {
        resolveModuleNamesWorker = function (moduleNames, containingFile) { return host.resolveModuleNames(moduleNames, containingFile
).map(function (resolved) {
            // An older host may have omitted extension, in which case we should infer it from the file extension of resolvedFileName
.
            if (!resolved || resolved.extension !== undefined) {
                return resolved;
            }
            var withExtension = ts.clone(resolved);
            withExtension.extension = ts.extensionFromPath(resolved.resolvedFileName);
            return withExtension;
        }); };
    }
    else {
        moduleResolutionCache = ts.createModuleResolutionCache(currentDirectory, function (x) { return host.getCanonicalFileName
(x); });
        var loader_1 = function (moduleName, containingFile) { return ts.resolveModuleName(moduleName, containingFile, options,
host, moduleResolutionCache).resolvedModule; };
        resolveModuleNamesWorker = function (moduleNames, containingFile) { return loadWithLocalCache(moduleNames, containingFile
, loader_1); };
    }
    var resolveTypeReferenceDirectiveNamesWorker;
    if (host.resolveTypeReferenceDirectives) {
        resolveTypeReferenceDirectiveNamesWorker = function (typeDirectiveNames, containingFile) { return host.resolveTypeReferenceDirectives
(typeDirectiveNames, containingFile); };
    }
    else {
        var loader_2 = function (typesRef, containingFile) { return ts.resolveTypeReferenceDirective(typesRef, containingFile, options
, host).resolvedTypeReferenceDirective; };
        resolveTypeReferenceDirectiveNamesWorker = function (typeReferenceDirectiveNames, containingFile) { return loadWithLocalCache
(typeReferenceDirectiveNames, containingFile, loader_2); };
    }
    var filesByName = ts.createFileMap();
    // stores 'filename -&gt; file association' igno ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createProperty" id="apidoc.element.typescript.createProperty">
        function <span class="apidocSignatureSpan">typescript.</span>createProperty
        <span class="apidocSignatureSpan">(decorators, modifiers, name, questionToken, type, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createProperty(decorators, modifiers, name, questionToken, type, initializer) {
    var node = createSynthesizedNode(148 /* PropertyDeclaration */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.name = asName(name);
    node.questionToken = questionToken;
    node.type = type;
    node.initializer = initializer;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createPropertyAccess" id="apidoc.element.typescript.createPropertyAccess">
        function <span class="apidocSignatureSpan">typescript.</span>createPropertyAccess
        <span class="apidocSignatureSpan">(expression, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPropertyAccess(expression, name) {
    var node = createSynthesizedNode(178 /* PropertyAccessExpression */);
    node.expression = ts.parenthesizeForAccess(expression);
    node.name = asName(name);
    setEmitFlags(node, 65536 /* NoIndentation */);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createPropertyAssignment" id="apidoc.element.typescript.createPropertyAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>createPropertyAssignment
        <span class="apidocSignatureSpan">(name, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPropertyAssignment(name, initializer) {
    var node = createSynthesizedNode(259 /* PropertyAssignment */);
    node.name = asName(name);
    node.questionToken = undefined;
    node.initializer = initializer !== undefined ? ts.parenthesizeExpressionForList(initializer) : undefined;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createQualifiedName" id="apidoc.element.typescript.createQualifiedName">
        function <span class="apidocSignatureSpan">typescript.</span>createQualifiedName
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createQualifiedName(left, right) {
    var node = createSynthesizedNode(142 /* QualifiedName */);
    node.left = left;
    node.right = asName(right);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createRange" id="apidoc.element.typescript.createRange">
        function <span class="apidocSignatureSpan">typescript.</span>createRange
        <span class="apidocSignatureSpan">(pos, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRange(pos, end) {
    return { pos: pos, end: end };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createReturn" id="apidoc.element.typescript.createReturn">
        function <span class="apidocSignatureSpan">typescript.</span>createReturn
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createReturn(expression) {
    var node = createSynthesizedNode(218 /* ReturnStatement */);
    node.expression = expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createScanner" id="apidoc.element.typescript.createScanner">
        function <span class="apidocSignatureSpan">typescript.</span>createScanner
        <span class="apidocSignatureSpan">(languageVersion, skipTrivia, languageVariant, text, onError, start, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createScanner(languageVersion, skipTrivia, languageVariant, text, onError, start, length) {
    if (languageVariant === void 0) { languageVariant = 0<span class="apidocCodeCommentSpan"> /* Standard */; }
    // Current position (end position of text of current token)
    var pos;
    // end of text
    var end;
    // Start position of whitespace before current token
    var startPos;
    // Start position of text of current token
    var tokenPos;
    var token;
    var tokenValue;
    var precedingLineBreak;
    var hasExtendedUnicodeEscape;
    var tokenIsUnterminated;
    setText(text, start, length);
    return {
        getStartPos: function () { return startPos; },
        getTextPos: function () { return pos; },
        getToken: function () { return token; },
        getTokenPos: function () { return tokenPos; },
        getTokenText: function () { return text.substring(tokenPos, pos); },
        getTokenValue: function () { return tokenValue; },
        hasExtendedUnicodeEscape: function () { return hasExtendedUnicodeEscape; },
        hasPrecedingLineBreak: function () { return precedingLineBreak; },
        isIdentifier: function () { return token === 70 /* Identifier */ || token &gt; 106 /* LastReservedWord */; },
        isReservedWord: function () { return token &gt;= 71 /* FirstReservedWord */ &amp;&amp; token &lt;= 106 /* LastReservedWord */; },
        isUnterminated: function () { return tokenIsUnterminated; },
        reScanGreaterToken: reScanGreaterToken,
        reScanSlashToken: reScanSlashToken,
        reScanTemplateToken: reScanTemplateToken,
        scanJsxIdentifier: scanJsxIdentifier,
        scanJsxAttributeValue: scanJsxAttributeValue,
        reScanJsxToken: reScanJsxToken,
        scanJsxToken: scanJsxToken,
        scanJSDocToken: scanJSDocToken,
        scan: scan,
        getText: getText,
        setText: setText,
        setScriptTarget: setScriptTarget,
        setLanguageVariant: setLanguageVariant,
        setOnError: setOnError,
        setTextPos: setTextPos,
        tryScan: tryScan,
        lookAhead: lookAhead,
        scanRange: scanRange,
    };
    function error(message, length) {
        if (onError) {
            onError(message, length || 0);
        }
    }
    function scanNumber() {
        var start = pos;
        while (isDigit(text.charCodeAt(pos)))
            pos++;
        if (text.charCodeAt(pos) === 46 /* dot */) {
            pos++;
            while (isDigit(text.charCodeAt(pos)))
                pos++;
        }
        var end = pos;
        if (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */) {
            pos++;
            if (text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */)
                pos++;
            if (isDigit(text.charCodeAt(pos))) {
                pos++;
                while (isDigit(text.charCodeAt(pos)))
                    pos++;
                end = pos;
            }
            else {
                error(ts.Diagnostics.Digit_expected);
            }
        }
        return "" + +(text.substring(start, end));
    }
    function scanOctalDigits() {
        var start = pos;
        while (isOctalDigit(text.charCodeAt(pos))) {
            pos++;
        }
        return +(text.substring(start, pos));
    }
    /**
     * Scans the given number of hexadecimal digits in the text,
     * returning -1 if the given number is unavailable.
     */
</span>    function scanExactNumberOfHexDigits(count) {
        return scanHexDigits(/*minCount*/ count, /*scanAsManyAsPossible*/ false);
    }
    /**
     * Scans as many hexadecimal digits as are available in the text,
     * returning -1 if the given number of digits was unavailable.
     */
    function scanMinimumNumberOfHexDigits(count) {
        return scanHexDigits(/*minCount*/ count, /*scanAsManyAsPossible*/ true);
    }
    function scanHexDigits(minCount, scanAsManyAsPossible) {
        var digits = 0;
        var value = 0;
        while (digits &lt; minCount || scanAsManyAsPossible) {
            var ch = text.charCodeAt(pos);
            if (ch &gt;= 48 /* _0 */ &amp;&amp; ch &lt;= 57 ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createSetAccessor" id="apidoc.element.typescript.createSetAccessor">
        function <span class="apidocSignatureSpan">typescript.</span>createSetAccessor
        <span class="apidocSignatureSpan">(decorators, modifiers, name, parameters, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSetAccessor(decorators, modifiers, name, parameters, body) {
    var node = createSynthesizedNode(153 /* SetAccessor */);
    node.decorators = asNodeArray(decorators);
    node.modifiers = asNodeArray(modifiers);
    node.name = asName(name);
    node.typeParameters = undefined;
    node.parameters = createNodeArray(parameters);
    node.body = body;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createShorthandPropertyAssignment" id="apidoc.element.typescript.createShorthandPropertyAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>createShorthandPropertyAssignment
        <span class="apidocSignatureSpan">(name, objectAssignmentInitializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createShorthandPropertyAssignment(name, objectAssignmentInitializer) {
    var node = createSynthesizedNode(260 /* ShorthandPropertyAssignment */);
    node.name = asName(name);
    node.objectAssignmentInitializer = objectAssignmentInitializer !== undefined ? ts.parenthesizeExpressionForList(objectAssignmentInitializer
) : undefined;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createSourceFile" id="apidoc.element.typescript.createSourceFile">
        function <span class="apidocSignatureSpan">typescript.</span>createSourceFile
        <span class="apidocSignatureSpan">(fileName, sourceText, languageVersion, setParentNodes, scriptKind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSourceFile(fileName, sourceText, languageVersion, setParentNodes, scriptKind) {
    if (setParentNodes === void 0) { setParentNodes = false; }
    ts.performance.mark("beforeParse");
    var result = Parser.parseSourceFile(fileName, sourceText, languageVersion, /*syntaxCursor*/ undefined, setParentNodes, scriptKind
);
    ts.performance.mark("afterParse");
    ts.performance.measure("Parse", "beforeParse", "afterParse");
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createSourceMapWriter" id="apidoc.element.typescript.createSourceMapWriter">
        function <span class="apidocSignatureSpan">typescript.</span>createSourceMapWriter
        <span class="apidocSignatureSpan">(host, writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSourceMapWriter(host, writer) {
    var compilerOptions = host.getCompilerOptions();
    var extendedDiagnostics = compilerOptions.extendedDiagnostics;
    var currentSourceFile;
    var currentSourceText;
    var sourceMapDir; // The directory in which sourcemap will be
    // Current source map file and its index in the sources list
    var sourceMapSourceIndex;
    // Last recorded and encoded spans
    var lastRecordedSourceMapSpan;
    var lastEncodedSourceMapSpan;
    var lastEncodedNameIndex;
    // Source map data
    var sourceMapData;
    var disabled = !(compilerOptions.sourceMap || compilerOptions.inlineSourceMap);
    return {
        initialize: initialize,
        reset: reset,
        getSourceMapData: function () { return sourceMapData; },
        setSourceFile: setSourceFile,
        emitPos: emitPos,
        emitNodeWithSourceMap: emitNodeWithSourceMap,
        emitTokenWithSourceMap: emitTokenWithSourceMap,
        getText: getText,
        getSourceMappingURL: getSourceMappingURL,
    };
<span class="apidocCodeCommentSpan">    /**
     * Initialize the SourceMapWriter for a new output file.
     *
     * @param filePath The path to the generated output file.
     * @param sourceMapFilePath The path to the output source map file.
     * @param sourceFileOrBundle The input source file or bundle for the program.
     */
</span>    function initialize(filePath, sourceMapFilePath, sourceFileOrBundle) {
        if (disabled) {
            return;
        }
        if (sourceMapData) {
            reset();
        }
        currentSourceFile = undefined;
        currentSourceText = undefined;
        // Current source map file and its index in the sources list
        sourceMapSourceIndex = -1;
        // Last recorded and encoded spans
        lastRecordedSourceMapSpan = undefined;
        lastEncodedSourceMapSpan = defaultLastEncodedSourceMapSpan;
        lastEncodedNameIndex = 0;
        // Initialize source map data
        sourceMapData = {
            sourceMapFilePath: sourceMapFilePath,
            jsSourceMappingURL: !compilerOptions.inlineSourceMap ? ts.getBaseFileName(ts.normalizeSlashes(sourceMapFilePath)) :
undefined,
            sourceMapFile: ts.getBaseFileName(ts.normalizeSlashes(filePath)),
            sourceMapSourceRoot: compilerOptions.sourceRoot || "",
            sourceMapSources: [],
            inputSourceFileNames: [],
            sourceMapNames: [],
            sourceMapMappings: "",
            sourceMapSourcesContent: compilerOptions.inlineSources ? [] : undefined,
            sourceMapDecodedMappings: []
        };
        // Normalize source root and make sure it has trailing "/" so that it can be used to combine paths with the
        // relative paths of the sources list in the sourcemap
        sourceMapData.sourceMapSourceRoot = ts.normalizeSlashes(sourceMapData.sourceMapSourceRoot);
        if (sourceMapData.sourceMapSourceRoot.length &amp;&amp; sourceMapData.sourceMapSourceRoot.charCodeAt(sourceMapData.sourceMapSourceRoot
.length - 1) !== 47 /* slash */) {
            sourceMapData.sourceMapSourceRoot += ts.directorySeparator;
        }
        if (compilerOptions.mapRoot) {
            sourceMapDir = ts.normalizeSlashes(compilerOptions.mapRoot);
            if (sourceFileOrBundle.kind === 263 /* SourceFile */) {
                // For modules or multiple emit files the mapRoot will have directory structure like the sources
                // So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and
 mapRoot\lib\b.js.map
                sourceMapDir = ts.getDirectoryPath(ts.getSourceFilePathInNewDir(sourceFileOrBundle, host, sourceMapDir));
            }
            if (!ts.isRootedDiskPath(sourceMapDir) &amp;&amp; !ts.isUrl(sourceMapDir)) {
                // The relative paths are relative to the common directory
                sourceMapDir = ts.combinePaths(host.getCommonSourceDirectory(), sourceMapDir);
                sourceMapData.jsSourceMappingURL = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizePath(filePath
)), // get the relative s ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createSpread" id="apidoc.element.typescript.createSpread">
        function <span class="apidocSignatureSpan">typescript.</span>createSpread
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSpread(expression) {
    var node = createSynthesizedNode(197 /* SpreadElement */);
    node.expression = ts.parenthesizeExpressionForList(expression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createSpreadAssignment" id="apidoc.element.typescript.createSpreadAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>createSpreadAssignment
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSpreadAssignment(expression) {
    var node = createSynthesizedNode(261 /* SpreadAssignment */);
    node.expression = expression !== undefined ? ts.parenthesizeExpressionForList(expression) : undefined;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createStatement" id="apidoc.element.typescript.createStatement">
        function <span class="apidocSignatureSpan">typescript.</span>createStatement
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStatement(expression) {
    var node = createSynthesizedNode(209 /* ExpressionStatement */);
    node.expression = ts.parenthesizeExpressionForExpressionStatement(expression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createStrictEquality" id="apidoc.element.typescript.createStrictEquality">
        function <span class="apidocSignatureSpan">typescript.</span>createStrictEquality
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStrictEquality(left, right) {
    return createBinary(left, 33 /* EqualsEqualsEqualsToken */, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createStrictInequality" id="apidoc.element.typescript.createStrictInequality">
        function <span class="apidocSignatureSpan">typescript.</span>createStrictInequality
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStrictInequality(left, right) {
    return createBinary(left, 34 /* ExclamationEqualsEqualsToken */, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createSubtract" id="apidoc.element.typescript.createSubtract">
        function <span class="apidocSignatureSpan">typescript.</span>createSubtract
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSubtract(left, right) {
    return createBinary(left, 37 /* MinusToken */, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createSuper" id="apidoc.element.typescript.createSuper">
        function <span class="apidocSignatureSpan">typescript.</span>createSuper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSuper() {
    return createSynthesizedNode(96 /* SuperKeyword */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createSwitch" id="apidoc.element.typescript.createSwitch">
        function <span class="apidocSignatureSpan">typescript.</span>createSwitch
        <span class="apidocSignatureSpan">(expression, caseBlock)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSwitch(expression, caseBlock) {
    var node = createSynthesizedNode(220 /* SwitchStatement */);
    node.expression = ts.parenthesizeExpressionForList(expression);
    node.caseBlock = caseBlock;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTaggedTemplate" id="apidoc.element.typescript.createTaggedTemplate">
        function <span class="apidocSignatureSpan">typescript.</span>createTaggedTemplate
        <span class="apidocSignatureSpan">(tag, template)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTaggedTemplate(tag, template) {
    var node = createSynthesizedNode(182 /* TaggedTemplateExpression */);
    node.tag = ts.parenthesizeForAccess(tag);
    node.template = template;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTempVariable" id="apidoc.element.typescript.createTempVariable">
        function <span class="apidocSignatureSpan">typescript.</span>createTempVariable
        <span class="apidocSignatureSpan">(recordTempVariable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTempVariable(recordTempVariable) {
    var name = createIdentifier("");
    name.autoGenerateKind = 1 /* Auto */;
    name.autoGenerateId = nextAutoGenerateId;
    nextAutoGenerateId++;
    if (recordTempVariable) {
        recordTempVariable(name);
    }
    return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTemplateExpression" id="apidoc.element.typescript.createTemplateExpression">
        function <span class="apidocSignatureSpan">typescript.</span>createTemplateExpression
        <span class="apidocSignatureSpan">(head, templateSpans)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTemplateExpression(head, templateSpans) {
    var node = createSynthesizedNode(195 /* TemplateExpression */);
    node.head = head;
    node.templateSpans = createNodeArray(templateSpans);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTemplateSpan" id="apidoc.element.typescript.createTemplateSpan">
        function <span class="apidocSignatureSpan">typescript.</span>createTemplateSpan
        <span class="apidocSignatureSpan">(expression, literal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTemplateSpan(expression, literal) {
    var node = createSynthesizedNode(204 /* TemplateSpan */);
    node.expression = expression;
    node.literal = literal;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTextChangeRange" id="apidoc.element.typescript.createTextChangeRange">
        function <span class="apidocSignatureSpan">typescript.</span>createTextChangeRange
        <span class="apidocSignatureSpan">(span, newLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTextChangeRange(span, newLength) {
    if (newLength &lt; 0) {
        throw new Error("newLength &lt; 0");
    }
    return { span: span, newLength: newLength };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTextSpan" id="apidoc.element.typescript.createTextSpan">
        function <span class="apidocSignatureSpan">typescript.</span>createTextSpan
        <span class="apidocSignatureSpan">(start, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTextSpan(start, length) {
    if (start &lt; 0) {
        throw new Error("start &lt; 0");
    }
    if (length &lt; 0) {
        throw new Error("length &lt; 0");
    }
    return { start: start, length: length };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTextSpanFromBounds" id="apidoc.element.typescript.createTextSpanFromBounds">
        function <span class="apidocSignatureSpan">typescript.</span>createTextSpanFromBounds
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTextSpanFromBounds(start, end) {
    return createTextSpan(start, end - start);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTextSpanFromNode" id="apidoc.element.typescript.createTextSpanFromNode">
        function <span class="apidocSignatureSpan">typescript.</span>createTextSpanFromNode
        <span class="apidocSignatureSpan">(node, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTextSpanFromNode(node, sourceFile) {
    return ts.createTextSpanFromBounds(node.getStart(sourceFile), node.getEnd());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTextWriter" id="apidoc.element.typescript.createTextWriter">
        function <span class="apidocSignatureSpan">typescript.</span>createTextWriter
        <span class="apidocSignatureSpan">(newLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTextWriter(newLine) {
    var output;
    var indent;
    var lineStart;
    var lineCount;
    var linePos;
    function write(s) {
        if (s &amp;&amp; s.length) {
            if (lineStart) {
                output += getIndentString(indent);
                lineStart = false;
            }
            output += s;
        }
    }
    function reset() {
        output = "";
        indent = 0;
        lineStart = true;
        lineCount = 0;
        linePos = 0;
    }
    function rawWrite(s) {
        if (s !== undefined) {
            if (lineStart) {
                lineStart = false;
            }
            output += s;
        }
    }
    function writeLiteral(s) {
        if (s &amp;&amp; s.length) {
            write(s);
            var lineStartsOfS = ts.computeLineStarts(s);
            if (lineStartsOfS.length &gt; 1) {
                lineCount = lineCount + lineStartsOfS.length - 1;
                linePos = output.length - s.length + ts.lastOrUndefined(lineStartsOfS);
            }
        }
    }
    function writeLine() {
        if (!lineStart) {
            output += newLine;
            lineCount++;
            linePos = output.length;
            lineStart = true;
        }
    }
    function writeTextOfNode(text, node) {
        write(getTextOfNodeFromSourceText(text, node));
    }
    reset();
    return {
        write: write,
        rawWrite: rawWrite,
        writeTextOfNode: writeTextOfNode,
        writeLiteral: writeLiteral,
        writeLine: writeLine,
        increaseIndent: function () { indent++; },
        decreaseIndent: function () { indent--; },
        getIndent: function () { return indent; },
        getTextPos: function () { return output.length; },
        getLine: function () { return lineCount + 1; },
        getColumn: function () { return lineStart ? indent * getIndentSize() + 1 : output.length - linePos + 1; },
        getText: function () { return output; },
        isAtStartOfLine: function () { return lineStart; },
        reset: reset
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createThis" id="apidoc.element.typescript.createThis">
        function <span class="apidocSignatureSpan">typescript.</span>createThis
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createThis() {
    return createSynthesizedNode(98 /* ThisKeyword */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createThrow" id="apidoc.element.typescript.createThrow">
        function <span class="apidocSignatureSpan">typescript.</span>createThrow
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createThrow(expression) {
    var node = createSynthesizedNode(222 /* ThrowStatement */);
    node.expression = expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createToken" id="apidoc.element.typescript.createToken">
        function <span class="apidocSignatureSpan">typescript.</span>createToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createToken(token) {
    return createSynthesizedNode(token);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTokenRange" id="apidoc.element.typescript.createTokenRange">
        function <span class="apidocSignatureSpan">typescript.</span>createTokenRange
        <span class="apidocSignatureSpan">(pos, token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTokenRange(pos, token) {
    return createRange(pos, pos + ts.tokenToString(token).length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTrue" id="apidoc.element.typescript.createTrue">
        function <span class="apidocSignatureSpan">typescript.</span>createTrue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTrue() {
    return createSynthesizedNode(100 /* TrueKeyword */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTry" id="apidoc.element.typescript.createTry">
        function <span class="apidocSignatureSpan">typescript.</span>createTry
        <span class="apidocSignatureSpan">(tryBlock, catchClause, finallyBlock)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTry(tryBlock, catchClause, finallyBlock) {
    var node = createSynthesizedNode(223 /* TryStatement */);
    node.tryBlock = tryBlock;
    node.catchClause = catchClause;
    node.finallyBlock = finallyBlock;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTypeAssertion" id="apidoc.element.typescript.createTypeAssertion">
        function <span class="apidocSignatureSpan">typescript.</span>createTypeAssertion
        <span class="apidocSignatureSpan">(type, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTypeAssertion(type, expression) {
    var node = createSynthesizedNode(183 /* TypeAssertionExpression */);
    node.type = type;
    node.expression = ts.parenthesizePrefixOperand(expression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTypeCheck" id="apidoc.element.typescript.createTypeCheck">
        function <span class="apidocSignatureSpan">typescript.</span>createTypeCheck
        <span class="apidocSignatureSpan">(value, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTypeCheck(value, tag) {
    return tag === "undefined"
        ? ts.createStrictEquality(value, ts.createVoidZero())
        : ts.createStrictEquality(ts.createTypeOf(value), ts.createLiteral(tag));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTypeChecker" id="apidoc.element.typescript.createTypeChecker">
        function <span class="apidocSignatureSpan">typescript.</span>createTypeChecker
        <span class="apidocSignatureSpan">(host, produceDiagnostics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTypeChecker(host, produceDiagnostics) {
    // Cancellation that controls whether or not we can cancel in the middle of type checking.
    // In general cancelling is *not* safe for the type checker.  We might be in the middle of
    // computing something, and we will leave our internals in an inconsistent state.  Callers
    // who set the cancellation token should catch if a cancellation exception occurs, and
    // should throw away and create a new TypeChecker.
    //
    // Currently we only support setting the cancellation token when getting diagnostics.  This
    // is because diagnostics can be quite expensive, and we want to allow hosts to bail out if
    // they no longer need the information (for example, if the user started editing again).
    var cancellationToken;
    var requestedExternalEmitHelpers;
    var externalHelpersModule;
    var Symbol = ts.objectAllocator.getSymbolConstructor();
    var Type = ts.objectAllocator.getTypeConstructor();
    var Signature = ts.objectAllocator.getSignatureConstructor();
    var typeCount = 0;
    var symbolCount = 0;
    var emptyArray = [];
    var emptySymbols = ts.createMap();
    var compilerOptions = host.getCompilerOptions();
    var languageVersion = compilerOptions.target || 0 /* ES3 */;
    var modulekind = ts.getEmitModuleKind(compilerOptions);
    var noUnusedIdentifiers = !!compilerOptions.noUnusedLocals || !!compilerOptions.noUnusedParameters;
    var allowSyntheticDefaultImports = typeof compilerOptions.allowSyntheticDefaultImports !== "undefined" ? compilerOptions.allowSyntheticDefaultImports
 : modulekind === ts.ModuleKind.System;
    var strictNullChecks = compilerOptions.strictNullChecks;
    var emitResolver = createResolver();
    var undefinedSymbol = createSymbol(4 /* Property */, "undefined");
    undefinedSymbol.declarations = [];
    var argumentsSymbol = createSymbol(4 /* Property */, "arguments");
    var checker = {
        getNodeCount: function () { return ts.sum(host.getSourceFiles(), "nodeCount"); },
        getIdentifierCount: function () { return ts.sum(host.getSourceFiles(), "identifierCount"); },
        getSymbolCount: function () { return ts.sum(host.getSourceFiles(), "symbolCount") + symbolCount; },
        getTypeCount: function () { return typeCount; },
        isUndefinedSymbol: function (symbol) { return symbol === undefinedSymbol; },
        isArgumentsSymbol: function (symbol) { return symbol === argumentsSymbol; },
        isUnknownSymbol: function (symbol) { return symbol === unknownSymbol; },
        getDiagnostics: getDiagnostics,
        getGlobalDiagnostics: getGlobalDiagnostics,
        getTypeOfSymbolAtLocation: getTypeOfSymbolAtLocation,
        getSymbolsOfParameterPropertyDeclaration: getSymbolsOfParameterPropertyDeclaration,
        getDeclaredTypeOfSymbol: getDeclaredTypeOfSymbol,
        getPropertiesOfType: getPropertiesOfType,
        getPropertyOfType: getPropertyOfType,
        getIndexInfoOfType: getIndexInfoOfType,
        getSignaturesOfType: getSignaturesOfType,
        getIndexTypeOfType: getIndexTypeOfType,
        getBaseTypes: getBaseTypes,
        getBaseTypeOfLiteralType: getBaseTypeOfLiteralType,
        getWidenedType: getWidenedType,
        getTypeFromTypeNode: getTypeFromTypeNode,
        getParameterType: getTypeAtPosition,
        getReturnTypeOfSignature: getReturnTypeOfSignature,
        getNonNullableType: getNonNullableType,
        getSymbolsInScope: getSymbolsInScope,
        getSymbolAtLocation: getSymbolAtLocation,
        getShorthandAssignmentValueSymbol: getShorthandAssignmentValueSymbol,
        getExportSpecifierLocalTargetSymbol: getExportSpecifierLocalTargetSymbol,
        getTypeAtLocation: getTypeOfNode,
        getPropertySymbolOfDestructuringAssignment: getPropertySymbolOfDestructuringAssignment,
        signatureToString: signatureToString,
        typeToString: typeToString,
        getSymbolDisplayBuilder: getSymbolDisplayBuilder,
        symbolToString: symbolToString,
        getAugmentedPropertiesOfType: getAugmentedPropertiesOfType,
        getRoo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createTypeOf" id="apidoc.element.typescript.createTypeOf">
        function <span class="apidocSignatureSpan">typescript.</span>createTypeOf
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTypeOf(expression) {
    var node = createSynthesizedNode(188 /* TypeOfExpression */);
    node.expression = ts.parenthesizePrefixOperand(expression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createUniqueName" id="apidoc.element.typescript.createUniqueName">
        function <span class="apidocSignatureSpan">typescript.</span>createUniqueName
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createUniqueName(text) {
    var name = createIdentifier(text);
    name.autoGenerateKind = 3 /* Unique */;
    name.autoGenerateId = nextAutoGenerateId;
    nextAutoGenerateId++;
    return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createVariableDeclaration" id="apidoc.element.typescript.createVariableDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>createVariableDeclaration
        <span class="apidocSignatureSpan">(name, type, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createVariableDeclaration(name, type, initializer) {
    var node = createSynthesizedNode(225 /* VariableDeclaration */);
    node.name = asName(name);
    node.type = type;
    node.initializer = initializer !== undefined ? ts.parenthesizeExpressionForList(initializer) : undefined;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createVariableDeclarationList" id="apidoc.element.typescript.createVariableDeclarationList">
        function <span class="apidocSignatureSpan">typescript.</span>createVariableDeclarationList
        <span class="apidocSignatureSpan">(declarations, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createVariableDeclarationList(declarations, flags) {
    var node = createSynthesizedNode(226 /* VariableDeclarationList */);
    node.flags |= flags;
    node.declarations = createNodeArray(declarations);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createVariableStatement" id="apidoc.element.typescript.createVariableStatement">
        function <span class="apidocSignatureSpan">typescript.</span>createVariableStatement
        <span class="apidocSignatureSpan">(modifiers, declarationList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createVariableStatement(modifiers, declarationList) {
    var node = createSynthesizedNode(207 /* VariableStatement */);
    node.decorators = undefined;
    node.modifiers = asNodeArray(modifiers);
    node.declarationList = ts.isArray(declarationList) ? createVariableDeclarationList(declarationList) : declarationList;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createVoid" id="apidoc.element.typescript.createVoid">
        function <span class="apidocSignatureSpan">typescript.</span>createVoid
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createVoid(expression) {
    var node = createSynthesizedNode(189 /* VoidExpression */);
    node.expression = ts.parenthesizePrefixOperand(expression);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createVoidZero" id="apidoc.element.typescript.createVoidZero">
        function <span class="apidocSignatureSpan">typescript.</span>createVoidZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createVoidZero() {
    return createVoid(createLiteral(0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createWhile" id="apidoc.element.typescript.createWhile">
        function <span class="apidocSignatureSpan">typescript.</span>createWhile
        <span class="apidocSignatureSpan">(expression, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createWhile(expression, statement) {
    var node = createSynthesizedNode(212 /* WhileStatement */);
    node.expression = expression;
    node.statement = statement;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createWith" id="apidoc.element.typescript.createWith">
        function <span class="apidocSignatureSpan">typescript.</span>createWith
        <span class="apidocSignatureSpan">(expression, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createWith(expression, statement) {
    var node = createSynthesizedNode(219 /* WithStatement */);
    node.expression = expression;
    node.statement = statement;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.createYield" id="apidoc.element.typescript.createYield">
        function <span class="apidocSignatureSpan">typescript.</span>createYield
        <span class="apidocSignatureSpan">(asteriskTokenOrExpression, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createYield(asteriskTokenOrExpression, expression) {
    var node = createSynthesizedNode(196 /* YieldExpression */);
    node.asteriskToken = asteriskTokenOrExpression &amp;&amp; asteriskTokenOrExpression.kind === 38 /* AsteriskToken */ ? asteriskTokenOrExpression
 : undefined;
    node.expression = asteriskTokenOrExpression &amp;&amp; asteriskTokenOrExpression.kind !== 38 /* AsteriskToken */ ? asteriskTokenOrExpression
 : expression;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.declarationNameToString" id="apidoc.element.typescript.declarationNameToString">
        function <span class="apidocSignatureSpan">typescript.</span>declarationNameToString
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function declarationNameToString(name) {
    return getFullWidth(name) === 0 ? "(Missing)" : getTextOfNode(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.decodedTextSpanIntersectsWith" id="apidoc.element.typescript.decodedTextSpanIntersectsWith">
        function <span class="apidocSignatureSpan">typescript.</span>decodedTextSpanIntersectsWith
        <span class="apidocSignatureSpan">(start1, length1, start2, length2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodedTextSpanIntersectsWith(start1, length1, start2, length2) {
    var end1 = start1 + length1;
    var end2 = start2 + length2;
    return start2 &lt;= end1 &amp;&amp; end2 &gt;= start1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.deduplicate" id="apidoc.element.typescript.deduplicate">
        function <span class="apidocSignatureSpan">typescript.</span>deduplicate
        <span class="apidocSignatureSpan">(array, areEqual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deduplicate(array, areEqual) {
    var result;
    if (array) {
        result = [];
        loop: for (var _i = 0, array_6 = array; _i &lt; array_6.length; _i++) {
            var item = array_6[_i];
            for (var _a = 0, result_1 = result; _a &lt; result_1.length; _a++) {
                var res = result_1[_a];
                if (areEqual ? areEqual(res, item) : res === item) {
                    continue loop;
                }
            }
            result.push(item);
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.deduplicateSortedDiagnostics" id="apidoc.element.typescript.deduplicateSortedDiagnostics">
        function <span class="apidocSignatureSpan">typescript.</span>deduplicateSortedDiagnostics
        <span class="apidocSignatureSpan">(diagnostics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deduplicateSortedDiagnostics(diagnostics) {
    if (diagnostics.length &lt; 2) {
        return diagnostics;
    }
    var newDiagnostics = [diagnostics[0]];
    var previousDiagnostic = diagnostics[0];
    for (var i = 1; i &lt; diagnostics.length; i++) {
        var currentDiagnostic = diagnostics[i];
        var isDupe = compareDiagnostics(currentDiagnostic, previousDiagnostic) === 0 /* EqualTo */;
        if (!isDupe) {
            newDiagnostics.push(currentDiagnostic);
            previousDiagnostic = currentDiagnostic;
        }
    }
    return newDiagnostics;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.directoryProbablyExists" id="apidoc.element.typescript.directoryProbablyExists">
        function <span class="apidocSignatureSpan">typescript.</span>directoryProbablyExists
        <span class="apidocSignatureSpan">(directoryName, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function directoryProbablyExists(directoryName, host) {
    // if host does not support 'directoryExists' assume that directory will exist
    return !host.directoryExists || host.directoryExists(directoryName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.displayPart" id="apidoc.element.typescript.displayPart">
        function <span class="apidocSignatureSpan">typescript.</span>displayPart
        <span class="apidocSignatureSpan">(text, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function displayPart(text, kind) {
    return {
        text: text,
        kind: ts.SymbolDisplayPartKind[kind]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.displayPartsToString" id="apidoc.element.typescript.displayPartsToString">
        function <span class="apidocSignatureSpan">typescript.</span>displayPartsToString
        <span class="apidocSignatureSpan">(displayParts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function displayPartsToString(displayParts) {
    if (displayParts) {
        return ts.map(displayParts, function (displayPart) { return displayPart.text; }).join("");
    }
    return "";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.disposeEmitNodes" id="apidoc.element.typescript.disposeEmitNodes">
        function <span class="apidocSignatureSpan">typescript.</span>disposeEmitNodes
        <span class="apidocSignatureSpan">(sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disposeEmitNodes(sourceFile) {
    // During transformation we may need to annotate a parse tree node with transient
    // transformation properties. As parse tree nodes live longer than transformation
    // nodes, we need to make sure we reclaim any memory allocated for custom ranges
    // from these nodes to ensure we do not hold onto entire subtrees just for position
    // information. We also need to reset these nodes to a pre-transformation state
    // for incremental parsing scenarios so that we do not impact later emit.
    sourceFile = ts.getSourceFileOfNode(ts.getParseTreeNode(sourceFile));
    var emitNode = sourceFile &amp;&amp; sourceFile.emitNode;
    var annotatedNodes = emitNode &amp;&amp; emitNode.annotatedNodes;
    if (annotatedNodes) {
        for (var _i = 0, annotatedNodes_1 = annotatedNodes; _i &lt; annotatedNodes_1.length; _i++) {
            var node = annotatedNodes_1[_i];
            node.emitNode = undefined;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.emitComments" id="apidoc.element.typescript.emitComments">
        function <span class="apidocSignatureSpan">typescript.</span>emitComments
        <span class="apidocSignatureSpan">(text, lineMap, writer, comments, leadingSeparator, trailingSeparator, newLine, writeComment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitComments(text, lineMap, writer, comments, leadingSeparator, trailingSeparator, newLine, writeComment) {
    if (comments &amp;&amp; comments.length &gt; 0) {
        if (leadingSeparator) {
            writer.write(" ");
        }
        var emitInterveningSeparator = false;
        for (var _i = 0, comments_1 = comments; _i &lt; comments_1.length; _i++) {
            var comment = comments_1[_i];
            if (emitInterveningSeparator) {
                writer.write(" ");
                emitInterveningSeparator = false;
            }
            writeComment(text, lineMap, writer, comment.pos, comment.end, newLine);
            if (comment.hasTrailingNewLine) {
                writer.writeLine();
            }
            else {
                emitInterveningSeparator = true;
            }
        }
        if (emitInterveningSeparator &amp;&amp; trailingSeparator) {
            writer.write(" ");
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.emitDetachedComments" id="apidoc.element.typescript.emitDetachedComments">
        function <span class="apidocSignatureSpan">typescript.</span>emitDetachedComments
        <span class="apidocSignatureSpan">(text, lineMap, writer, writeComment, node, newLine, removeComments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitDetachedComments(text, lineMap, writer, writeComment, node, newLine, removeComments) {
    var leadingComments;
    var currentDetachedCommentInfo;
    if (removeComments) {
        // removeComments is true, only reserve pinned comment at the top of file
        // For example:
        //<span class="apidocCodeCommentSpan">      /*! Pinned Comment */
</span>        //
        //      var x = 10;
        if (node.pos === 0) {
            leadingComments = ts.filter(ts.getLeadingCommentRanges(text, node.pos), isPinnedComment);
        }
    }
    else {
        // removeComments is false, just get detached as normal and bypass the process to filter comment
        leadingComments = ts.getLeadingCommentRanges(text, node.pos);
    }
    if (leadingComments) {
        var detachedComments = [];
        var lastComment = void 0;
        for (var _i = 0, leadingComments_1 = leadingComments; _i &lt; leadingComments_1.length; _i++) {
            var comment = leadingComments_1[_i];
            if (lastComment) {
                var lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, lastComment.end);
                var commentLine = getLineOfLocalPositionFromLineMap(lineMap, comment.pos);
                if (commentLine &gt;= lastCommentLine + 2) {
                    // There was a blank line between the last comment and this comment.  This
                    // comment is not part of the copyright comments.  Return what we have so
                    // far.
                    break;
                }
            }
            detachedComments.push(comment);
            lastComment = comment;
        }
        if (detachedComments.length) {
            // All comments look like they could have been part of the copyright header.  Make
            // sure there is at least one blank line between it and the node.  If not, it's not
            // a copyright header.
            var lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, ts.lastOrUndefined(detachedComments).end);
            var nodeLine = getLineOfLocalPositionFromLineMap(lineMap, ts.skipTrivia(text, node.pos));
            if (nodeLine &gt;= lastCommentLine + 2) {
                // Valid detachedComments
                emitNewLineBeforeLeadingComments(lineMap, writer, node, leadingComments);
                emitComments(text, lineMap, writer, detachedComments, /*leadingSeparator*/ false, /*trailingSeparator*/ true, newLine
, writeComment);
                currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: ts.lastOrUndefined(detachedComments).end
 };
            }
        }
    }
    return currentDetachedCommentInfo;
    function isPinnedComment(comment) {
        return text.charCodeAt(comment.pos + 1) === 42 /* asterisk */ &amp;&amp;
            text.charCodeAt(comment.pos + 2) === 33 /* exclamation */;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.emitFiles" id="apidoc.element.typescript.emitFiles">
        function <span class="apidocSignatureSpan">typescript.</span>emitFiles
        <span class="apidocSignatureSpan">(resolver, host, targetSourceFile, emitOnlyDtsFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitFiles(resolver, host, targetSourceFile, emitOnlyDtsFiles) {
    var compilerOptions = host.getCompilerOptions();
    var moduleKind = ts.getEmitModuleKind(compilerOptions);
    var sourceMapDataList = compilerOptions.sourceMap || compilerOptions.inlineSourceMap ? [] : undefined;
    var emittedFilesList = compilerOptions.listEmittedFiles ? [] : undefined;
    var emitterDiagnostics = ts.createDiagnosticCollection();
    var newLine = host.getNewLine();
    var transformers = emitOnlyDtsFiles ? [] : ts.getTransformers(compilerOptions);
    var writer = ts.createTextWriter(newLine);
    var sourceMap = ts.createSourceMapWriter(host, writer);
    var currentSourceFile;
    var bundledHelpers;
    var isOwnFileEmit;
    var emitSkipped = false;
    var sourceFiles = ts.getSourceFilesToEmit(host, targetSourceFile);
    // Transform the source files
    var transform = ts.transformFiles(resolver, host, sourceFiles, transformers);
    // Create a printer to print the nodes
    var printer = createPrinter(compilerOptions, {
        // resolver hooks
        hasGlobalName: resolver.hasGlobalName,
        // transform hooks
        onEmitNode: transform.emitNodeWithNotification,
        onSubstituteNode: transform.emitNodeWithSubstitution,
        // sourcemap hooks
        onEmitSourceMapOfNode: sourceMap.emitNodeWithSourceMap,
        onEmitSourceMapOfToken: sourceMap.emitTokenWithSourceMap,
        onEmitSourceMapOfPosition: sourceMap.emitPos,
        // emitter hooks
        onEmitHelpers: emitHelpers,
        onSetSourceFile: setSourceFile,
    });
    // Emit each output file
    ts.performance.mark("beforePrint");
    ts.forEachEmittedFile(host, emitSourceFileOrBundle, transform.transformed, emitOnlyDtsFiles);
    ts.performance.measure("printTime", "beforePrint");
    // Clean up emit nodes on parse tree
    for (var _a = 0, sourceFiles_2 = sourceFiles; _a &lt; sourceFiles_2.length; _a++) {
        var sourceFile = sourceFiles_2[_a];
        ts.disposeEmitNodes(sourceFile);
    }
    return {
        emitSkipped: emitSkipped,
        diagnostics: emitterDiagnostics.getDiagnostics(),
        emittedFiles: emittedFilesList,
        sourceMaps: sourceMapDataList
    };
    function emitSourceFileOrBundle(_a, sourceFileOrBundle) {
        var jsFilePath = _a.jsFilePath, sourceMapFilePath = _a.sourceMapFilePath, declarationFilePath = _a.declarationFilePath;
        // Make sure not to write js file and source map file if any of them cannot be written
        if (!host.isEmitBlocked(jsFilePath) &amp;&amp; !compilerOptions.noEmit) {
            if (!emitOnlyDtsFiles) {
                printSourceFileOrBundle(jsFilePath, sourceMapFilePath, sourceFileOrBundle);
            }
        }
        else {
            emitSkipped = true;
        }
        if (declarationFilePath) {
            emitSkipped = ts.writeDeclarationFile(declarationFilePath, ts.getOriginalSourceFileOrBundle(sourceFileOrBundle), host
, resolver, emitterDiagnostics, emitOnlyDtsFiles) || emitSkipped;
        }
        if (!emitSkipped &amp;&amp; emittedFilesList) {
            if (!emitOnlyDtsFiles) {
                emittedFilesList.push(jsFilePath);
            }
            if (sourceMapFilePath) {
                emittedFilesList.push(sourceMapFilePath);
            }
            if (declarationFilePath) {
                emittedFilesList.push(declarationFilePath);
            }
        }
    }
    function printSourceFileOrBundle(jsFilePath, sourceMapFilePath, sourceFileOrBundle) {
        var bundle = sourceFileOrBundle.kind === 264 /* Bundle */ ? sourceFileOrBundle : undefined;
        var sourceFile = sourceFileOrBundle.kind === 263 /* SourceFile */ ? sourceFileOrBundle : undefined;
        var sourceFiles = bundle ? bundle.sourceFiles : [sourceFile];
        sourceMap.initialize(jsFilePath, sourceMapFilePath, sourceFileOrBundle);
        if (bundle) {
            bundledHelpers = ts.createMap();
            isOwnFileEmit = false;
            printer.writeBundle(bundle, writer);
        }
        else {
            isOwnFileEmit = true;
            printer.writeF ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.emitNewLineBeforeLeadingCommentOfPosition" id="apidoc.element.typescript.emitNewLineBeforeLeadingCommentOfPosition">
        function <span class="apidocSignatureSpan">typescript.</span>emitNewLineBeforeLeadingCommentOfPosition
        <span class="apidocSignatureSpan">(lineMap, writer, pos, commentPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitNewLineBeforeLeadingCommentOfPosition(lineMap, writer, pos, commentPos) {
    // If the leading comments start on different line than the start of node, write new line
    if (pos !== commentPos &amp;&amp;
        getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, commentPos)) {
        writer.writeLine();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.emitNewLineBeforeLeadingComments" id="apidoc.element.typescript.emitNewLineBeforeLeadingComments">
        function <span class="apidocSignatureSpan">typescript.</span>emitNewLineBeforeLeadingComments
        <span class="apidocSignatureSpan">(lineMap, writer, node, leadingComments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitNewLineBeforeLeadingComments(lineMap, writer, node, leadingComments) {
    emitNewLineBeforeLeadingCommentsOfPosition(lineMap, writer, node.pos, leadingComments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.emitNewLineBeforeLeadingCommentsOfPosition" id="apidoc.element.typescript.emitNewLineBeforeLeadingCommentsOfPosition">
        function <span class="apidocSignatureSpan">typescript.</span>emitNewLineBeforeLeadingCommentsOfPosition
        <span class="apidocSignatureSpan">(lineMap, writer, pos, leadingComments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitNewLineBeforeLeadingCommentsOfPosition(lineMap, writer, pos, leadingComments) {
    // If the leading comments start on different line than the start of node, write new line
    if (leadingComments &amp;&amp; leadingComments.length &amp;&amp; pos !== leadingComments[0].pos &amp;&amp;
        getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, leadingComments[0].pos)) {
        writer.writeLine();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.endsWith" id="apidoc.element.typescript.endsWith">
        function <span class="apidocSignatureSpan">typescript.</span>endsWith
        <span class="apidocSignatureSpan">(str, suffix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endsWith(str, suffix) {
    var expectedPos = str.length - suffix.length;
    return expectedPos &gt;= 0 &amp;&amp; str.indexOf(suffix, expectedPos) === expectedPos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.ensureScriptKind" id="apidoc.element.typescript.ensureScriptKind">
        function <span class="apidocSignatureSpan">typescript.</span>ensureScriptKind
        <span class="apidocSignatureSpan">(fileName, scriptKind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureScriptKind(fileName, scriptKind) {
    // Using scriptKind as a condition handles both:
    // - 'scriptKind' is unspecified and thus it is `undefined`
    // - 'scriptKind' is set and it is `Unknown` (0)
    // If the 'scriptKind' is 'undefined' or 'Unknown' then we attempt
    // to get the ScriptKind from the file name. If it cannot be resolved
    // from the file name then the default 'TS' script kind is returned.
    return (scriptKind || getScriptKindFromFileName(fileName)) || 3 /* TS */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.ensureTrailingDirectorySeparator" id="apidoc.element.typescript.ensureTrailingDirectorySeparator">
        function <span class="apidocSignatureSpan">typescript.</span>ensureTrailingDirectorySeparator
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureTrailingDirectorySeparator(path) {
    if (path.charAt(path.length - 1) !== ts.directorySeparator) {
        return path + ts.directorySeparator;
    }
    return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.ensureUseStrict" id="apidoc.element.typescript.ensureUseStrict">
        function <span class="apidocSignatureSpan">typescript.</span>ensureUseStrict
        <span class="apidocSignatureSpan">(statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureUseStrict(statements) {
    var foundUseStrict = false;
    for (var _i = 0, statements_1 = statements; _i &lt; statements_1.length; _i++) {
        var statement = statements_1[_i];
        if (ts.isPrologueDirective(statement)) {
            if (isUseStrictPrologue(statement)) {
                foundUseStrict = true;
                break;
            }
        }
        else {
            break;
        }
    }
    if (!foundUseStrict) {
        return ts.setTextRange(ts.createNodeArray([
            startOnNewLine(ts.createStatement(ts.createLiteral("use strict")))
        ].concat(statements)), statements);
    }
    return statements;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.entityNameToString" id="apidoc.element.typescript.entityNameToString">
        function <span class="apidocSignatureSpan">typescript.</span>entityNameToString
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function entityNameToString(name) {
    switch (name.kind) {
        case 70 /* Identifier */:
            return getFullWidth(name) === 0 ? unescapeIdentifier(name.text) : getTextOfNode(name);
        case 142 /* QualifiedName */:
            return entityNameToString(name.left) + "." + entityNameToString(name.right);
        case 178 /* PropertyAccessExpression */:
            return entityNameToString(name.expression) + "." + entityNameToString(name.name);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.equalOwnProperties" id="apidoc.element.typescript.equalOwnProperties">
        function <span class="apidocSignatureSpan">typescript.</span>equalOwnProperties
        <span class="apidocSignatureSpan">(left, right, equalityComparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equalOwnProperties(left, right, equalityComparer) {
    if (left === right)
        return true;
    if (!left || !right)
        return false;
    for (var key in left)
        if (hasOwnProperty.call(left, key)) {
            if (!hasOwnProperty.call(right, key) === undefined)
                return false;
            if (equalityComparer ? !equalityComparer(left[key], right[key]) : left[key] !== right[key])
                return false;
        }
    for (var key in right)
        if (hasOwnProperty.call(right, key)) {
            if (!hasOwnProperty.call(left, key))
                return false;
        }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.escapeIdentifier" id="apidoc.element.typescript.escapeIdentifier">
        function <span class="apidocSignatureSpan">typescript.</span>escapeIdentifier
        <span class="apidocSignatureSpan">(identifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeIdentifier(identifier) {
    return identifier.length &gt;= 2 &amp;&amp; identifier.charCodeAt(0) === 95 /* _ */ &amp;&amp; identifier.charCodeAt(1) === 95 /* _ */ ? "_" +
identifier : identifier;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.escapeNonAsciiCharacters" id="apidoc.element.typescript.escapeNonAsciiCharacters">
        function <span class="apidocSignatureSpan">typescript.</span>escapeNonAsciiCharacters
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeNonAsciiCharacters(s) {
    // Replace non-ASCII characters with '\uNNNN' escapes if any exist.
    // Otherwise just return the original string.
    return nonAsciiCharacters.test(s) ?
        s.replace(nonAsciiCharacters, function (c) { return get16BitUnicodeEscapeSequence(c.charCodeAt(0)); }) :
        s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.escapeString" id="apidoc.element.typescript.escapeString">
        function <span class="apidocSignatureSpan">typescript.</span>escapeString
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeString(s) {
    return s.replace(escapedCharsRegExp, getReplacement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.every" id="apidoc.element.typescript.every">
        function <span class="apidocSignatureSpan">typescript.</span>every
        <span class="apidocSignatureSpan">(array, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function every(array, callback) {
    if (array) {
        for (var i = 0; i &lt; array.length; i++) {
            if (!callback(array[i], i)) {
                return false;
            }
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.exportAssignmentIsAlias" id="apidoc.element.typescript.exportAssignmentIsAlias">
        function <span class="apidocSignatureSpan">typescript.</span>exportAssignmentIsAlias
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exportAssignmentIsAlias(node) {
    return isEntityNameExpression(node.expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.extend" id="apidoc.element.typescript.extend">
        function <span class="apidocSignatureSpan">typescript.</span>extend
        <span class="apidocSignatureSpan">(first, second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(first, second) {
    var result = {};
    for (var id in second)
        if (hasOwnProperty.call(second, id)) {
            result[id] = second[id];
        }
    for (var id in first)
        if (hasOwnProperty.call(first, id)) {
            result[id] = first[id];
        }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.extensionFromPath" id="apidoc.element.typescript.extensionFromPath">
        function <span class="apidocSignatureSpan">typescript.</span>extensionFromPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extensionFromPath(path) {
    var ext = tryGetExtensionFromPath(path);
    if (ext !== undefined) {
        return ext;
    }
    Debug.fail("File " + path + " has unknown extension.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.extensionIsTypeScript" id="apidoc.element.typescript.extensionIsTypeScript">
        function <span class="apidocSignatureSpan">typescript.</span>extensionIsTypeScript
        <span class="apidocSignatureSpan">(ext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extensionIsTypeScript(ext) {
    return ext &lt;= ts.Extension.LastTypeScriptExtension;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.fileExtensionIs" id="apidoc.element.typescript.fileExtensionIs">
        function <span class="apidocSignatureSpan">typescript.</span>fileExtensionIs
        <span class="apidocSignatureSpan">(path, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fileExtensionIs(path, extension) {
    return path.length &gt; extension.length &amp;&amp; endsWith(path, extension);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.fileExtensionIsAny" id="apidoc.element.typescript.fileExtensionIsAny">
        function <span class="apidocSignatureSpan">typescript.</span>fileExtensionIsAny
        <span class="apidocSignatureSpan">(path, extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fileExtensionIsAny(path, extensions) {
    for (var _i = 0, extensions_1 = extensions; _i &lt; extensions_1.length; _i++) {
        var extension = extensions_1[_i];
        if (fileExtensionIs(path, extension)) {
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.filter" id="apidoc.element.typescript.filter">
        function <span class="apidocSignatureSpan">typescript.</span>filter
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(array, f) {
    if (array) {
        var len = array.length;
        var i = 0;
        while (i &lt; len &amp;&amp; f(array[i]))
            i++;
        if (i &lt; len) {
            var result = array.slice(0, i);
            i++;
            while (i &lt; len) {
                var item = array[i];
                if (f(item)) {
                    result.push(item);
                }
                i++;
            }
            return result;
        }
    }
    return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.filterMutate" id="apidoc.element.typescript.filterMutate">
        function <span class="apidocSignatureSpan">typescript.</span>filterMutate
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterMutate(array, f) {
    var outIndex = 0;
    for (var _i = 0, array_3 = array; _i &lt; array_3.length; _i++) {
        var item = array_3[_i];
        if (f(item)) {
            array[outIndex] = item;
            outIndex++;
        }
    }
    array.length = outIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.find" id="apidoc.element.typescript.find">
        function <span class="apidocSignatureSpan">typescript.</span>find
        <span class="apidocSignatureSpan">(array, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(array, predicate) {
    for (var i = 0; i &lt; array.length; i++) {
        var value = array[i];
        if (predicate(value, i)) {
            return value;
        }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findBestPatternMatch" id="apidoc.element.typescript.findBestPatternMatch">
        function <span class="apidocSignatureSpan">typescript.</span>findBestPatternMatch
        <span class="apidocSignatureSpan">(values, getPattern, candidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findBestPatternMatch(values, getPattern, candidate) {
    var matchedValue = undefined;
    // use length of prefix as betterness criteria
    var longestMatchPrefixLength = -1;
    for (var _i = 0, values_1 = values; _i &lt; values_1.length; _i++) {
        var v = values_1[_i];
        var pattern = getPattern(v);
        if (isPatternMatch(pattern, candidate) &amp;&amp; pattern.prefix.length &gt; longestMatchPrefixLength) {
            longestMatchPrefixLength = pattern.prefix.length;
            matchedValue = v;
        }
    }
    return matchedValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findChildOfKind" id="apidoc.element.typescript.findChildOfKind">
        function <span class="apidocSignatureSpan">typescript.</span>findChildOfKind
        <span class="apidocSignatureSpan">(n, kind, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findChildOfKind(n, kind, sourceFile) {
    return ts.forEach(n.getChildren(sourceFile), function (c) { return c.kind === kind &amp;&amp; c; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findConfigFile" id="apidoc.element.typescript.findConfigFile">
        function <span class="apidocSignatureSpan">typescript.</span>findConfigFile
        <span class="apidocSignatureSpan">(searchPath, fileExists, configName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findConfigFile(searchPath, fileExists, configName) {
    if (configName === void 0) { configName = "tsconfig.json"; }
    while (true) {
        var fileName = ts.combinePaths(searchPath, configName);
        if (fileExists(fileName)) {
            return fileName;
        }
        var parentPath = ts.getDirectoryPath(searchPath);
        if (parentPath === searchPath) {
            break;
        }
        searchPath = parentPath;
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findContainingList" id="apidoc.element.typescript.findContainingList">
        function <span class="apidocSignatureSpan">typescript.</span>findContainingList
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findContainingList(node) {
    // The node might be a list element (nonsynthetic) or a comma (synthetic). Either way, it will
    // be parented by the container of the SyntaxList, not the SyntaxList itself.
    // In order to find the list item index, we first need to locate SyntaxList itself and then search
    // for the position of the relevant node (or comma).
    var syntaxList = ts.forEach(node.parent.getChildren(), function (c) {
        // find syntax list that covers the span of the node
        if (c.kind === 295 /* SyntaxList */ &amp;&amp; c.pos &lt;= node.pos &amp;&amp; c.end &gt;= node.end) {
            return c;
        }
    });
    // Either we didn't find an appropriate list, or the list must contain us.
    ts.Debug.assert(!syntaxList || ts.contains(syntaxList.getChildren(), node));
    return syntaxList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findIndex" id="apidoc.element.typescript.findIndex">
        function <span class="apidocSignatureSpan">typescript.</span>findIndex
        <span class="apidocSignatureSpan">(array, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findIndex(array, predicate) {
    for (var i = 0; i &lt; array.length; i++) {
        if (predicate(array[i], i)) {
            return i;
        }
    }
    return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findListItemInfo" id="apidoc.element.typescript.findListItemInfo">
        function <span class="apidocSignatureSpan">typescript.</span>findListItemInfo
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findListItemInfo(node) {
    var list = findContainingList(node);
    // It is possible at this point for syntaxList to be undefined, either if
    // node.parent had no list child, or if none of its list children contained
    // the span of node. If this happens, return undefined. The caller should
    // handle this case.
    if (!list) {
        return undefined;
    }
    var children = list.getChildren();
    var listItemIndex = ts.indexOf(children, node);
    return {
        listItemIndex: listItemIndex,
        list: list
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findMap" id="apidoc.element.typescript.findMap">
        function <span class="apidocSignatureSpan">typescript.</span>findMap
        <span class="apidocSignatureSpan">(array, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findMap(array, callback) {
    for (var i = 0; i &lt; array.length; i++) {
        var result = callback(array[i], i);
        if (result) {
            return result;
        }
    }
    Debug.fail();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findNextToken" id="apidoc.element.typescript.findNextToken">
        function <span class="apidocSignatureSpan">typescript.</span>findNextToken
        <span class="apidocSignatureSpan">(previousToken, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findNextToken(previousToken, parent) {
    return find(parent);
    function find(n) {
        if (isToken(n) &amp;&amp; n.pos === previousToken.end) {
            // this is token that starts at the end of previous token - return it
            return n;
        }
        var children = n.getChildren();
        for (var _i = 0, children_2 = children; _i &lt; children_2.length; _i++) {
            var child = children_2[_i];
            var shouldDiveInChildNode =
            // previous token is enclosed somewhere in the child
            (child.pos &lt;= previousToken.pos &amp;&amp; child.end &gt; previousToken.end) ||
                // previous token ends exactly at the beginning of child
                (child.pos === previousToken.end);
            if (shouldDiveInChildNode &amp;&amp; nodeHasTokens(child)) {
                return find(child);
            }
        }
        return undefined;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findPrecedingToken" id="apidoc.element.typescript.findPrecedingToken">
        function <span class="apidocSignatureSpan">typescript.</span>findPrecedingToken
        <span class="apidocSignatureSpan">(position, sourceFile, startNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findPrecedingToken(position, sourceFile, startNode) {
    return find(startNode || sourceFile);
    function findRightmostToken(n) {
        if (isToken(n)) {
            return n;
        }
        var children = n.getChildren();
        var candidate = findRightmostChildNodeWithTokens(children, /*exclusiveStartPosition*/ children.length);
        return candidate &amp;&amp; findRightmostToken(candidate);
    }
    function find(n) {
        if (isToken(n)) {
            return n;
        }
        var children = n.getChildren();
        for (var i = 0; i &lt; children.length; i++) {
            var child = children[i];
            // condition 'position &lt; child.end' checks if child node end after the position
            // in the example below this condition will be false for 'aaaa' and 'bbbb' and true for 'ccc'
            // aaaa___bbbb___$__ccc
            // after we found child node with end after the position we check if start of the node is after the position.
            // if yes - then position is in the trivia and we need to look into the previous child to find the token in question
.
            // if no - position is in the node itself so we should recurse in it.
            // NOTE: JsxText is a weird kind of node that can contain only whitespaces (since they are not counted as trivia).
            // if this is the case - then we should assume that token in question is located in previous child.
            if (position &lt; child.end &amp;&amp; (nodeHasTokens(child) || child.kind === 10 /* JsxText */)) {
                var start = child.getStart(sourceFile);
                var lookInPreviousChild = (start &gt;= position) ||
                    (child.kind === 10 /* JsxText */ &amp;&amp; start === child.end); // whitespace only JsxText
                if (lookInPreviousChild) {
                    // actual start of the node is past the position - previous token should be at the end of previous child
                    var candidate = findRightmostChildNodeWithTokens(children, /*exclusiveStartPosition*/ i);
                    return candidate &amp;&amp; findRightmostToken(candidate);
                }
                else {
                    // candidate should be in this node
                    return find(child);
                }
            }
        }
        ts.Debug.assert(startNode !== undefined || n.kind === 263 /* SourceFile */);
        // Here we know that none of child token nodes embrace the position,
        // the only known case is when position is at the end of the file.
        // Try to find the rightmost token in the file without filtering.
        // Namely we are skipping the check: 'position &lt; node.end'
        if (children.length) {
            var candidate = findRightmostChildNodeWithTokens(children, /*exclusiveStartPosition*/ children.length);
            return candidate &amp;&amp; findRightmostToken(candidate);
        }
    }
    /// finds last node that is considered as candidate for search (isCandidate(node) === true) starting from 'exclusiveStartPosition
'
    function findRightmostChildNodeWithTokens(children, exclusiveStartPosition) {
        for (var i = exclusiveStartPosition - 1; i &gt;= 0; i--) {
            if (nodeHasTokens(children[i])) {
                return children[i];
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.findTokenOnLeftOfPosition" id="apidoc.element.typescript.findTokenOnLeftOfPosition">
        function <span class="apidocSignatureSpan">typescript.</span>findTokenOnLeftOfPosition
        <span class="apidocSignatureSpan">(file, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findTokenOnLeftOfPosition(file, position) {
    // Ideally, getTokenAtPosition should return a token. However, it is currently
    // broken, so we do a check to make sure the result was indeed a token.
    var tokenAtPosition = getTokenAtPosition(file, position);
    if (isToken(tokenAtPosition) &amp;&amp; position &gt; tokenAtPosition.getStart(file) &amp;&amp; position &lt; tokenAtPosition.getEnd()) {
        return tokenAtPosition;
    }
    return findPrecedingToken(position, file);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.firstOrUndefined" id="apidoc.element.typescript.firstOrUndefined">
        function <span class="apidocSignatureSpan">typescript.</span>firstOrUndefined
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function firstOrUndefined(array) {
    return array &amp;&amp; array.length &gt; 0
        ? array[0]
        : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.flatMap" id="apidoc.element.typescript.flatMap">
        function <span class="apidocSignatureSpan">typescript.</span>flatMap
        <span class="apidocSignatureSpan">(array, mapfn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flatMap(array, mapfn) {
    var result;
    if (array) {
        result = [];
        for (var i = 0; i &lt; array.length; i++) {
            var v = mapfn(array[i], i);
            if (v) {
                if (isArray(v)) {
                    addRange(result, v);
                }
                else {
                    result.push(v);
                }
            }
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.flatten" id="apidoc.element.typescript.flatten">
        function <span class="apidocSignatureSpan">typescript.</span>flatten
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flatten(array) {
    var result;
    if (array) {
        result = [];
        for (var _i = 0, array_4 = array; _i &lt; array_4.length; _i++) {
            var v = array_4[_i];
            if (v) {
                if (isArray(v)) {
                    addRange(result, v);
                }
                else {
                    result.push(v);
                }
            }
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.flattenDestructuringAssignment" id="apidoc.element.typescript.flattenDestructuringAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>flattenDestructuringAssignment
        <span class="apidocSignatureSpan">(node, visitor, context, level, needsValue, createAssignmentCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenDestructuringAssignment(node, visitor, context, level, needsValue, createAssignmentCallback) {
    var location = node;
    var value;
    if (ts.isDestructuringAssignment(node)) {
        value = node.right;
        while (ts.isEmptyObjectLiteralOrArrayLiteral(node.left)) {
            if (ts.isDestructuringAssignment(value)) {
                location = node = value;
                value = node.right;
            }
            else {
                return value;
            }
        }
    }
    var expressions;
    var flattenContext = {
        context: context,
        level: level,
        hoistTempVariables: true,
        emitExpression: emitExpression,
        emitBindingOrAssignment: emitBindingOrAssignment,
        createArrayBindingOrAssignmentPattern: makeArrayAssignmentPattern,
        createObjectBindingOrAssignmentPattern: makeObjectAssignmentPattern,
        createArrayBindingOrAssignmentElement: makeAssignmentElement,
        visitor: visitor
    };
    if (value) {
        value = ts.visitNode(value, visitor, ts.isExpression);
        if (needsValue) {
            // If the right-hand value of the destructuring assignment needs to be preserved (as
            // is the case when the destructuring assignment is part of a larger expression),
            // then we need to cache the right-hand value.
            //
            // The source map location for the assignment should point to the entire binary
            // expression.
            value = ensureIdentifier(flattenContext, value, /*reuseIdentifierExpressions*/ true, location);
        }
        else if (ts.nodeIsSynthesized(node)) {
            // Generally, the source map location for a destructuring assignment is the root
            // expression.
            //
            // However, if the root expression is synthesized (as in the case
            // of the initializer when transforming a ForOfStatement), then the source map
            // location should point to the right-hand value of the expression.
            location = value;
        }
    }
    flattenBindingOrAssignmentElement(flattenContext, node, value, location, /*skipInitializer*/ ts.isDestructuringAssignment(node
));
    if (value &amp;&amp; needsValue) {
        if (!ts.some(expressions)) {
            return value;
        }
        expressions.push(value);
    }
    return ts.aggregateTransformFlags(ts.inlineExpressions(expressions)) || ts.createOmittedExpression();
    function emitExpression(expression) {
        // NOTE: this completely disables source maps, but aligns with the behavior of
        //       `emitAssignment` in the old emitter.
        ts.setEmitFlags(expression, 64 /* NoNestedSourceMaps */);
        ts.aggregateTransformFlags(expression);
        expressions = ts.append(expressions, expression);
    }
    function emitBindingOrAssignment(target, value, location, original) {
        ts.Debug.assertNode(target, createAssignmentCallback ? ts.isIdentifier : ts.isExpression);
        var expression = createAssignmentCallback
            ? createAssignmentCallback(target, value, location)
            : ts.setTextRange(ts.createAssignment(ts.visitNode(target, visitor, ts.isExpression), value), location);
        expression.original = original;
        emitExpression(expression);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.flattenDestructuringBinding" id="apidoc.element.typescript.flattenDestructuringBinding">
        function <span class="apidocSignatureSpan">typescript.</span>flattenDestructuringBinding
        <span class="apidocSignatureSpan">(node, visitor, context, level, rval, hoistTempVariables, skipInitializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenDestructuringBinding(node, visitor, context, level, rval, hoistTempVariables, skipInitializer) {
    var pendingExpressions;
    var pendingDeclarations = [];
    var declarations = [];
    var flattenContext = {
        context: context,
        level: level,
        hoistTempVariables: hoistTempVariables,
        emitExpression: emitExpression,
        emitBindingOrAssignment: emitBindingOrAssignment,
        createArrayBindingOrAssignmentPattern: makeArrayBindingPattern,
        createObjectBindingOrAssignmentPattern: makeObjectBindingPattern,
        createArrayBindingOrAssignmentElement: makeBindingElement,
        visitor: visitor
    };
    flattenBindingOrAssignmentElement(flattenContext, node, rval, node, skipInitializer);
    if (pendingExpressions) {
        var temp = ts.createTempVariable(/*recordTempVariable*/ undefined);
        if (hoistTempVariables) {
            var value = ts.inlineExpressions(pendingExpressions);
            pendingExpressions = undefined;
            emitBindingOrAssignment(temp, value, /*location*/ undefined, /*original*/ undefined);
        }
        else {
            context.hoistVariableDeclaration(temp);
            var pendingDeclaration = ts.lastOrUndefined(pendingDeclarations);
            pendingDeclaration.pendingExpressions = ts.append(pendingDeclaration.pendingExpressions, ts.createAssignment(temp, pendingDeclaration
.value));
            ts.addRange(pendingDeclaration.pendingExpressions, pendingExpressions);
            pendingDeclaration.value = temp;
        }
    }
    for (var _i = 0, pendingDeclarations_1 = pendingDeclarations; _i &lt; pendingDeclarations_1.length; _i++) {
        var _a = pendingDeclarations_1[_i], pendingExpressions_1 = _a.pendingExpressions, name = _a.name, value = _a.value, location
 = _a.location, original = _a.original;
        var variable = ts.createVariableDeclaration(name,
        /*type*/ undefined, pendingExpressions_1 ? ts.inlineExpressions(ts.append(pendingExpressions_1, value)) : value);
        variable.original = original;
        ts.setTextRange(variable, location);
        if (ts.isIdentifier(name)) {
            ts.setEmitFlags(variable, 64 /* NoNestedSourceMaps */);
        }
        ts.aggregateTransformFlags(variable);
        declarations.push(variable);
    }
    return declarations;
    function emitExpression(value) {
        pendingExpressions = ts.append(pendingExpressions, value);
    }
    function emitBindingOrAssignment(target, value, location, original) {
        ts.Debug.assertNode(target, ts.isBindingName);
        if (pendingExpressions) {
            value = ts.inlineExpressions(ts.append(pendingExpressions, value));
            pendingExpressions = undefined;
        }
        pendingDeclarations.push({ pendingExpressions: pendingExpressions, name: target, value: value, location: location, original
: original });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.flattenDiagnosticMessageText" id="apidoc.element.typescript.flattenDiagnosticMessageText">
        function <span class="apidocSignatureSpan">typescript.</span>flattenDiagnosticMessageText
        <span class="apidocSignatureSpan">(messageText, newLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenDiagnosticMessageText(messageText, newLine) {
    if (typeof messageText === "string") {
        return messageText;
    }
    else {
        var diagnosticChain = messageText;
        var result = "";
        var indent = 0;
        while (diagnosticChain) {
            if (indent) {
                result += newLine;
                for (var i = 0; i &lt; indent; i++) {
                    result += "  ";
                }
            }
            result += diagnosticChain.messageText;
            indent++;
            diagnosticChain = diagnosticChain.next;
        }
        return result;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.forEach" id="apidoc.element.typescript.forEach">
        function <span class="apidocSignatureSpan">typescript.</span>forEach
        <span class="apidocSignatureSpan">(array, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEach(array, callback) {
    if (array) {
        for (var i = 0; i &lt; array.length; i++) {
            var result = callback(array[i], i);
            if (result) {
                return result;
            }
        }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.forEachChild" id="apidoc.element.typescript.forEachChild">
        function <span class="apidocSignatureSpan">typescript.</span>forEachChild
        <span class="apidocSignatureSpan">(node, cbNode, cbNodeArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachChild(node, cbNode, cbNodeArray) {
    if (!node) {
        return;
    }
    // The visitXXX functions could be written as local functions that close over the cbNode and cbNodeArray
    // callback parameters, but that causes a closure allocation for each invocation with noticeable effects
    // on performance.
    var visitNodes = cbNodeArray ? visitNodeArray : visitEachNode;
    var cbNodes = cbNodeArray || cbNode;
    switch (node.kind) {
        case 142 /* QualifiedName */:
            return visitNode(cbNode, node.left) ||
                visitNode(cbNode, node.right);
        case 144 /* TypeParameter */:
            return visitNode(cbNode, node.name) ||
                visitNode(cbNode, node.constraint) ||
                visitNode(cbNode, node.expression);
        case 260 /* ShorthandPropertyAssignment */:
            return visitNodes(cbNodes, node.decorators) ||
                visitNodes(cbNodes, node.modifiers) ||
                visitNode(cbNode, node.name) ||
                visitNode(cbNode, node.questionToken) ||
                visitNode(cbNode, node.equalsToken) ||
                visitNode(cbNode, node.objectAssignmentInitializer);
        case 261 /* SpreadAssignment */:
            return visitNode(cbNode, node.expression);
        case 145 /* Parameter */:
        case 148 /* PropertyDeclaration */:
        case 147 /* PropertySignature */:
        case 259 /* PropertyAssignment */:
        case 225 /* VariableDeclaration */:
        case 175 /* BindingElement */:
            return visitNodes(cbNodes, node.decorators) ||
                visitNodes(cbNodes, node.modifiers) ||
                visitNode(cbNode, node.propertyName) ||
                visitNode(cbNode, node.dotDotDotToken) ||
                visitNode(cbNode, node.name) ||
                visitNode(cbNode, node.questionToken) ||
                visitNode(cbNode, node.type) ||
                visitNode(cbNode, node.initializer);
        case 159 /* FunctionType */:
        case 160 /* ConstructorType */:
        case 154 /* CallSignature */:
        case 155 /* ConstructSignature */:
        case 156 /* IndexSignature */:
            return visitNodes(cbNodes, node.decorators) ||
                visitNodes(cbNodes, node.modifiers) ||
                visitNodes(cbNodes, node.typeParameters) ||
                visitNodes(cbNodes, node.parameters) ||
                visitNode(cbNode, node.type);
        case 150 /* MethodDeclaration */:
        case 149 /* MethodSignature */:
        case 151 /* Constructor */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        case 185 /* FunctionExpression */:
        case 227 /* FunctionDeclaration */:
        case 186 /* ArrowFunction */:
            return visitNodes(cbNodes, node.decorators) ||
                visitNodes(cbNodes, node.modifiers) ||
                visitNode(cbNode, node.asteriskToken) ||
                visitNode(cbNode, node.name) ||
                visitNode(cbNode, node.questionToken) ||
                visitNodes(cbNodes, node.typeParameters) ||
                visitNodes(cbNodes, node.parameters) ||
                visitNode(cbNode, node.type) ||
                visitNode(cbNode, node.equalsGreaterThanToken) ||
                visitNode(cbNode, node.body);
        case 158 /* TypeReference */:
            return visitNode(cbNode, node.typeName) ||
                visitNodes(cbNodes, node.typeArguments);
        case 157 /* TypePredicate */:
            return visitNode(cbNode, node.parameterName) ||
                visitNode(cbNode, node.type);
        case 161 /* TypeQuery */:
            return visitNode(cbNode, node.exprName);
        case 162 /* TypeLiteral */:
            return visitNodes(cbNodes, node.members);
        case 163 /* ArrayType */:
            return visitNode(cbNode, node.elementType);
        case 164 /* TupleType */:
            return visitNodes(cbNodes, node.elementTypes);
        case 165 /* UnionType */:
        case 166 /* IntersectionType */:
            return visitNodes(cbNodes, node.types);
        c ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.forEachEmittedFile" id="apidoc.element.typescript.forEachEmittedFile">
        function <span class="apidocSignatureSpan">typescript.</span>forEachEmittedFile
        <span class="apidocSignatureSpan">(host, action, sourceFilesOrTargetSourceFile, emitOnlyDtsFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachEmittedFile(host, action, sourceFilesOrTargetSourceFile, emitOnlyDtsFiles) {
    var sourceFiles = ts.isArray(sourceFilesOrTargetSourceFile) ? sourceFilesOrTargetSourceFile : getSourceFilesToEmit(host, sourceFilesOrTargetSourceFile
);
    var options = host.getCompilerOptions();
    if (options.outFile || options.out) {
        if (sourceFiles.length) {
            var jsFilePath = options.outFile || options.out;
            var sourceMapFilePath = getSourceMapFilePath(jsFilePath, options);
            var declarationFilePath = options.declaration ? ts.removeFileExtension(jsFilePath) + ".d.ts" : undefined;
            action({ jsFilePath: jsFilePath, sourceMapFilePath: sourceMapFilePath, declarationFilePath: declarationFilePath }, ts
.createBundle(sourceFiles), emitOnlyDtsFiles);
        }
    }
    else {
        for (var _i = 0, sourceFiles_1 = sourceFiles; _i &lt; sourceFiles_1.length; _i++) {
            var sourceFile = sourceFiles_1[_i];
            var jsFilePath = getOwnEmitOutputFilePath(sourceFile, host, getOutputExtension(sourceFile, options));
            var sourceMapFilePath = getSourceMapFilePath(jsFilePath, options);
            var declarationFilePath = !isSourceFileJavaScript(sourceFile) &amp;&amp; (emitOnlyDtsFiles || options.declaration) ? getDeclarationEmitOutputFilePath
(sourceFile, host) : undefined;
            action({ jsFilePath: jsFilePath, sourceMapFilePath: sourceMapFilePath, declarationFilePath: declarationFilePath }, sourceFile
, emitOnlyDtsFiles);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.forEachEntry" id="apidoc.element.typescript.forEachEntry">
        function <span class="apidocSignatureSpan">typescript.</span>forEachEntry
        <span class="apidocSignatureSpan">(map, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachEntry(map, callback) {
    var iterator = map.entries();
    for (var _a = iterator.next(), pair = _a.value, done = _a.done; !done; _b = iterator.next(), pair = _b.value, done = _b.done
, _b) {
        var key = pair[0], value = pair[1];
        var result = callback(value, key);
        if (result) {
            return result;
        }
    }
    return undefined;
    var _b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.forEachKey" id="apidoc.element.typescript.forEachKey">
        function <span class="apidocSignatureSpan">typescript.</span>forEachKey
        <span class="apidocSignatureSpan">(map, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachKey(map, callback) {
    var iterator = map.keys();
    for (var _a = iterator.next(), key = _a.value, done = _a.done; !done; _b = iterator.next(), key = _b.value, done = _b.done,
_b) {
        var result = callback(key);
        if (result) {
            return result;
        }
    }
    return undefined;
    var _b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.forEachLeadingCommentRange" id="apidoc.element.typescript.forEachLeadingCommentRange">
        function <span class="apidocSignatureSpan">typescript.</span>forEachLeadingCommentRange
        <span class="apidocSignatureSpan">(text, pos, cb, state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachLeadingCommentRange(text, pos, cb, state) {
    return iterateCommentRanges(/*reduce*/ false, text, pos, /*trailing*/ false, cb, state);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.forEachReturnStatement" id="apidoc.element.typescript.forEachReturnStatement">
        function <span class="apidocSignatureSpan">typescript.</span>forEachReturnStatement
        <span class="apidocSignatureSpan">(body, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachReturnStatement(body, visitor) {
    return traverse(body);
    function traverse(node) {
        switch (node.kind) {
            case 218 /* ReturnStatement */:
                return visitor(node);
            case 234 /* CaseBlock */:
            case 206 /* Block */:
            case 210 /* IfStatement */:
            case 211 /* DoStatement */:
            case 212 /* WhileStatement */:
            case 213 /* ForStatement */:
            case 214 /* ForInStatement */:
            case 215 /* ForOfStatement */:
            case 219 /* WithStatement */:
            case 220 /* SwitchStatement */:
            case 255 /* CaseClause */:
            case 256 /* DefaultClause */:
            case 221 /* LabeledStatement */:
            case 223 /* TryStatement */:
            case 258 /* CatchClause */:
                return ts.forEachChild(node, traverse);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.forEachTrailingCommentRange" id="apidoc.element.typescript.forEachTrailingCommentRange">
        function <span class="apidocSignatureSpan">typescript.</span>forEachTrailingCommentRange
        <span class="apidocSignatureSpan">(text, pos, cb, state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachTrailingCommentRange(text, pos, cb, state) {
    return iterateCommentRanges(/*reduce*/ false, text, pos, /*trailing*/ true, cb, state);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.forEachYieldExpression" id="apidoc.element.typescript.forEachYieldExpression">
        function <span class="apidocSignatureSpan">typescript.</span>forEachYieldExpression
        <span class="apidocSignatureSpan">(body, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachYieldExpression(body, visitor) {
    return traverse(body);
    function traverse(node) {
        switch (node.kind) {
            case 196 /* YieldExpression */:
                visitor(node);
                var operand = node.expression;
                if (operand) {
                    traverse(operand);
                }
            case 231 /* EnumDeclaration */:
            case 229 /* InterfaceDeclaration */:
            case 232 /* ModuleDeclaration */:
            case 230 /* TypeAliasDeclaration */:
            case 228 /* ClassDeclaration */:
            case 198 /* ClassExpression */:
                // These are not allowed inside a generator now, but eventually they may be allowed
                // as local types. Regardless, any yield statements contained within them should be
                // skipped in this traversal.
                return;
            default:
                if (isFunctionLike(node)) {
                    var name = node.name;
                    if (name &amp;&amp; name.kind === 143 /* ComputedPropertyName */) {
                        // Note that we will not include methods/accessors of a class because they would require
                        // first descending into the class. This is by design.
                        traverse(name.expression);
                        return;
                    }
                }
                else if (!isPartOfTypeNode(node)) {
                    // This is the general case, which should include mostly expressions and statements.
                    // Also includes NodeArrays.
                    ts.forEachChild(node, traverse);
                }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatDiagnostics" id="apidoc.element.typescript.formatDiagnostics">
        function <span class="apidocSignatureSpan">typescript.</span>formatDiagnostics
        <span class="apidocSignatureSpan">(diagnostics, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatDiagnostics(diagnostics, host) {
    var output = "";
    for (var _i = 0, diagnostics_1 = diagnostics; _i &lt; diagnostics_1.length; _i++) {
        var diagnostic = diagnostics_1[_i];
        if (diagnostic.file) {
            var _a = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start), line = _a.line, character = _a.character
;
            var fileName = diagnostic.file.fileName;
            var relativeFileName = ts.convertToRelativePath(fileName, host.getCurrentDirectory(), function (fileName) { return host
.getCanonicalFileName(fileName); });
            output += relativeFileName + "(" + (line + 1) + "," + (character + 1) + "): ";
        }
        var category = ts.DiagnosticCategory[diagnostic.category].toLowerCase();
        output += category + " TS" + diagnostic.code + ": " + flattenDiagnosticMessageText(diagnostic.messageText, host.getNewLine
()) + host.getNewLine();
    }
    return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatMessage" id="apidoc.element.typescript.formatMessage">
        function <span class="apidocSignatureSpan">typescript.</span>formatMessage
        <span class="apidocSignatureSpan">(_dummy, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatMessage(_dummy, message) {
    var text = getLocaleSpecificMessage(message);
    if (arguments.length &gt; 2) {
        text = formatStringFromArgs(text, arguments, 2);
    }
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatStringFromArgs" id="apidoc.element.typescript.formatStringFromArgs">
        function <span class="apidocSignatureSpan">typescript.</span>formatStringFromArgs
        <span class="apidocSignatureSpan">(text, args, baseIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatStringFromArgs(text, args, baseIndex) {
    baseIndex = baseIndex || 0;
    return text.replace(/{(\d+)}/g, function (_match, index) { return args[+index + baseIndex]; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatSyntaxKind" id="apidoc.element.typescript.formatSyntaxKind">
        function <span class="apidocSignatureSpan">typescript.</span>formatSyntaxKind
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatSyntaxKind(kind) {
    var syntaxKindEnum = ts.SyntaxKind;
    if (syntaxKindEnum) {
        var cached = syntaxKindCache[kind];
        if (cached !== undefined) {
            return cached;
        }
        for (var name in syntaxKindEnum) {
            if (syntaxKindEnum[name] === kind) {
                var result = kind + " (" + name + ")";
                syntaxKindCache[kind] = result;
                return result;
            }
        }
    }
    else {
        return kind.toString();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext" id="apidoc.element.typescript.formatting.FormattingContext">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.FormattingContext
        <span class="apidocSignatureSpan">(sourceFile, formattingRequestKind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FormattingContext(sourceFile, formattingRequestKind) {
    this.sourceFile = sourceFile;
    this.formattingRequestKind = formattingRequestKind;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rule" id="apidoc.element.typescript.formatting.Rule">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.Rule
        <span class="apidocSignatureSpan">(Descriptor, Operation, Flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Rule(Descriptor, Operation, Flag) {
    if (Flag === void 0) { Flag = 0 /* None */; }
    this.Descriptor = Descriptor;
    this.Operation = Operation;
    this.Flag = Flag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleDescriptor" id="apidoc.element.typescript.formatting.RuleDescriptor">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.RuleDescriptor
        <span class="apidocSignatureSpan">(LeftTokenRange, RightTokenRange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleDescriptor(LeftTokenRange, RightTokenRange) {
    this.LeftTokenRange = LeftTokenRange;
    this.RightTokenRange = RightTokenRange;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperation" id="apidoc.element.typescript.formatting.RuleOperation">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.RuleOperation
        <span class="apidocSignatureSpan">(Context, Action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleOperation(Context, Action) {
    this.Context = Context;
    this.Action = Action;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperationContext" id="apidoc.element.typescript.formatting.RuleOperationContext">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.RuleOperationContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleOperationContext() {
    var funcs = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        funcs[_i] = arguments[_i];
    }
    this.customContextChecks = funcs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules" id="apidoc.element.typescript.formatting.Rules">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.Rules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Rules() {
    ///
    /// Common Rules
    ///
    // Leave comments alone
    this.IgnoreBeforeComment = new formatting.Rule(formatting.RuleDescriptor.create4(formatting.Shared.TokenRange.Any, formatting
.Shared.TokenRange.Comments), formatting.RuleOperation.create1(1 /* Ignore */));
    this.IgnoreAfterLineComment = new formatting.Rule(formatting.RuleDescriptor.create3(2 /* SingleLineCommentTrivia */, formatting
.Shared.TokenRange.Any), formatting.RuleOperation.create1(1 /* Ignore */));
    // Space after keyword but not before ; or : or ?
    this.NoSpaceBeforeSemicolon = new formatting.Rule(formatting.RuleDescriptor.create2(formatting.Shared.TokenRange.Any, 24 /*
SemicolonToken */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 8 /*
Delete */));
    this.NoSpaceBeforeColon = new formatting.Rule(formatting.RuleDescriptor.create2(formatting.Shared.TokenRange.Any, 55 /* ColonToken
 */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules.IsNotBinaryOpContext
), 8 /* Delete */));
    this.NoSpaceBeforeQuestionMark = new formatting.Rule(formatting.RuleDescriptor.create2(formatting.Shared.TokenRange.Any, 54 /*
QuestionToken */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules
.IsNotBinaryOpContext), 8 /* Delete */));
    this.SpaceAfterColon = new formatting.Rule(formatting.RuleDescriptor.create3(55 /* ColonToken */, formatting.Shared.TokenRange
.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules.IsNotBinaryOpContext
), 2 /* Space */));
    this.SpaceAfterQuestionMarkInConditionalOperator = new formatting.Rule(formatting.RuleDescriptor.create3(54 /* QuestionToken
 */, formatting.Shared.TokenRange.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext
, Rules.IsConditionalOperatorContext), 2 /* Space */));
    this.NoSpaceAfterQuestionMark = new formatting.Rule(formatting.RuleDescriptor.create3(54 /* QuestionToken */, formatting.Shared
.TokenRange.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 8 /*
Delete */));
    this.SpaceAfterSemicolon = new formatting.Rule(formatting.RuleDescriptor.create3(24 /* SemicolonToken */, formatting.Shared.
TokenRange.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 2 /*
Space */));
    // Space after }.
    this.SpaceAfterCloseBrace = new formatting.Rule(formatting.RuleDescriptor.create3(17 /* CloseBraceToken */, formatting.Shared
.TokenRange.FromRange(0 /* FirstToken */, 141 /* LastToken */, [19 /* CloseParenToken */])), formatting.RuleOperation.create2(new
 formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules.IsAfterCodeBlockContext), 2 /* Space */));
    // Special case for (}, else) and (}, while) since else &amp; while tokens are not part of the tree which makes SpaceAfterCloseBrace
 rule not applied
    this.SpaceBetweenCloseBraceAndElse = new formatting.Rule(formatting.RuleDescriptor.create1(17 /* CloseBraceToken */, 81 /* ElseKeyword
 */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 2 /* Space */));
    this.SpaceBetweenCloseBraceAndWhile = new formatting.Rule(formatting.RuleDescriptor.create1(17 /* CloseBraceToken */, 105 /*
WhileKeyword */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 2 /*
Space */));
    this.NoSpaceAfterCloseBrace = new formatting.Rule(formatting.RuleDescriptor.create3(17 /* CloseBraceToken */, formatting.Shared
.TokenRange.FromTokens([21 /* CloseBracketToken */, 25 /* CommaToken */, 24 /* SemicolonToken */])), formatting.RuleOperation.create2
(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 8 /* Delete */));
    // No space for dot
    this.NoSpaceBeforeDot = ne ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucket" id="apidoc.element.typescript.formatting.RulesBucket">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.RulesBucket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesBucket() {
    this.rules = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucketConstructionState" id="apidoc.element.typescript.formatting.RulesBucketConstructionState">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.RulesBucketConstructionState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesBucketConstructionState() {
    //// The Rules list contains all the inserted rules into a rulebucket in the following order:
    ////    1- Ignore rules with specific token combination
    ////    2- Ignore rules with any token combination
    ////    3- Context rules with specific token combination
    ////    4- Context rules with any token combination
    ////    5- Non-context rules with specific token combination
    ////    6- Non-context rules with any token combination
    ////
    //// The member rulesInsertionIndexBitmap is used to describe the number of rules
    //// in each sub-bucket (above) hence can be used to know the index of where to insert
    //// the next rule. It's a bitmap which contains 6 different sections each is given 5 bits.
    ////
    //// Example:
    //// In order to insert a rule to the end of sub-bucket (3), we get the index by adding
    //// the values in the bitmap segments 3rd, 2nd, and 1st.
    this.rulesInsertionIndexBitmap = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesMap" id="apidoc.element.typescript.formatting.RulesMap">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.RulesMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesMap() {
    this.map = [];
    this.mapRowLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesProvider" id="apidoc.element.typescript.formatting.RulesProvider">
        function <span class="apidocSignatureSpan">typescript.</span>formatting.RulesProvider
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesProvider() {
    this.globalRules = new formatting.Rules();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.generateTSConfig" id="apidoc.element.typescript.generateTSConfig">
        function <span class="apidocSignatureSpan">typescript.</span>generateTSConfig
        <span class="apidocSignatureSpan">(options, fileNames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateTSConfig(options, fileNames) {
    var compilerOptions = ts.extend(options, ts.defaultInitCompilerOptions);
    var configurations = {
        compilerOptions: serializeCompilerOptions(compilerOptions)
    };
    if (fileNames &amp;&amp; fileNames.length) {
        // only set the files property if we have at least one file
        configurations.files = fileNames;
    }
    return configurations;
    function getCustomTypeMapOfCommandLineOption(optionDefinition) {
        if (optionDefinition.type === "string" || optionDefinition.type === "number" || optionDefinition.type === "boolean") {
            // this is of a type CommandLineOptionOfPrimitiveType
            return undefined;
        }
        else if (optionDefinition.type === "list") {
            return getCustomTypeMapOfCommandLineOption(optionDefinition.element);
        }
        else {
            return optionDefinition.type;
        }
    }
    function getNameOfCompilerOptionValue(value, customTypeMap) {
        // There is a typeMap associated with this command-line option so use it to map value back to its name
        return ts.forEachEntry(customTypeMap, function (mapValue, key) {
            if (mapValue === value) {
                return key;
            }
        });
    }
    function serializeCompilerOptions(options) {
        var result = {};
        var optionsNameMap = getOptionNameMap().optionNameMap;
        for (var name in options) {
            if (ts.hasProperty(options, name)) {
                // tsconfig only options cannot be specified via command line,
                // so we can assume that only types that can appear here string | number | boolean
                switch (name) {
                    case "init":
                    case "watch":
                    case "version":
                    case "help":
                    case "project":
                        break;
                    default:
                        var value = options[name];
                        var optionDefinition = optionsNameMap.get(name.toLowerCase());
                        if (optionDefinition) {
                            var customTypeMap = getCustomTypeMapOfCommandLineOption(optionDefinition);
                            if (!customTypeMap) {
                                // There is no map associated with this compiler option then use the value as-is
                                // This is the case if the value is expect to be string, number, boolean or list of string
                                result[name] = value;
                            }
                            else {
                                if (optionDefinition.type === "list") {
                                    var convertedValue = [];
                                    for (var _i = 0, _a = value; _i &lt; _a.length; _i++) {
                                        var element = _a[_i];
                                        convertedValue.push(getNameOfCompilerOptionValue(element, customTypeMap));
                                    }
                                    result[name] = convertedValue;
                                }
                                else {
                                    // There is a typeMap associated with this command-line option so use it to map value back to
 its name
                                    result[name] = getNameOfCompilerOptionValue(value, customTypeMap);
                                }
                            }
                        }
                        break;
                }
            }
        }
        return result;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getAllAccessorDeclarations" id="apidoc.element.typescript.getAllAccessorDeclarations">
        function <span class="apidocSignatureSpan">typescript.</span>getAllAccessorDeclarations
        <span class="apidocSignatureSpan">(declarations, accessor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAllAccessorDeclarations(declarations, accessor) {
    var firstAccessor;
    var secondAccessor;
    var getAccessor;
    var setAccessor;
    if (hasDynamicName(accessor)) {
        firstAccessor = accessor;
        if (accessor.kind === 152 /* GetAccessor */) {
            getAccessor = accessor;
        }
        else if (accessor.kind === 153 /* SetAccessor */) {
            setAccessor = accessor;
        }
        else {
            ts.Debug.fail("Accessor has wrong kind");
        }
    }
    else {
        ts.forEach(declarations, function (member) {
            if ((member.kind === 152 /* GetAccessor */ || member.kind === 153 /* SetAccessor */)
                &amp;&amp; hasModifier(member, 32 /* Static */) === hasModifier(accessor, 32 /* Static */)) {
                var memberName = getPropertyNameForPropertyNameNode(member.name);
                var accessorName = getPropertyNameForPropertyNameNode(accessor.name);
                if (memberName === accessorName) {
                    if (!firstAccessor) {
                        firstAccessor = member;
                    }
                    else if (!secondAccessor) {
                        secondAccessor = member;
                    }
                    if (member.kind === 152 /* GetAccessor */ &amp;&amp; !getAccessor) {
                        getAccessor = member;
                    }
                    if (member.kind === 153 /* SetAccessor */ &amp;&amp; !setAccessor) {
                        setAccessor = member;
                    }
                }
            }
        });
    }
    return {
        firstAccessor: firstAccessor,
        secondAccessor: secondAccessor,
        getAccessor: getAccessor,
        setAccessor: setAccessor
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getAncestor" id="apidoc.element.typescript.getAncestor">
        function <span class="apidocSignatureSpan">typescript.</span>getAncestor
        <span class="apidocSignatureSpan">(node, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAncestor(node, kind) {
    while (node) {
        if (node.kind === kind) {
            return node;
        }
        node = node.parent;
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getAssignmentTargetKind" id="apidoc.element.typescript.getAssignmentTargetKind">
        function <span class="apidocSignatureSpan">typescript.</span>getAssignmentTargetKind
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAssignmentTargetKind(node) {
    var parent = node.parent;
    while (true) {
        switch (parent.kind) {
            case 193 /* BinaryExpression */:
                var binaryOperator = parent.operatorToken.kind;
                return isAssignmentOperator(binaryOperator) &amp;&amp; parent.left === node ?
                    binaryOperator === 57 /* EqualsToken */ ? 1 /* Definite */ : 2 /* Compound */ :
                    0 /* None */;
            case 191 /* PrefixUnaryExpression */:
            case 192 /* PostfixUnaryExpression */:
                var unaryOperator = parent.operator;
                return unaryOperator === 42 /* PlusPlusToken */ || unaryOperator === 43 /* MinusMinusToken */ ? 2 /* Compound */ :
0 /* None */;
            case 214 /* ForInStatement */:
            case 215 /* ForOfStatement */:
                return parent.initializer === node ? 1 /* Definite */ : 0 /* None */;
            case 184 /* ParenthesizedExpression */:
            case 176 /* ArrayLiteralExpression */:
            case 197 /* SpreadElement */:
                node = parent;
                break;
            case 260 /* ShorthandPropertyAssignment */:
                if (parent.name !== node) {
                    return 0 /* None */;
                }
                node = parent.parent;
                break;
            case 259 /* PropertyAssignment */:
                if (parent.name === node) {
                    return 0 /* None */;
                }
                node = parent.parent;
                break;
            default:
                return 0 /* None */;
        }
        parent = node.parent;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getAutomaticTypeDirectiveNames" id="apidoc.element.typescript.getAutomaticTypeDirectiveNames">
        function <span class="apidocSignatureSpan">typescript.</span>getAutomaticTypeDirectiveNames
        <span class="apidocSignatureSpan">(options, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAutomaticTypeDirectiveNames(options, host) {
    // Use explicit type list from tsconfig.json
    if (options.types) {
        return options.types;
    }
    // Walk the primary type lookup locations
    var result = [];
    if (host.directoryExists &amp;&amp; host.getDirectories) {
        var typeRoots = getEffectiveTypeRoots(options, host);
        if (typeRoots) {
            for (var _i = 0, typeRoots_1 = typeRoots; _i &lt; typeRoots_1.length; _i++) {
                var root = typeRoots_1[_i];
                if (host.directoryExists(root)) {
                    for (var _a = 0, _b = host.getDirectories(root); _a &lt; _b.length; _a++) {
                        var typeDirectivePath = _b[_a];
                        var normalized = ts.normalizePath(typeDirectivePath);
                        var packageJsonPath = pathToPackageJson(ts.combinePaths(root, normalized));
                        // tslint:disable-next-line:no-null-keyword
                        var isNotNeededPackage = host.fileExists(packageJsonPath) &amp;&amp; readJson(packageJsonPath, host).typings ===
null;
                        if (!isNotNeededPackage) {
                            // Return just the type directive names
                            result.push(ts.getBaseFileName(normalized));
                        }
                    }
                }
            }
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getBaseFileName" id="apidoc.element.typescript.getBaseFileName">
        function <span class="apidocSignatureSpan">typescript.</span>getBaseFileName
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getBaseFileName(path) {
    if (path === undefined) {
        return undefined;
    }
    var i = path.lastIndexOf(ts.directorySeparator);
    return i &lt; 0 ? path : path.substring(i + 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getClassExtendsHeritageClauseElement" id="apidoc.element.typescript.getClassExtendsHeritageClauseElement">
        function <span class="apidocSignatureSpan">typescript.</span>getClassExtendsHeritageClauseElement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getClassExtendsHeritageClauseElement(node) {
    var heritageClause = getHeritageClause(node.heritageClauses, 84 /* ExtendsKeyword */);
    return heritageClause &amp;&amp; heritageClause.types.length &gt; 0 ? heritageClause.types[0] : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getClassImplementsHeritageClauseElements" id="apidoc.element.typescript.getClassImplementsHeritageClauseElements">
        function <span class="apidocSignatureSpan">typescript.</span>getClassImplementsHeritageClauseElements
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getClassImplementsHeritageClauseElements(node) {
    var heritageClause = getHeritageClause(node.heritageClauses, 107 /* ImplementsKeyword */);
    return heritageClause ? heritageClause.types : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getCombinedModifierFlags" id="apidoc.element.typescript.getCombinedModifierFlags">
        function <span class="apidocSignatureSpan">typescript.</span>getCombinedModifierFlags
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCombinedModifierFlags(node) {
    node = walkUpBindingElementsAndPatterns(node);
    var flags = ts.getModifierFlags(node);
    if (node.kind === 225 /* VariableDeclaration */) {
        node = node.parent;
    }
    if (node &amp;&amp; node.kind === 226 /* VariableDeclarationList */) {
        flags |= ts.getModifierFlags(node);
        node = node.parent;
    }
    if (node &amp;&amp; node.kind === 207 /* VariableStatement */) {
        flags |= ts.getModifierFlags(node);
    }
    return flags;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getCombinedNodeFlags" id="apidoc.element.typescript.getCombinedNodeFlags">
        function <span class="apidocSignatureSpan">typescript.</span>getCombinedNodeFlags
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCombinedNodeFlags(node) {
    node = walkUpBindingElementsAndPatterns(node);
    var flags = node.flags;
    if (node.kind === 225 /* VariableDeclaration */) {
        node = node.parent;
    }
    if (node &amp;&amp; node.kind === 226 /* VariableDeclarationList */) {
        flags |= node.flags;
        node = node.parent;
    }
    if (node &amp;&amp; node.kind === 207 /* VariableStatement */) {
        flags |= node.flags;
    }
    return flags;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getCommentRange" id="apidoc.element.typescript.getCommentRange">
        function <span class="apidocSignatureSpan">typescript.</span>getCommentRange
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCommentRange(node) {
    var emitNode = node.emitNode;
    return (emitNode &amp;&amp; emitNode.commentRange) || node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getCommentsFromJSDoc" id="apidoc.element.typescript.getCommentsFromJSDoc">
        function <span class="apidocSignatureSpan">typescript.</span>getCommentsFromJSDoc
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCommentsFromJSDoc(node) {
    return ts.map(getJSDocs(node), function (doc) { return doc.comment; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getConstantValue" id="apidoc.element.typescript.getConstantValue">
        function <span class="apidocSignatureSpan">typescript.</span>getConstantValue
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getConstantValue(node) {
    var emitNode = node.emitNode;
    return emitNode &amp;&amp; emitNode.constantValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getContainerNode" id="apidoc.element.typescript.getContainerNode">
        function <span class="apidocSignatureSpan">typescript.</span>getContainerNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getContainerNode(node) {
    while (true) {
        node = node.parent;
        if (!node) {
            return undefined;
        }
        switch (node.kind) {
            case 263 /* SourceFile */:
            case 150 /* MethodDeclaration */:
            case 149 /* MethodSignature */:
            case 227 /* FunctionDeclaration */:
            case 185 /* FunctionExpression */:
            case 152 /* GetAccessor */:
            case 153 /* SetAccessor */:
            case 228 /* ClassDeclaration */:
            case 229 /* InterfaceDeclaration */:
            case 231 /* EnumDeclaration */:
            case 232 /* ModuleDeclaration */:
                return node;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getContainingClass" id="apidoc.element.typescript.getContainingClass">
        function <span class="apidocSignatureSpan">typescript.</span>getContainingClass
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getContainingClass(node) {
    while (true) {
        node = node.parent;
        if (!node || isClassLike(node)) {
            return node;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getContainingFunction" id="apidoc.element.typescript.getContainingFunction">
        function <span class="apidocSignatureSpan">typescript.</span>getContainingFunction
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getContainingFunction(node) {
    while (true) {
        node = node.parent;
        if (!node || isFunctionLike(node)) {
            return node;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getDeclarationDiagnostics" id="apidoc.element.typescript.getDeclarationDiagnostics">
        function <span class="apidocSignatureSpan">typescript.</span>getDeclarationDiagnostics
        <span class="apidocSignatureSpan">(host, resolver, targetSourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDeclarationDiagnostics(host, resolver, targetSourceFile) {
    var declarationDiagnostics = ts.createDiagnosticCollection();
    ts.forEachEmittedFile(host, getDeclarationDiagnosticsFromFile, targetSourceFile);
    return declarationDiagnostics.getDiagnostics(targetSourceFile ? targetSourceFile.fileName : undefined);
    function getDeclarationDiagnosticsFromFile(_a, sourceFileOrBundle) {
        var declarationFilePath = _a.declarationFilePath;
        emitDeclarations(host, resolver, declarationDiagnostics, declarationFilePath, sourceFileOrBundle, /*emitOnlyDtsFiles*/ false
);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getDeclarationEmitOutputFilePath" id="apidoc.element.typescript.getDeclarationEmitOutputFilePath">
        function <span class="apidocSignatureSpan">typescript.</span>getDeclarationEmitOutputFilePath
        <span class="apidocSignatureSpan">(sourceFile, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDeclarationEmitOutputFilePath(sourceFile, host) {
    var options = host.getCompilerOptions();
    var outputDir = options.declarationDir || options.outDir; // Prefer declaration folder if specified
    var path = outputDir
        ? getSourceFilePathInNewDir(sourceFile, host, outputDir)
        : sourceFile.fileName;
    return ts.removeFileExtension(path) + ".d.ts";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getDeclarationName" id="apidoc.element.typescript.getDeclarationName">
        function <span class="apidocSignatureSpan">typescript.</span>getDeclarationName
        <span class="apidocSignatureSpan">(node, allowComments, allowSourceMaps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDeclarationName(node, allowComments, allowSourceMaps) {
    return getName(node, allowComments, allowSourceMaps);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getDeclarationOfKind" id="apidoc.element.typescript.getDeclarationOfKind">
        function <span class="apidocSignatureSpan">typescript.</span>getDeclarationOfKind
        <span class="apidocSignatureSpan">(symbol, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDeclarationOfKind(symbol, kind) {
    var declarations = symbol.declarations;
    if (declarations) {
        for (var _i = 0, declarations_1 = declarations; _i &lt; declarations_1.length; _i++) {
            var declaration = declarations_1[_i];
            if (declaration.kind === kind) {
                return declaration;
            }
        }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getDeclaredName" id="apidoc.element.typescript.getDeclaredName">
        function <span class="apidocSignatureSpan">typescript.</span>getDeclaredName
        <span class="apidocSignatureSpan">(typeChecker, symbol, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDeclaredName(typeChecker, symbol, location) {
    // If this is an export or import specifier it could have been renamed using the 'as' syntax.
    // If so we want to search for whatever is under the cursor.
    if (isImportOrExportSpecifierName(location)) {
        return location.getText();
    }
    else if (ts.isStringOrNumericLiteral(location) &amp;&amp;
        location.parent.kind === 143 /* ComputedPropertyName */) {
        return location.text;
    }
    // Try to get the local symbol if we're dealing with an 'export default'
    // since that symbol has the "true" name.
    var localExportDefaultSymbol = ts.getLocalSymbolForExportDefault(symbol);
    var name = typeChecker.symbolToString(localExportDefaultSymbol || symbol);
    return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getDefaultCompilerOptions" id="apidoc.element.typescript.getDefaultCompilerOptions">
        function <span class="apidocSignatureSpan">typescript.</span>getDefaultCompilerOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultCompilerOptions() {
    // Always default to "ScriptTarget.ES5" for the language service
    return {
        target: 1<span class="apidocCodeCommentSpan"> /* ES5 */,
        jsx: 1 /* Preserve */
</span>    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getDefaultLibFileName" id="apidoc.element.typescript.getDefaultLibFileName">
        function <span class="apidocSignatureSpan">typescript.</span>getDefaultLibFileName
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultLibFileName(options) {
    switch (options.target) {
        case 5 /* ESNext */:
        case 4 /* ES2017 */:
            return "lib.es2017.d.ts";
        case 3 /* ES2016 */:
            return "lib.es2016.d.ts";
        case 2 /* ES2015 */:
            return "lib.es6.d.ts";
        default:
            return "lib.d.ts";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getDefaultLibFilePath" id="apidoc.element.typescript.getDefaultLibFilePath">
        function <span class="apidocSignatureSpan">typescript.</span>getDefaultLibFilePath
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultLibFilePath(options) {
    // Check __dirname is defined and that we are on a node.js system.
    if (typeof __dirname !== "undefined") {
        return __dirname + ts.directorySeparator + ts.getDefaultLibFileName(options);
    }
    throw new Error("getDefaultLibFilePath is only supported when consumed as a node module. ");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getDirectoryPath" id="apidoc.element.typescript.getDirectoryPath">
        function <span class="apidocSignatureSpan">typescript.</span>getDirectoryPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDirectoryPath(path) {
    return path.substr(0, Math.max(getRootLength(path), path.lastIndexOf(ts.directorySeparator)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEffectiveTypeRoots" id="apidoc.element.typescript.getEffectiveTypeRoots">
        function <span class="apidocSignatureSpan">typescript.</span>getEffectiveTypeRoots
        <span class="apidocSignatureSpan">(options, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEffectiveTypeRoots(options, host) {
    if (options.typeRoots) {
        return options.typeRoots;
    }
    var currentDirectory;
    if (options.configFilePath) {
        currentDirectory = ts.getDirectoryPath(options.configFilePath);
    }
    else if (host.getCurrentDirectory) {
        currentDirectory = host.getCurrentDirectory();
    }
    if (currentDirectory !== undefined) {
        return getDefaultTypeRoots(currentDirectory, host);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getElementsOfBindingOrAssignmentPattern" id="apidoc.element.typescript.getElementsOfBindingOrAssignmentPattern">
        function <span class="apidocSignatureSpan">typescript.</span>getElementsOfBindingOrAssignmentPattern
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getElementsOfBindingOrAssignmentPattern(name) {
    switch (name.kind) {
        case 173 /* ObjectBindingPattern */:
        case 174 /* ArrayBindingPattern */:
        case 176 /* ArrayLiteralExpression */:
            // `a` in `{a}`
            // `a` in `[a]`
            return name.elements;
        case 177 /* ObjectLiteralExpression */:
            // `a` in `{a}`
            return name.properties;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEmitFlags" id="apidoc.element.typescript.getEmitFlags">
        function <span class="apidocSignatureSpan">typescript.</span>getEmitFlags
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEmitFlags(node) {
    var emitNode = node.emitNode;
    return emitNode &amp;&amp; emitNode.flags;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEmitHelpers" id="apidoc.element.typescript.getEmitHelpers">
        function <span class="apidocSignatureSpan">typescript.</span>getEmitHelpers
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEmitHelpers(node) {
    var emitNode = node.emitNode;
    return emitNode &amp;&amp; emitNode.helpers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEmitModuleKind" id="apidoc.element.typescript.getEmitModuleKind">
        function <span class="apidocSignatureSpan">typescript.</span>getEmitModuleKind
        <span class="apidocSignatureSpan">(compilerOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEmitModuleKind(compilerOptions) {
    return typeof compilerOptions.module === "number" ?
        compilerOptions.module :
        getEmitScriptTarget(compilerOptions) &gt;= 2 /* ES2015 */ ? ts.ModuleKind.ES2015 : ts.ModuleKind.CommonJS;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEmitModuleResolutionKind" id="apidoc.element.typescript.getEmitModuleResolutionKind">
        function <span class="apidocSignatureSpan">typescript.</span>getEmitModuleResolutionKind
        <span class="apidocSignatureSpan">(compilerOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEmitModuleResolutionKind(compilerOptions) {
    var moduleResolution = compilerOptions.moduleResolution;
    if (moduleResolution === undefined) {
        moduleResolution = getEmitModuleKind(compilerOptions) === ts.ModuleKind.CommonJS ? ts.ModuleResolutionKind.NodeJs : ts.ModuleResolutionKind
.Classic;
    }
    return moduleResolution;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEmitScriptTarget" id="apidoc.element.typescript.getEmitScriptTarget">
        function <span class="apidocSignatureSpan">typescript.</span>getEmitScriptTarget
        <span class="apidocSignatureSpan">(compilerOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEmitScriptTarget(compilerOptions) {
    return compilerOptions.target || 0 /* ES3 */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEnclosingBlockScopeContainer" id="apidoc.element.typescript.getEnclosingBlockScopeContainer">
        function <span class="apidocSignatureSpan">typescript.</span>getEnclosingBlockScopeContainer
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEnclosingBlockScopeContainer(node) {
    var current = node.parent;
    while (current) {
        if (isBlockScope(current, current.parent)) {
            return current;
        }
        current = current.parent;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEncodedSemanticClassifications" id="apidoc.element.typescript.getEncodedSemanticClassifications">
        function <span class="apidocSignatureSpan">typescript.</span>getEncodedSemanticClassifications
        <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFile, classifiableNames, span)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
    var result = [];
    processNode(sourceFile);
    return { spans: result, endOfLineState: 0<span class="apidocCodeCommentSpan"> /* None */ };
    function pushClassification(start, length, type) {
        result.push(start);
        result.push(length);
        result.push(type);
    }
    function classifySymbol(symbol, meaningAtPosition) {
        var flags = symbol.getFlags();
        if ((flags &amp; 788448 /* Classifiable */) === 0 /* None */) {
            return;
        }
        if (flags &amp; 32 /* Class */) {
            return 11 /* className */;
        }
        else if (flags &amp; 384 /* Enum */) {
            return 12 /* enumName */;
        }
        else if (flags &amp; 524288 /* TypeAlias */) {
            return 16 /* typeAliasName */;
        }
        else if (meaningAtPosition &amp; 2 /* Type */) {
            if (flags &amp; 64 /* Interface */) {
                return 13 /* interfaceName */;
            }
            else if (flags &amp; 262144 /* TypeParameter */) {
                return 15 /* typeParameterName */;
            }
        }
        else if (flags &amp; 1536 /* Module */) {
            // Only classify a module as such if
            //  - It appears in a namespace context.
            //  - There exists a module declaration which actually impacts the value side.
            if (meaningAtPosition &amp; 4 /* Namespace */ ||
                (meaningAtPosition &amp; 1 /* Value */ &amp;&amp; hasValueSideModule(symbol))) {
                return 14 /* moduleName */;
            }
        }
        return undefined;
        /**
         * Returns true if there exists a module that introduces entities on the value side.
         */
</span>        function hasValueSideModule(symbol) {
            return ts.forEach(symbol.declarations, function (declaration) {
                return declaration.kind === 232 /* ModuleDeclaration */ &amp;&amp;
                    ts.getModuleInstanceState(declaration) === 1 /* Instantiated */;
            });
        }
    }
    function processNode(node) {
        // Only walk into nodes that intersect the requested span.
        if (node &amp;&amp; ts.textSpanIntersectsWith(span, node.getFullStart(), node.getFullWidth())) {
            var kind = node.kind;
            checkForClassificationCancellation(cancellationToken, kind);
            if (kind === 70 /* Identifier */ &amp;&amp; !ts.nodeIsMissing(node)) {
                var identifier = node;
                // Only bother calling into the typechecker if this is an identifier that
                // could possibly resolve to a type name.  This makes classification run
                // in a third of the time it would normally take.
                if (classifiableNames.get(identifier.text)) {
                    var symbol = typeChecker.getSymbolAtLocation(node);
                    if (symbol) {
                        var type = classifySymbol(symbol, ts.getMeaningFromLocation(node));
                        if (type) {
                            pushClassification(node.getStart(), node.getWidth(), type);
                        }
                    }
                }
            }
            ts.forEachChild(node, processNode);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEncodedSyntacticClassifications" id="apidoc.element.typescript.getEncodedSyntacticClassifications">
        function <span class="apidocSignatureSpan">typescript.</span>getEncodedSyntacticClassifications
        <span class="apidocSignatureSpan">(cancellationToken, sourceFile, span)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEncodedSyntacticClassifications(cancellationToken, sourceFile, span) {
    var spanStart = span.start;
    var spanLength = span.length;
    // Make a scanner we can get trivia from.
    var triviaScanner = ts.createScanner(5 /* Latest */, /*skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text);
    var mergeConflictScanner = ts.createScanner(5 /* Latest */, /*skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text
);
    var result = [];
    processElement(sourceFile);
    return { spans: result, endOfLineState: 0 /* None */ };
    function pushClassification(start, length, type) {
        result.push(start);
        result.push(length);
        result.push(type);
    }
    function classifyLeadingTriviaAndGetTokenStart(token) {
        triviaScanner.setTextPos(token.pos);
        while (true) {
            var start = triviaScanner.getTextPos();
            // only bother scanning if we have something that could be trivia.
            if (!ts.couldStartTrivia(sourceFile.text, start)) {
                return start;
            }
            var kind = triviaScanner.scan();
            var end = triviaScanner.getTextPos();
            var width = end - start;
            // The moment we get something that isn't trivia, then stop processing.
            if (!ts.isTrivia(kind)) {
                return start;
            }
            // Don't bother with newlines/whitespace.
            if (kind === 4 /* NewLineTrivia */ || kind === 5 /* WhitespaceTrivia */) {
                continue;
            }
            // Only bother with the trivia if it at least intersects the span of interest.
            if (ts.isComment(kind)) {
                classifyComment(token, kind, start, width);
                // Classifying a comment might cause us to reuse the trivia scanner
                // (because of jsdoc comments).  So after we classify the comment make
                // sure we set the scanner position back to where it needs to be.
                triviaScanner.setTextPos(end);
                continue;
            }
            if (kind === 7 /* ConflictMarkerTrivia */) {
                var text = sourceFile.text;
                var ch = text.charCodeAt(start);
                // for the &lt;&lt;&lt;&lt;&lt;&lt;&lt; and &gt;&gt;&gt;&gt;&gt;&gt;&gt; markers, we just add them in as comments
                // in the classification stream.
                if (ch === 60 /* lessThan */ || ch === 62 /* greaterThan */) {
                    pushClassification(start, width, 1 /* comment */);
                    continue;
                }
                // for the ======== add a comment for the first line, and then lex all
                // subsequent lines up until the end of the conflict marker.
                ts.Debug.assert(ch === 61 /* equals */);
                classifyDisabledMergeCode(text, start, end);
            }
        }
    }
    function classifyComment(token, kind, start, width) {
        if (kind === 3 /* MultiLineCommentTrivia */) {
            // See if this is a doc comment.  If so, we'll classify certain portions of it
            // specially.
            var docCommentAndDiagnostics = ts.parseIsolatedJSDocComment(sourceFile.text, start, width);
            if (docCommentAndDiagnostics &amp;&amp; docCommentAndDiagnostics.jsDoc) {
                docCommentAndDiagnostics.jsDoc.parent = token;
                classifyJSDocComment(docCommentAndDiagnostics.jsDoc);
                return;
            }
        }
        // Simple comment.  Just add as is.
        pushCommentRange(start, width);
    }
    function pushCommentRange(start, width) {
        pushClassification(start, width, 1 /* comment */);
    }
    function classifyJSDocComment(docComment) {
        var pos = docComment.pos;
        if (docComment.tags) {
            for (var _i = 0, _a = docComment.tags; _i &lt; _a.length; _i++) {
                var tag = _a[_i];
                // As we walk through each tag, classify the portion of text from the end of
                // the last tag (or the start of the entire doc comment) as 'comment'.
                i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEndLinePosition" id="apidoc.element.typescript.getEndLinePosition">
        function <span class="apidocSignatureSpan">typescript.</span>getEndLinePosition
        <span class="apidocSignatureSpan">(line, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEndLinePosition(line, sourceFile) {
    ts.Debug.assert(line &gt;= 0);
    var lineStarts = ts.getLineStarts(sourceFile);
    var lineIndex = line;
    var sourceText = sourceFile.text;
    if (lineIndex + 1 === lineStarts.length) {
        // last line - return EOF
        return sourceText.length - 1;
    }
    else {
        // current line start
        var start = lineStarts[lineIndex];
        // take the start position of the next line - 1 = it should be some line break
        var pos = lineStarts[lineIndex + 1] - 1;
        ts.Debug.assert(ts.isLineBreak(sourceText.charCodeAt(pos)));
        // walk backwards skipping line breaks, stop the the beginning of current line.
        // i.e:
        // &lt;some text&gt;
        // $ &lt;- end of line for this position should match the start position
        while (start &lt;= pos &amp;&amp; ts.isLineBreak(sourceText.charCodeAt(pos))) {
            pos--;
        }
        return pos;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getEntityNameFromTypeNode" id="apidoc.element.typescript.getEntityNameFromTypeNode">
        function <span class="apidocSignatureSpan">typescript.</span>getEntityNameFromTypeNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEntityNameFromTypeNode(node) {
    switch (node.kind) {
        case 158 /* TypeReference */:
        case 275 /* JSDocTypeReference */:
            return node.typeName;
        case 200 /* ExpressionWithTypeArguments */:
            return isEntityNameExpression(node.expression)
                ? node.expression
                : undefined;
        case 70 /* Identifier */:
        case 142 /* QualifiedName */:
            return node;
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getErrorSpanForNode" id="apidoc.element.typescript.getErrorSpanForNode">
        function <span class="apidocSignatureSpan">typescript.</span>getErrorSpanForNode
        <span class="apidocSignatureSpan">(sourceFile, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getErrorSpanForNode(sourceFile, node) {
    var errorNode = node;
    switch (node.kind) {
        case 263 /* SourceFile */:
            var pos_1 = ts.skipTrivia(sourceFile.text, 0, /*stopAfterLineBreak*/ false);
            if (pos_1 === sourceFile.text.length) {
                // file is empty - return span for the beginning of the file
                return ts.createTextSpan(0, 0);
            }
            return getSpanOfTokenAtPosition(sourceFile, pos_1);
        // This list is a work in progress. Add missing node kinds to improve their error
        // spans.
        case 225 /* VariableDeclaration */:
        case 175 /* BindingElement */:
        case 228 /* ClassDeclaration */:
        case 198 /* ClassExpression */:
        case 229 /* InterfaceDeclaration */:
        case 232 /* ModuleDeclaration */:
        case 231 /* EnumDeclaration */:
        case 262 /* EnumMember */:
        case 227 /* FunctionDeclaration */:
        case 185 /* FunctionExpression */:
        case 150 /* MethodDeclaration */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        case 230 /* TypeAliasDeclaration */:
            errorNode = node.name;
            break;
        case 186 /* ArrowFunction */:
            return getErrorSpanForArrowFunction(sourceFile, node);
    }
    if (errorNode === undefined) {
        // If we don't have a better node, then just set the error on the first token of
        // construct.
        return getSpanOfTokenAtPosition(sourceFile, node.pos);
    }
    var pos = nodeIsMissing(errorNode)
        ? errorNode.pos
        : ts.skipTrivia(sourceFile.text, errorNode.pos);
    return ts.createTextSpanFromBounds(pos, errorNode.end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExportName" id="apidoc.element.typescript.getExportName">
        function <span class="apidocSignatureSpan">typescript.</span>getExportName
        <span class="apidocSignatureSpan">(node, allowComments, allowSourceMaps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExportName(node, allowComments, allowSourceMaps) {
    return getName(node, allowComments, allowSourceMaps, 8192 /* ExportName */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExpressionAssociativity" id="apidoc.element.typescript.getExpressionAssociativity">
        function <span class="apidocSignatureSpan">typescript.</span>getExpressionAssociativity
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExpressionAssociativity(expression) {
    var operator = getOperator(expression);
    var hasArguments = expression.kind === 181 /* NewExpression */ &amp;&amp; expression.arguments !== undefined;
    return getOperatorAssociativity(expression.kind, operator, hasArguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExpressionPrecedence" id="apidoc.element.typescript.getExpressionPrecedence">
        function <span class="apidocSignatureSpan">typescript.</span>getExpressionPrecedence
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExpressionPrecedence(expression) {
    var operator = getOperator(expression);
    var hasArguments = expression.kind === 181 /* NewExpression */ &amp;&amp; expression.arguments !== undefined;
    return getOperatorPrecedence(expression.kind, operator, hasArguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExtensionPriority" id="apidoc.element.typescript.getExtensionPriority">
        function <span class="apidocSignatureSpan">typescript.</span>getExtensionPriority
        <span class="apidocSignatureSpan">(path, supportedExtensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExtensionPriority(path, supportedExtensions) {
    for (var i = supportedExtensions.length - 1; i &gt;= 0; i--) {
        if (fileExtensionIs(path, supportedExtensions[i])) {
            return adjustExtensionPriority(i, supportedExtensions);
        }
    }
    // If its not in the list of supported extensions, this is likely a
    // TypeScript file with a non-ts extension
    return 0 /* Highest */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExternalHelpersModuleName" id="apidoc.element.typescript.getExternalHelpersModuleName">
        function <span class="apidocSignatureSpan">typescript.</span>getExternalHelpersModuleName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExternalHelpersModuleName(node) {
    var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
    var emitNode = parseNode &amp;&amp; parseNode.emitNode;
    return emitNode &amp;&amp; emitNode.externalHelpersModuleName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExternalModuleImportEqualsDeclarationExpression" id="apidoc.element.typescript.getExternalModuleImportEqualsDeclarationExpression">
        function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleImportEqualsDeclarationExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExternalModuleImportEqualsDeclarationExpression(node) {
    ts.Debug.assert(isExternalModuleImportEqualsDeclaration(node));
    return node.moduleReference.expression;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExternalModuleName" id="apidoc.element.typescript.getExternalModuleName">
        function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExternalModuleName(node) {
    if (node.kind === 237 /* ImportDeclaration */) {
        return node.moduleSpecifier;
    }
    if (node.kind === 236 /* ImportEqualsDeclaration */) {
        var reference = node.moduleReference;
        if (reference.kind === 247 /* ExternalModuleReference */) {
            return reference.expression;
        }
    }
    if (node.kind === 243 /* ExportDeclaration */) {
        return node.moduleSpecifier;
    }
    if (node.kind === 232 /* ModuleDeclaration */ &amp;&amp; node.name.kind === 9 /* StringLiteral */) {
        return node.name;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExternalModuleNameFromDeclaration" id="apidoc.element.typescript.getExternalModuleNameFromDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleNameFromDeclaration
        <span class="apidocSignatureSpan">(host, resolver, declaration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExternalModuleNameFromDeclaration(host, resolver, declaration) {
    var file = resolver.getExternalModuleFileFromDeclaration(declaration);
    if (!file || isDeclarationFile(file)) {
        return undefined;
    }
    return getResolvedExternalModuleName(host, file);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExternalModuleNameFromPath" id="apidoc.element.typescript.getExternalModuleNameFromPath">
        function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleNameFromPath
        <span class="apidocSignatureSpan">(host, fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExternalModuleNameFromPath(host, fileName) {
    var getCanonicalFileName = function (f) { return host.getCanonicalFileName(f); };
    var dir = ts.toPath(host.getCommonSourceDirectory(), host.getCurrentDirectory(), getCanonicalFileName);
    var filePath = ts.getNormalizedAbsolutePath(fileName, host.getCurrentDirectory());
    var relativePath = ts.getRelativePathToDirectoryOrUrl(dir, filePath, dir, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false
);
    return ts.removeFileExtension(relativePath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExternalModuleNameLiteral" id="apidoc.element.typescript.getExternalModuleNameLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleNameLiteral
        <span class="apidocSignatureSpan">(importNode, sourceFile, host, resolver, compilerOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExternalModuleNameLiteral(importNode, sourceFile, host, resolver, compilerOptions) {
    var moduleName = ts.getExternalModuleName(importNode);
    if (moduleName.kind === 9 /* StringLiteral */) {
        return tryGetModuleNameFromDeclaration(importNode, host, resolver, compilerOptions)
            || tryRenameExternalModule(moduleName, sourceFile)
            || ts.getSynthesizedClone(moduleName);
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getExternalModuleOrNamespaceExportName" id="apidoc.element.typescript.getExternalModuleOrNamespaceExportName">
        function <span class="apidocSignatureSpan">typescript.</span>getExternalModuleOrNamespaceExportName
        <span class="apidocSignatureSpan">(ns, node, allowComments, allowSourceMaps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExternalModuleOrNamespaceExportName(ns, node, allowComments, allowSourceMaps) {
    if (ns &amp;&amp; ts.hasModifier(node, 1 /* Export */)) {
        return getNamespaceMemberName(ns, getName(node), allowComments, allowSourceMaps);
    }
    return getExportName(node, allowComments, allowSourceMaps);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getFileMatcherPatterns" id="apidoc.element.typescript.getFileMatcherPatterns">
        function <span class="apidocSignatureSpan">typescript.</span>getFileMatcherPatterns
        <span class="apidocSignatureSpan">(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {
    path = normalizePath(path);
    currentDirectory = normalizePath(currentDirectory);
    var absolutePath = combinePaths(currentDirectory, path);
    return {
        includeFilePatterns: map(getRegularExpressionsForWildcards(includes, absolutePath, "files"), function (pattern) { return
 "^" + pattern + "$"; }),
        includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, "files"),
        includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, "directories"),
        excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, "exclude"),
        basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getFileReferenceFromReferencePath" id="apidoc.element.typescript.getFileReferenceFromReferencePath">
        function <span class="apidocSignatureSpan">typescript.</span>getFileReferenceFromReferencePath
        <span class="apidocSignatureSpan">(comment, commentRange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFileReferenceFromReferencePath(comment, commentRange) {
    var simpleReferenceRegEx = /^\/\/\/\s*&lt;reference\s+/gim;
    var isNoDefaultLibRegEx = /^(\/\/\/\s*&lt;reference\s+no-default-lib\s*=\s*)('|")(.+?)\2\s*\/&gt;/gim;
    if (simpleReferenceRegEx.test(comment)) {
        if (isNoDefaultLibRegEx.test(comment)) {
            return {
                isNoDefaultLib: true
            };
        }
        else {
            var refMatchResult = ts.fullTripleSlashReferencePathRegEx.exec(comment);
            var refLibResult = !refMatchResult &amp;&amp; ts.fullTripleSlashReferenceTypeReferenceDirectiveRegEx.exec(comment);
            if (refMatchResult || refLibResult) {
                var start = commentRange.pos;
                var end = commentRange.end;
                return {
                    fileReference: {
                        pos: start,
                        end: end,
                        fileName: (refMatchResult || refLibResult)[3]
                    },
                    isNoDefaultLib: false,
                    isTypeReferenceDirective: !!refLibResult
                };
            }
            return {
                diagnosticMessage: ts.Diagnostics.Invalid_reference_directive_syntax,
                isNoDefaultLib: false
            };
        }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getFirstConstructorWithBody" id="apidoc.element.typescript.getFirstConstructorWithBody">
        function <span class="apidocSignatureSpan">typescript.</span>getFirstConstructorWithBody
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFirstConstructorWithBody(node) {
    return ts.forEach(node.members, function (member) {
        if (member.kind === 151 /* Constructor */ &amp;&amp; nodeIsPresent(member.body)) {
            return member;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getFullWidth" id="apidoc.element.typescript.getFullWidth">
        function <span class="apidocSignatureSpan">typescript.</span>getFullWidth
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFullWidth(node) {
    return node.end - node.pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getGeneratedNameForNode" id="apidoc.element.typescript.getGeneratedNameForNode">
        function <span class="apidocSignatureSpan">typescript.</span>getGeneratedNameForNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getGeneratedNameForNode(node) {
    var name = createIdentifier("");
    name.autoGenerateKind = 4 /* Node */;
    name.autoGenerateId = nextAutoGenerateId;
    name.original = node;
    nextAutoGenerateId++;
    return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getHelperName" id="apidoc.element.typescript.getHelperName">
        function <span class="apidocSignatureSpan">typescript.</span>getHelperName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHelperName(name) {
    return ts.setEmitFlags(ts.createIdentifier(name), 4096 /* HelperName */ | 2 /* AdviseOnEmitNode */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getHeritageClause" id="apidoc.element.typescript.getHeritageClause">
        function <span class="apidocSignatureSpan">typescript.</span>getHeritageClause
        <span class="apidocSignatureSpan">(clauses, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHeritageClause(clauses, kind) {
    if (clauses) {
        for (var _i = 0, clauses_1 = clauses; _i &lt; clauses_1.length; _i++) {
            var clause = clauses_1[_i];
            if (clause.token === kind) {
                return clause;
            }
        }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getImmediatelyInvokedFunctionExpression" id="apidoc.element.typescript.getImmediatelyInvokedFunctionExpression">
        function <span class="apidocSignatureSpan">typescript.</span>getImmediatelyInvokedFunctionExpression
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getImmediatelyInvokedFunctionExpression(func) {
    if (func.kind === 185 /* FunctionExpression */ || func.kind === 186 /* ArrowFunction */) {
        var prev = func;
        var parent = func.parent;
        while (parent.kind === 184 /* ParenthesizedExpression */) {
            prev = parent;
            parent = parent.parent;
        }
        if (parent.kind === 180 /* CallExpression */ &amp;&amp; parent.expression === prev) {
            return parent;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getIndentSize" id="apidoc.element.typescript.getIndentSize">
        function <span class="apidocSignatureSpan">typescript.</span>getIndentSize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getIndentSize() {
    return indentStrings[1].length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getIndentString" id="apidoc.element.typescript.getIndentString">
        function <span class="apidocSignatureSpan">typescript.</span>getIndentString
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getIndentString(level) {
    if (indentStrings[level] === undefined) {
        indentStrings[level] = getIndentString(level - 1) + indentStrings[1];
    }
    return indentStrings[level];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getInitializedVariables" id="apidoc.element.typescript.getInitializedVariables">
        function <span class="apidocSignatureSpan">typescript.</span>getInitializedVariables
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getInitializedVariables(node) {
    return ts.filter(node.declarations, isInitializedVariable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getInitializerOfBindingOrAssignmentElement" id="apidoc.element.typescript.getInitializerOfBindingOrAssignmentElement">
        function <span class="apidocSignatureSpan">typescript.</span>getInitializerOfBindingOrAssignmentElement
        <span class="apidocSignatureSpan">(bindingElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getInitializerOfBindingOrAssignmentElement(bindingElement) {
    if (ts.isDeclarationBindingElement(bindingElement)) {
        // `1` in `let { a = 1 } = ...`
        // `1` in `let { a: b = 1 } = ...`
        // `1` in `let { a: {b} = 1 } = ...`
        // `1` in `let { a: [b] = 1 } = ...`
        // `1` in `let [a = 1] = ...`
        // `1` in `let [{a} = 1] = ...`
        // `1` in `let [[a] = 1] = ...`
        return bindingElement.initializer;
    }
    if (ts.isPropertyAssignment(bindingElement)) {
        // `1` in `({ a: b = 1 } = ...)`
        // `1` in `({ a: {b} = 1 } = ...)`
        // `1` in `({ a: [b] = 1 } = ...)`
        return ts.isAssignmentExpression(bindingElement.initializer, /*excludeCompoundAssignment*/ true)
            ? bindingElement.initializer.right
            : undefined;
    }
    if (ts.isShorthandPropertyAssignment(bindingElement)) {
        // `1` in `({ a = 1 } = ...)`
        return bindingElement.objectAssignmentInitializer;
    }
    if (ts.isAssignmentExpression(bindingElement, /*excludeCompoundAssignment*/ true)) {
        // `1` in `[a = 1] = ...`
        // `1` in `[{a} = 1] = ...`
        // `1` in `[[a] = 1] = ...`
        return bindingElement.right;
    }
    if (ts.isSpreadExpression(bindingElement)) {
        // Recovery consistent with existing emit.
        return getInitializerOfBindingOrAssignmentElement(bindingElement.expression);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getInterfaceBaseTypeNodes" id="apidoc.element.typescript.getInterfaceBaseTypeNodes">
        function <span class="apidocSignatureSpan">typescript.</span>getInterfaceBaseTypeNodes
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getInterfaceBaseTypeNodes(node) {
    var heritageClause = getHeritageClause(node.heritageClauses, 84 /* ExtendsKeyword */);
    return heritageClause ? heritageClause.types : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getInvokedExpression" id="apidoc.element.typescript.getInvokedExpression">
        function <span class="apidocSignatureSpan">typescript.</span>getInvokedExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getInvokedExpression(node) {
    if (node.kind === 182 /* TaggedTemplateExpression */) {
        return node.tag;
    }
    // Will either be a CallExpression, NewExpression, or Decorator.
    return node.expression;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getJSDocAugmentsTag" id="apidoc.element.typescript.getJSDocAugmentsTag">
        function <span class="apidocSignatureSpan">typescript.</span>getJSDocAugmentsTag
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getJSDocAugmentsTag(node) {
    return getFirstJSDocTag(node, 283 /* JSDocAugmentsTag */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getJSDocCommentRanges" id="apidoc.element.typescript.getJSDocCommentRanges">
        function <span class="apidocSignatureSpan">typescript.</span>getJSDocCommentRanges
        <span class="apidocSignatureSpan">(node, text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getJSDocCommentRanges(node, text) {
    var commentRanges = (node.kind === 145 /* Parameter */ ||
        node.kind === 144 /* TypeParameter */ ||
        node.kind === 185 /* FunctionExpression */ ||
        node.kind === 186 /* ArrowFunction */) ?
        ts.concatenate(ts.getTrailingCommentRanges(text, node.pos), ts.getLeadingCommentRanges(text, node.pos)) :
        getLeadingCommentRangesOfNodeFromText(node, text);
    // True if the comment starts with '/**' but not if it is '/**/'
    return ts.filter(commentRanges, function (comment) {
        return text.charCodeAt(comment.pos + 1) === 42 /* asterisk */ &amp;&amp;
            text.charCodeAt(comment.pos + 2) === 42 /* asterisk */ &amp;&amp;
            text.charCodeAt(comment.pos + 3) !== 47 /* slash */;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getJSDocParameterTags" id="apidoc.element.typescript.getJSDocParameterTags">
        function <span class="apidocSignatureSpan">typescript.</span>getJSDocParameterTags
        <span class="apidocSignatureSpan">(param)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getJSDocParameterTags(param) {
    if (!isParameter(param)) {
        return undefined;
    }
    var func = param.parent;
    var tags = getJSDocTags(func, 284 /* JSDocParameterTag */);
    if (!param.name) {
        // this is an anonymous jsdoc param from a `function(type1, type2): type3` specification
        var i = func.parameters.indexOf(param);
        var paramTags = ts.filter(tags, function (tag) { return tag.kind === 284 /* JSDocParameterTag */; });
        if (paramTags &amp;&amp; 0 &lt;= i &amp;&amp; i &lt; paramTags.length) {
            return [paramTags[i]];
        }
    }
    else if (param.name.kind === 70 /* Identifier */) {
        var name_1 = param.name.text;
        return ts.filter(tags, function (tag) { return tag.kind === 284 /* JSDocParameterTag */ &amp;&amp; tag.parameterName.text === name_1
; });
    }
    else {
        // TODO: it's a destructured parameter, so it should look up an "object type" series of multiple lines
        // But multi-line object types aren't supported yet either
        return undefined;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getJSDocReturnTag" id="apidoc.element.typescript.getJSDocReturnTag">
        function <span class="apidocSignatureSpan">typescript.</span>getJSDocReturnTag
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getJSDocReturnTag(node) {
    return getFirstJSDocTag(node, 285 /* JSDocReturnTag */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getJSDocTemplateTag" id="apidoc.element.typescript.getJSDocTemplateTag">
        function <span class="apidocSignatureSpan">typescript.</span>getJSDocTemplateTag
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getJSDocTemplateTag(node) {
    return getFirstJSDocTag(node, 287 /* JSDocTemplateTag */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getJSDocType" id="apidoc.element.typescript.getJSDocType">
        function <span class="apidocSignatureSpan">typescript.</span>getJSDocType
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getJSDocType(node) {
    var tag = getFirstJSDocTag(node, 286 /* JSDocTypeTag */);
    if (!tag &amp;&amp; node.kind === 145 /* Parameter */) {
        var paramTags = getJSDocParameterTags(node);
        if (paramTags) {
            tag = ts.find(paramTags, function (tag) { return !!tag.typeExpression; });
        }
    }
    return tag &amp;&amp; tag.typeExpression &amp;&amp; tag.typeExpression.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getJsDocTagAtPosition" id="apidoc.element.typescript.getJsDocTagAtPosition">
        function <span class="apidocSignatureSpan">typescript.</span>getJsDocTagAtPosition
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getJsDocTagAtPosition(sourceFile, position) {
    var node = ts.getTokenAtPosition(sourceFile, position);
    if (isToken(node)) {
        switch (node.kind) {
            case 103 /* VarKeyword */:
            case 109 /* LetKeyword */:
            case 75 /* ConstKeyword */:
                // if the current token is var, let or const, skip the VariableDeclarationList
                node = node.parent === undefined ? undefined : node.parent.parent;
                break;
            default:
                node = node.parent;
                break;
        }
    }
    if (node) {
        if (node.jsDoc) {
            for (var _i = 0, _a = node.jsDoc; _i &lt; _a.length; _i++) {
                var jsDoc = _a[_i];
                if (jsDoc.tags) {
                    for (var _b = 0, _c = jsDoc.tags; _b &lt; _c.length; _b++) {
                        var tag = _c[_b];
                        if (tag.pos &lt;= position &amp;&amp; position &lt;= tag.end) {
                            return tag;
                        }
                    }
                }
            }
        }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLeadingCommentRanges" id="apidoc.element.typescript.getLeadingCommentRanges">
        function <span class="apidocSignatureSpan">typescript.</span>getLeadingCommentRanges
        <span class="apidocSignatureSpan">(text, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLeadingCommentRanges(text, pos) {
    return reduceEachLeadingCommentRange(text, pos, appendCommentRange, undefined, undefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLeadingCommentRangesOfNode" id="apidoc.element.typescript.getLeadingCommentRangesOfNode">
        function <span class="apidocSignatureSpan">typescript.</span>getLeadingCommentRangesOfNode
        <span class="apidocSignatureSpan">(node, sourceFileOfNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLeadingCommentRangesOfNode(node, sourceFileOfNode) {
    return ts.getLeadingCommentRanges(sourceFileOfNode.text, node.pos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLeadingCommentRangesOfNodeFromText" id="apidoc.element.typescript.getLeadingCommentRangesOfNodeFromText">
        function <span class="apidocSignatureSpan">typescript.</span>getLeadingCommentRangesOfNodeFromText
        <span class="apidocSignatureSpan">(node, text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLeadingCommentRangesOfNodeFromText(node, text) {
    return ts.getLeadingCommentRanges(text, node.pos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLineAndCharacterOfPosition" id="apidoc.element.typescript.getLineAndCharacterOfPosition">
        function <span class="apidocSignatureSpan">typescript.</span>getLineAndCharacterOfPosition
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineAndCharacterOfPosition(sourceFile, position) {
    return computeLineAndCharacterOfPosition(getLineStarts(sourceFile), position);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLineOfLocalPosition" id="apidoc.element.typescript.getLineOfLocalPosition">
        function <span class="apidocSignatureSpan">typescript.</span>getLineOfLocalPosition
        <span class="apidocSignatureSpan">(currentSourceFile, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineOfLocalPosition(currentSourceFile, pos) {
    return ts.getLineAndCharacterOfPosition(currentSourceFile, pos).line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLineOfLocalPositionFromLineMap" id="apidoc.element.typescript.getLineOfLocalPositionFromLineMap">
        function <span class="apidocSignatureSpan">typescript.</span>getLineOfLocalPositionFromLineMap
        <span class="apidocSignatureSpan">(lineMap, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineOfLocalPositionFromLineMap(lineMap, pos) {
    return ts.computeLineAndCharacterOfPosition(lineMap, pos).line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLineStartPositionForPosition" id="apidoc.element.typescript.getLineStartPositionForPosition">
        function <span class="apidocSignatureSpan">typescript.</span>getLineStartPositionForPosition
        <span class="apidocSignatureSpan">(position, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineStartPositionForPosition(position, sourceFile) {
    var lineStarts = sourceFile.getLineStarts();
    var line = sourceFile.getLineAndCharacterOfPosition(position).line;
    return lineStarts[line];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLineStarts" id="apidoc.element.typescript.getLineStarts">
        function <span class="apidocSignatureSpan">typescript.</span>getLineStarts
        <span class="apidocSignatureSpan">(sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineStarts(sourceFile) {
    return sourceFile.lineMap || (sourceFile.lineMap = computeLineStarts(sourceFile.text));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLiteralText" id="apidoc.element.typescript.getLiteralText">
        function <span class="apidocSignatureSpan">typescript.</span>getLiteralText
        <span class="apidocSignatureSpan">(node, sourceFile, languageVersion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLiteralText(node, sourceFile, languageVersion) {
    // Any template literal or string literal with an extended escape
    // (e.g. "\u{0067}") will need to be downleveled as a escaped string literal.
    if (languageVersion &lt; 2 /* ES2015 */ &amp;&amp; (isTemplateLiteralKind(node.kind) || node.hasExtendedUnicodeEscape)) {
        return getQuotedEscapedLiteralText('"', node.text, '"');
    }
    // If we don't need to downlevel and we can reach the original source text using
    // the node's parent reference, then simply get the text as it was originally written.
    if (!nodeIsSynthesized(node) &amp;&amp; node.parent) {
        var text = getSourceTextOfNodeFromSourceFile(sourceFile, node);
        if (languageVersion &lt; 2 /* ES2015 */ &amp;&amp; isBinaryOrOctalIntegerLiteral(node, text)) {
            return node.text;
        }
        return text;
    }
    // If we can't reach the original source text, use the canonical form if it's a number,
    // or an escaped quoted form of the original text if it's string-like.
    switch (node.kind) {
        case 9 /* StringLiteral */:
            return getQuotedEscapedLiteralText('"', node.text, '"');
        case 12 /* NoSubstitutionTemplateLiteral */:
            return getQuotedEscapedLiteralText("`", node.text, "`");
        case 13 /* TemplateHead */:
            return getQuotedEscapedLiteralText("`", node.text, "${");
        case 14 /* TemplateMiddle */:
            return getQuotedEscapedLiteralText("}", node.text, "${");
        case 15 /* TemplateTail */:
            return getQuotedEscapedLiteralText("}", node.text, "`");
        case 8 /* NumericLiteral */:
            return node.text;
    }
    ts.Debug.fail("Literal kind '" + node.kind + "' not accounted for.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLocalName" id="apidoc.element.typescript.getLocalName">
        function <span class="apidocSignatureSpan">typescript.</span>getLocalName
        <span class="apidocSignatureSpan">(node, allowComments, allowSourceMaps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLocalName(node, allowComments, allowSourceMaps) {
    return getName(node, allowComments, allowSourceMaps, 16384 /* LocalName */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLocalNameForExternalImport" id="apidoc.element.typescript.getLocalNameForExternalImport">
        function <span class="apidocSignatureSpan">typescript.</span>getLocalNameForExternalImport
        <span class="apidocSignatureSpan">(node, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLocalNameForExternalImport(node, sourceFile) {
    var namespaceDeclaration = ts.getNamespaceDeclarationNode(node);
    if (namespaceDeclaration &amp;&amp; !ts.isDefaultImport(node)) {
        var name = namespaceDeclaration.name;
        return ts.isGeneratedIdentifier(name) ? name : ts.createIdentifier(ts.getSourceTextOfNodeFromSourceFile(sourceFile, namespaceDeclaration
.name));
    }
    if (node.kind === 237 /* ImportDeclaration */ &amp;&amp; node.importClause) {
        return ts.getGeneratedNameForNode(node);
    }
    if (node.kind === 243 /* ExportDeclaration */ &amp;&amp; node.moduleSpecifier) {
        return ts.getGeneratedNameForNode(node);
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLocalSymbolForExportDefault" id="apidoc.element.typescript.getLocalSymbolForExportDefault">
        function <span class="apidocSignatureSpan">typescript.</span>getLocalSymbolForExportDefault
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLocalSymbolForExportDefault(symbol) {
    return isExportDefaultSymbol(symbol) ? symbol.valueDeclaration.localSymbol : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getLocaleSpecificMessage" id="apidoc.element.typescript.getLocaleSpecificMessage">
        function <span class="apidocSignatureSpan">typescript.</span>getLocaleSpecificMessage
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLocaleSpecificMessage(message) {
    return ts.localizedDiagnosticMessages &amp;&amp; ts.localizedDiagnosticMessages[message.key] || message.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getMeaningFromDeclaration" id="apidoc.element.typescript.getMeaningFromDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>getMeaningFromDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMeaningFromDeclaration(node) {
    switch (node.kind) {
        case 145 /* Parameter */:
        case 225 /* VariableDeclaration */:
        case 175 /* BindingElement */:
        case 148 /* PropertyDeclaration */:
        case 147 /* PropertySignature */:
        case 259 /* PropertyAssignment */:
        case 260 /* ShorthandPropertyAssignment */:
        case 262 /* EnumMember */:
        case 150 /* MethodDeclaration */:
        case 149 /* MethodSignature */:
        case 151 /* Constructor */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        case 227 /* FunctionDeclaration */:
        case 185 /* FunctionExpression */:
        case 186 /* ArrowFunction */:
        case 258 /* CatchClause */:
            return 1 /* Value */;
        case 144 /* TypeParameter */:
        case 229 /* InterfaceDeclaration */:
        case 230 /* TypeAliasDeclaration */:
        case 162 /* TypeLiteral */:
            return 2 /* Type */;
        case 228 /* ClassDeclaration */:
        case 231 /* EnumDeclaration */:
            return 1 /* Value */ | 2 /* Type */;
        case 232 /* ModuleDeclaration */:
            if (ts.isAmbientModule(node)) {
                return 4 /* Namespace */ | 1 /* Value */;
            }
            else if (ts.getModuleInstanceState(node) === 1 /* Instantiated */) {
                return 4 /* Namespace */ | 1 /* Value */;
            }
            else {
                return 4 /* Namespace */;
            }
        case 240 /* NamedImports */:
        case 241 /* ImportSpecifier */:
        case 236 /* ImportEqualsDeclaration */:
        case 237 /* ImportDeclaration */:
        case 242 /* ExportAssignment */:
        case 243 /* ExportDeclaration */:
            return 1 /* Value */ | 2 /* Type */ | 4 /* Namespace */;
        // An external module can be a Value
        case 263 /* SourceFile */:
            return 4 /* Namespace */ | 1 /* Value */;
    }
    return 1 /* Value */ | 2 /* Type */ | 4 /* Namespace */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getMeaningFromLocation" id="apidoc.element.typescript.getMeaningFromLocation">
        function <span class="apidocSignatureSpan">typescript.</span>getMeaningFromLocation
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMeaningFromLocation(node) {
    if (node.kind === 263 /* SourceFile */) {
        return 1 /* Value */;
    }
    else if (node.parent.kind === 242 /* ExportAssignment */) {
        return 1 /* Value */ | 2 /* Type */ | 4 /* Namespace */;
    }
    else if (isInRightSideOfImport(node)) {
        return getMeaningFromRightHandSideOfImportEquals(node);
    }
    else if (ts.isDeclarationName(node)) {
        return getMeaningFromDeclaration(node.parent);
    }
    else if (isTypeReference(node)) {
        return 2 /* Type */;
    }
    else if (isNamespaceReference(node)) {
        return 4 /* Namespace */;
    }
    else {
        return 1 /* Value */;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getModifierFlags" id="apidoc.element.typescript.getModifierFlags">
        function <span class="apidocSignatureSpan">typescript.</span>getModifierFlags
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getModifierFlags(node) {
    if (node.modifierFlagsCache &amp; 536870912 /* HasComputedFlags */) {
        return node.modifierFlagsCache &amp; ~536870912 /* HasComputedFlags */;
    }
    var flags = 0 /* None */;
    if (node.modifiers) {
        for (var _i = 0, _a = node.modifiers; _i &lt; _a.length; _i++) {
            var modifier = _a[_i];
            flags |= modifierToFlag(modifier.kind);
        }
    }
    if (node.flags &amp; 4 /* NestedNamespace */ || (node.kind === 70 /* Identifier */ &amp;&amp; node.isInJSDocNamespace)) {
        flags |= 1 /* Export */;
    }
    node.modifierFlagsCache = flags | 536870912 /* HasComputedFlags */;
    return flags;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getModuleInstanceState" id="apidoc.element.typescript.getModuleInstanceState">
        function <span class="apidocSignatureSpan">typescript.</span>getModuleInstanceState
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getModuleInstanceState(node) {
    // A module is uninstantiated if it contains only
    // 1. interface declarations, type alias declarations
    if (node.kind === 229 /* InterfaceDeclaration */ || node.kind === 230 /* TypeAliasDeclaration */) {
        return 0 /* NonInstantiated */;
    }
    else if (ts.isConstEnumDeclaration(node)) {
        return 2 /* ConstEnumOnly */;
    }
    else if ((node.kind === 237 /* ImportDeclaration */ || node.kind === 236 /* ImportEqualsDeclaration */) &amp;&amp; !(ts.hasModifier(
node, 1 /* Export */))) {
        return 0 /* NonInstantiated */;
    }
    else if (node.kind === 233 /* ModuleBlock */) {
        var state_1 = 0 /* NonInstantiated */;
        ts.forEachChild(node, function (n) {
            switch (getModuleInstanceState(n)) {
                case 0 /* NonInstantiated */:
                    // child is non-instantiated - continue searching
                    return false;
                case 2 /* ConstEnumOnly */:
                    // child is const enum only - record state and continue searching
                    state_1 = 2 /* ConstEnumOnly */;
                    return false;
                case 1 /* Instantiated */:
                    // child is instantiated - record state and stop
                    state_1 = 1 /* Instantiated */;
                    return true;
            }
        });
        return state_1;
    }
    else if (node.kind === 232 /* ModuleDeclaration */) {
        var body = node.body;
        return body ? getModuleInstanceState(body) : 1 /* Instantiated */;
    }
    else if (node.kind === 70 /* Identifier */ &amp;&amp; node.isInJSDocNamespace) {
        return 0 /* NonInstantiated */;
    }
    else {
        return 1 /* Instantiated */;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getMutableClone" id="apidoc.element.typescript.getMutableClone">
        function <span class="apidocSignatureSpan">typescript.</span>getMutableClone
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMutableClone(node) {
    var clone = getSynthesizedClone(node);
    clone.pos = node.pos;
    clone.end = node.end;
    clone.parent = node.parent;
    return clone;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNameTable" id="apidoc.element.typescript.getNameTable">
        function <span class="apidocSignatureSpan">typescript.</span>getNameTable
        <span class="apidocSignatureSpan">(sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNameTable(sourceFile) {
    if (!sourceFile.nameTable) {
        initializeNameTable(sourceFile);
    }
    return sourceFile.nameTable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNamespaceDeclarationNode" id="apidoc.element.typescript.getNamespaceDeclarationNode">
        function <span class="apidocSignatureSpan">typescript.</span>getNamespaceDeclarationNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNamespaceDeclarationNode(node) {
    if (node.kind === 236 /* ImportEqualsDeclaration */) {
        return node;
    }
    var importClause = node.importClause;
    if (importClause &amp;&amp; importClause.namedBindings &amp;&amp; importClause.namedBindings.kind === 239 /* NamespaceImport */) {
        return importClause.namedBindings;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNamespaceMemberName" id="apidoc.element.typescript.getNamespaceMemberName">
        function <span class="apidocSignatureSpan">typescript.</span>getNamespaceMemberName
        <span class="apidocSignatureSpan">(ns, name, allowComments, allowSourceMaps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNamespaceMemberName(ns, name, allowComments, allowSourceMaps) {
    var qualifiedName = ts.createPropertyAccess(ns, ts.nodeIsSynthesized(name) ? name : ts.getSynthesizedClone(name));
    ts.setTextRange(qualifiedName, name);
    var emitFlags;
    if (!allowSourceMaps)
        emitFlags |= 48 /* NoSourceMap */;
    if (!allowComments)
        emitFlags |= 1536 /* NoComments */;
    if (emitFlags)
        ts.setEmitFlags(qualifiedName, emitFlags);
    return qualifiedName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNewLineCharacter" id="apidoc.element.typescript.getNewLineCharacter">
        function <span class="apidocSignatureSpan">typescript.</span>getNewLineCharacter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNewLineCharacter(options) {
    if (options.newLine === 0 /* CarriageReturnLineFeed */) {
        return carriageReturnLineFeed;
    }
    else if (options.newLine === 1 /* LineFeed */) {
        return lineFeed;
    }
    else if (ts.sys) {
        return ts.sys.newLine;
    }
    return carriageReturnLineFeed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNewLineOrDefaultFromHost" id="apidoc.element.typescript.getNewLineOrDefaultFromHost">
        function <span class="apidocSignatureSpan">typescript.</span>getNewLineOrDefaultFromHost
        <span class="apidocSignatureSpan">(host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNewLineOrDefaultFromHost(host) {
    return host.getNewLine ? host.getNewLine() : carriageReturnLineFeed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNewTargetContainer" id="apidoc.element.typescript.getNewTargetContainer">
        function <span class="apidocSignatureSpan">typescript.</span>getNewTargetContainer
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNewTargetContainer(node) {
    var container = getThisContainer(node, /*includeArrowFunctions*/ false);
    if (container) {
        switch (container.kind) {
            case 151 /* Constructor */:
            case 227 /* FunctionDeclaration */:
            case 185 /* FunctionExpression */:
                return container;
        }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNextLowestExtensionPriority" id="apidoc.element.typescript.getNextLowestExtensionPriority">
        function <span class="apidocSignatureSpan">typescript.</span>getNextLowestExtensionPriority
        <span class="apidocSignatureSpan">(extensionPriority, supportedExtensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNextLowestExtensionPriority(extensionPriority, supportedExtensions) {
    if (extensionPriority &lt; 2 /* DeclarationAndJavaScriptFiles */) {
        return 2 /* DeclarationAndJavaScriptFiles */;
    }
    else {
        return supportedExtensions.length;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNodeId" id="apidoc.element.typescript.getNodeId">
        function <span class="apidocSignatureSpan">typescript.</span>getNodeId
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeId(node) {
    if (!node.id) {
        node.id = nextNodeId;
        nextNodeId++;
    }
    return node.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNodeKind" id="apidoc.element.typescript.getNodeKind">
        function <span class="apidocSignatureSpan">typescript.</span>getNodeKind
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeKind(node) {
    switch (node.kind) {
        case 263 /* SourceFile */:
            return ts.isExternalModule(node) ? ts.ScriptElementKind.moduleElement : ts.ScriptElementKind.scriptElement;
        case 232 /* ModuleDeclaration */:
            return ts.ScriptElementKind.moduleElement;
        case 228 /* ClassDeclaration */:
        case 198 /* ClassExpression */:
            return ts.ScriptElementKind.classElement;
        case 229 /* InterfaceDeclaration */: return ts.ScriptElementKind.interfaceElement;
        case 230 /* TypeAliasDeclaration */: return ts.ScriptElementKind.typeElement;
        case 231 /* EnumDeclaration */: return ts.ScriptElementKind.enumElement;
        case 225 /* VariableDeclaration */:
            return getKindOfVariableDeclaration(node);
        case 175 /* BindingElement */:
            return getKindOfVariableDeclaration(ts.getRootDeclaration(node));
        case 186 /* ArrowFunction */:
        case 227 /* FunctionDeclaration */:
        case 185 /* FunctionExpression */:
            return ts.ScriptElementKind.functionElement;
        case 152 /* GetAccessor */: return ts.ScriptElementKind.memberGetAccessorElement;
        case 153 /* SetAccessor */: return ts.ScriptElementKind.memberSetAccessorElement;
        case 150 /* MethodDeclaration */:
        case 149 /* MethodSignature */:
            return ts.ScriptElementKind.memberFunctionElement;
        case 148 /* PropertyDeclaration */:
        case 147 /* PropertySignature */:
            return ts.ScriptElementKind.memberVariableElement;
        case 156 /* IndexSignature */: return ts.ScriptElementKind.indexSignatureElement;
        case 155 /* ConstructSignature */: return ts.ScriptElementKind.constructSignatureElement;
        case 154 /* CallSignature */: return ts.ScriptElementKind.callSignatureElement;
        case 151 /* Constructor */: return ts.ScriptElementKind.constructorImplementationElement;
        case 144 /* TypeParameter */: return ts.ScriptElementKind.typeParameterElement;
        case 262 /* EnumMember */: return ts.ScriptElementKind.enumMemberElement;
        case 145 /* Parameter */: return ts.hasModifier(node, 92 /* ParameterPropertyModifier */) ? ts.ScriptElementKind.memberVariableElement
 : ts.ScriptElementKind.parameterElement;
        case 236 /* ImportEqualsDeclaration */:
        case 241 /* ImportSpecifier */:
        case 238 /* ImportClause */:
        case 245 /* ExportSpecifier */:
        case 239 /* NamespaceImport */:
            return ts.ScriptElementKind.alias;
        case 288 /* JSDocTypedefTag */:
            return ts.ScriptElementKind.typeElement;
        default:
            return ts.ScriptElementKind.unknown;
    }
    function getKindOfVariableDeclaration(v) {
        return ts.isConst(v)
            ? ts.ScriptElementKind.constElement
            : ts.isLet(v)
                ? ts.ScriptElementKind.letElement
                : ts.ScriptElementKind.variableElement;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNodeMajorVersion" id="apidoc.element.typescript.getNodeMajorVersion">
        function <span class="apidocSignatureSpan">typescript.</span>getNodeMajorVersion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeMajorVersion() {
    if (typeof process === "undefined") {
        return undefined;
    }
    var version = process.version;
    if (!version) {
        return undefined;
    }
    var dot = version.indexOf(".");
    if (dot === -1) {
        return undefined;
    }
    return parseInt(version.substring(1, dot));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNodeModifiers" id="apidoc.element.typescript.getNodeModifiers">
        function <span class="apidocSignatureSpan">typescript.</span>getNodeModifiers
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeModifiers(node) {
    var flags = ts.getCombinedModifierFlags(node);
    var result = [];
    if (flags &amp; 8 /* Private */)
        result.push(ts.ScriptElementKindModifier.privateMemberModifier);
    if (flags &amp; 16 /* Protected */)
        result.push(ts.ScriptElementKindModifier.protectedMemberModifier);
    if (flags &amp; 4 /* Public */)
        result.push(ts.ScriptElementKindModifier.publicMemberModifier);
    if (flags &amp; 32 /* Static */)
        result.push(ts.ScriptElementKindModifier.staticModifier);
    if (flags &amp; 128 /* Abstract */)
        result.push(ts.ScriptElementKindModifier.abstractModifier);
    if (flags &amp; 1 /* Export */)
        result.push(ts.ScriptElementKindModifier.exportedModifier);
    if (ts.isInAmbientContext(node))
        result.push(ts.ScriptElementKindModifier.ambientModifier);
    return result.length &gt; 0 ? result.join(",") : ts.ScriptElementKindModifier.none;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNonDecoratorTokenPosOfNode" id="apidoc.element.typescript.getNonDecoratorTokenPosOfNode">
        function <span class="apidocSignatureSpan">typescript.</span>getNonDecoratorTokenPosOfNode
        <span class="apidocSignatureSpan">(node, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNonDecoratorTokenPosOfNode(node, sourceFile) {
    if (nodeIsMissing(node) || !node.decorators) {
        return getTokenPosOfNode(node, sourceFile);
    }
    return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.decorators.end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNormalizedAbsolutePath" id="apidoc.element.typescript.getNormalizedAbsolutePath">
        function <span class="apidocSignatureSpan">typescript.</span>getNormalizedAbsolutePath
        <span class="apidocSignatureSpan">(fileName, currentDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNormalizedAbsolutePath(fileName, currentDirectory) {
    return getNormalizedPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNormalizedPathComponents" id="apidoc.element.typescript.getNormalizedPathComponents">
        function <span class="apidocSignatureSpan">typescript.</span>getNormalizedPathComponents
        <span class="apidocSignatureSpan">(path, currentDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNormalizedPathComponents(path, currentDirectory) {
    path = normalizeSlashes(path);
    var rootLength = getRootLength(path);
    if (rootLength === 0) {
        // If the path is not rooted it is relative to current directory
        path = combinePaths(normalizeSlashes(currentDirectory), path);
        rootLength = getRootLength(path);
    }
    return normalizedPathComponents(path, rootLength);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNormalizedPathFromPathComponents" id="apidoc.element.typescript.getNormalizedPathFromPathComponents">
        function <span class="apidocSignatureSpan">typescript.</span>getNormalizedPathFromPathComponents
        <span class="apidocSignatureSpan">(pathComponents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNormalizedPathFromPathComponents(pathComponents) {
    if (pathComponents &amp;&amp; pathComponents.length) {
        return pathComponents[0] + pathComponents.slice(1).join(ts.directorySeparator);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getNumericLiteralFlags" id="apidoc.element.typescript.getNumericLiteralFlags">
        function <span class="apidocSignatureSpan">typescript.</span>getNumericLiteralFlags
        <span class="apidocSignatureSpan">(text, hint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNumericLiteralFlags(text, hint) {
    if (text.length &gt; 1) {
        switch (text.charCodeAt(1)) {
            case 98 /* b */:
            case 66 /* B */:
                return 2 /* Binary */;
            case 111 /* o */:
            case 79 /* O */:
                return 4 /* Octal */;
            case 120 /* x */:
            case 88 /* X */:
                return 1 /* Hexadecimal */;
        }
        if (hint &amp; 8 /* Scientific */) {
            for (var i = text.length - 1; i &gt;= 0; i--) {
                switch (text.charCodeAt(i)) {
                    case 101 /* e */:
                    case 69 /* E */:
                        return 8 /* Scientific */;
                }
            }
        }
    }
    return 0 /* None */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOpenBraceEnd" id="apidoc.element.typescript.getOpenBraceEnd">
        function <span class="apidocSignatureSpan">typescript.</span>getOpenBraceEnd
        <span class="apidocSignatureSpan">(constructor, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOpenBraceEnd(constructor, sourceFile) {
    // First token is the open curly, this is where we want to put the 'super' call.
    return constructor.body.getFirstToken(sourceFile).getEnd();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOperator" id="apidoc.element.typescript.getOperator">
        function <span class="apidocSignatureSpan">typescript.</span>getOperator
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOperator(expression) {
    if (expression.kind === 193 /* BinaryExpression */) {
        return expression.operatorToken.kind;
    }
    else if (expression.kind === 191 /* PrefixUnaryExpression */ || expression.kind === 192 /* PostfixUnaryExpression */) {
        return expression.operator;
    }
    else {
        return expression.kind;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOperatorAssociativity" id="apidoc.element.typescript.getOperatorAssociativity">
        function <span class="apidocSignatureSpan">typescript.</span>getOperatorAssociativity
        <span class="apidocSignatureSpan">(kind, operator, hasArguments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOperatorAssociativity(kind, operator, hasArguments) {
    switch (kind) {
        case 181 /* NewExpression */:
            return hasArguments ? 0 /* Left */ : 1 /* Right */;
        case 191 /* PrefixUnaryExpression */:
        case 188 /* TypeOfExpression */:
        case 189 /* VoidExpression */:
        case 187 /* DeleteExpression */:
        case 190 /* AwaitExpression */:
        case 194 /* ConditionalExpression */:
        case 196 /* YieldExpression */:
            return 1 /* Right */;
        case 193 /* BinaryExpression */:
            switch (operator) {
                case 39 /* AsteriskAsteriskToken */:
                case 57 /* EqualsToken */:
                case 58 /* PlusEqualsToken */:
                case 59 /* MinusEqualsToken */:
                case 61 /* AsteriskAsteriskEqualsToken */:
                case 60 /* AsteriskEqualsToken */:
                case 62 /* SlashEqualsToken */:
                case 63 /* PercentEqualsToken */:
                case 64 /* LessThanLessThanEqualsToken */:
                case 65 /* GreaterThanGreaterThanEqualsToken */:
                case 66 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 67 /* AmpersandEqualsToken */:
                case 69 /* CaretEqualsToken */:
                case 68 /* BarEqualsToken */:
                    return 1 /* Right */;
            }
    }
    return 0 /* Left */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOperatorPrecedence" id="apidoc.element.typescript.getOperatorPrecedence">
        function <span class="apidocSignatureSpan">typescript.</span>getOperatorPrecedence
        <span class="apidocSignatureSpan">(nodeKind, operatorKind, hasArguments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOperatorPrecedence(nodeKind, operatorKind, hasArguments) {
    switch (nodeKind) {
        case 98 /* ThisKeyword */:
        case 96 /* SuperKeyword */:
        case 70 /* Identifier */:
        case 94 /* NullKeyword */:
        case 100 /* TrueKeyword */:
        case 85 /* FalseKeyword */:
        case 8 /* NumericLiteral */:
        case 9 /* StringLiteral */:
        case 176 /* ArrayLiteralExpression */:
        case 177 /* ObjectLiteralExpression */:
        case 185 /* FunctionExpression */:
        case 186 /* ArrowFunction */:
        case 198 /* ClassExpression */:
        case 248 /* JsxElement */:
        case 249 /* JsxSelfClosingElement */:
        case 11 /* RegularExpressionLiteral */:
        case 12 /* NoSubstitutionTemplateLiteral */:
        case 195 /* TemplateExpression */:
        case 184 /* ParenthesizedExpression */:
        case 199 /* OmittedExpression */:
            return 19;
        case 182 /* TaggedTemplateExpression */:
        case 178 /* PropertyAccessExpression */:
        case 179 /* ElementAccessExpression */:
            return 18;
        case 181 /* NewExpression */:
            return hasArguments ? 18 : 17;
        case 180 /* CallExpression */:
            return 17;
        case 192 /* PostfixUnaryExpression */:
            return 16;
        case 191 /* PrefixUnaryExpression */:
        case 188 /* TypeOfExpression */:
        case 189 /* VoidExpression */:
        case 187 /* DeleteExpression */:
        case 190 /* AwaitExpression */:
            return 15;
        case 193 /* BinaryExpression */:
            switch (operatorKind) {
                case 50 /* ExclamationToken */:
                case 51 /* TildeToken */:
                    return 15;
                case 39 /* AsteriskAsteriskToken */:
                case 38 /* AsteriskToken */:
                case 40 /* SlashToken */:
                case 41 /* PercentToken */:
                    return 14;
                case 36 /* PlusToken */:
                case 37 /* MinusToken */:
                    return 13;
                case 44 /* LessThanLessThanToken */:
                case 45 /* GreaterThanGreaterThanToken */:
                case 46 /* GreaterThanGreaterThanGreaterThanToken */:
                    return 12;
                case 26 /* LessThanToken */:
                case 29 /* LessThanEqualsToken */:
                case 28 /* GreaterThanToken */:
                case 30 /* GreaterThanEqualsToken */:
                case 91 /* InKeyword */:
                case 92 /* InstanceOfKeyword */:
                    return 11;
                case 31 /* EqualsEqualsToken */:
                case 33 /* EqualsEqualsEqualsToken */:
                case 32 /* ExclamationEqualsToken */:
                case 34 /* ExclamationEqualsEqualsToken */:
                    return 10;
                case 47 /* AmpersandToken */:
                    return 9;
                case 49 /* CaretToken */:
                    return 8;
                case 48 /* BarToken */:
                    return 7;
                case 52 /* AmpersandAmpersandToken */:
                    return 6;
                case 53 /* BarBarToken */:
                    return 5;
                case 57 /* EqualsToken */:
                case 58 /* PlusEqualsToken */:
                case 59 /* MinusEqualsToken */:
                case 61 /* AsteriskAsteriskEqualsToken */:
                case 60 /* AsteriskEqualsToken */:
                case 62 /* SlashEqualsToken */:
                case 63 /* PercentEqualsToken */:
                case 64 /* LessThanLessThanEqualsToken */:
                case 65 /* GreaterThanGreaterThanEqualsToken */:
                case 66 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 67 /* AmpersandEqualsToken */:
                case 69 /* CaretEqualsToken */:
                case 68 /* BarEqualsToken */:
                    return 3;
                case 25 /* CommaToken */:
                    return 0;
                default:
                    return -1;
            } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOptionNameMap" id="apidoc.element.typescript.getOptionNameMap">
        function <span class="apidocSignatureSpan">typescript.</span>getOptionNameMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOptionNameMap() {
    if (optionNameMapCache) {
        return optionNameMapCache;
    }
    var optionNameMap = ts.createMap();
    var shortOptionNames = ts.createMap();
    ts.forEach(ts.optionDeclarations, function (option) {
        optionNameMap.set(option.name.toLowerCase(), option);
        if (option.shortName) {
            shortOptionNames.set(option.shortName, option.name);
        }
    });
    optionNameMapCache = { optionNameMap: optionNameMap, shortOptionNames: shortOptionNames };
    return optionNameMapCache;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOrCreateEmitNode" id="apidoc.element.typescript.getOrCreateEmitNode">
        function <span class="apidocSignatureSpan">typescript.</span>getOrCreateEmitNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOrCreateEmitNode(node) {
    if (!node.emitNode) {
        if (ts.isParseTreeNode(node)) {
            // To avoid holding onto transformation artifacts, we keep track of any
            // parse tree node we are annotating. This allows us to clean them up after
            // all transformations have completed.
            if (node.kind === 263 /* SourceFile */) {
                return node.emitNode = { annotatedNodes: [node] };
            }
            var sourceFile = ts.getSourceFileOfNode(node);
            getOrCreateEmitNode(sourceFile).annotatedNodes.push(node);
        }
        node.emitNode = {};
    }
    return node.emitNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOrCreateExternalHelpersModuleNameIfNeeded" id="apidoc.element.typescript.getOrCreateExternalHelpersModuleNameIfNeeded">
        function <span class="apidocSignatureSpan">typescript.</span>getOrCreateExternalHelpersModuleNameIfNeeded
        <span class="apidocSignatureSpan">(node, compilerOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOrCreateExternalHelpersModuleNameIfNeeded(node, compilerOptions) {
    if (compilerOptions.importHelpers &amp;&amp; (ts.isExternalModule(node) || compilerOptions.isolatedModules)) {
        var externalHelpersModuleName = getExternalHelpersModuleName(node);
        if (externalHelpersModuleName) {
            return externalHelpersModuleName;
        }
        var helpers = ts.getEmitHelpers(node);
        if (helpers) {
            for (var _i = 0, helpers_2 = helpers; _i &lt; helpers_2.length; _i++) {
                var helper = helpers_2[_i];
                if (!helper.scoped) {
                    var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
                    var emitNode = ts.getOrCreateEmitNode(parseNode);
                    return emitNode.externalHelpersModuleName || (emitNode.externalHelpersModuleName = ts.createUniqueName(ts.externalHelpersModuleNameText
));
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOriginalNode" id="apidoc.element.typescript.getOriginalNode">
        function <span class="apidocSignatureSpan">typescript.</span>getOriginalNode
        <span class="apidocSignatureSpan">(node, nodeTest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOriginalNode(node, nodeTest) {
    if (node) {
        while (node.original !== undefined) {
            node = node.original;
        }
    }
    return !nodeTest || nodeTest(node) ? node : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOriginalNodeId" id="apidoc.element.typescript.getOriginalNodeId">
        function <span class="apidocSignatureSpan">typescript.</span>getOriginalNodeId
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOriginalNodeId(node) {
    node = ts.getOriginalNode(node);
    return node ? ts.getNodeId(node) : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOriginalSourceFileOrBundle" id="apidoc.element.typescript.getOriginalSourceFileOrBundle">
        function <span class="apidocSignatureSpan">typescript.</span>getOriginalSourceFileOrBundle
        <span class="apidocSignatureSpan">(sourceFileOrBundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOriginalSourceFileOrBundle(sourceFileOrBundle) {
    if (sourceFileOrBundle.kind === 264 /* Bundle */) {
        return ts.updateBundle(sourceFileOrBundle, ts.sameMap(sourceFileOrBundle.sourceFiles, getOriginalSourceFile));
    }
    return getOriginalSourceFile(sourceFileOrBundle);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOriginalSourceFiles" id="apidoc.element.typescript.getOriginalSourceFiles">
        function <span class="apidocSignatureSpan">typescript.</span>getOriginalSourceFiles
        <span class="apidocSignatureSpan">(sourceFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOriginalSourceFiles(sourceFiles) {
    return ts.sameMap(sourceFiles, getOriginalSourceFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOwnEmitOutputFilePath" id="apidoc.element.typescript.getOwnEmitOutputFilePath">
        function <span class="apidocSignatureSpan">typescript.</span>getOwnEmitOutputFilePath
        <span class="apidocSignatureSpan">(sourceFile, host, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOwnEmitOutputFilePath(sourceFile, host, extension) {
    var compilerOptions = host.getCompilerOptions();
    var emitOutputFilePathWithoutExtension;
    if (compilerOptions.outDir) {
        emitOutputFilePathWithoutExtension = ts.removeFileExtension(getSourceFilePathInNewDir(sourceFile, host, compilerOptions.
outDir));
    }
    else {
        emitOutputFilePathWithoutExtension = ts.removeFileExtension(sourceFile.fileName);
    }
    return emitOutputFilePathWithoutExtension + extension;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getOwnKeys" id="apidoc.element.typescript.getOwnKeys">
        function <span class="apidocSignatureSpan">typescript.</span>getOwnKeys
        <span class="apidocSignatureSpan">(map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOwnKeys(map) {
    var keys = [];
    for (var key in map)
        if (hasOwnProperty.call(map, key)) {
            keys.push(key);
        }
    return keys;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getParseTreeNode" id="apidoc.element.typescript.getParseTreeNode">
        function <span class="apidocSignatureSpan">typescript.</span>getParseTreeNode
        <span class="apidocSignatureSpan">(node, nodeTest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getParseTreeNode(node, nodeTest) {
    if (isParseTreeNode(node)) {
        return node;
    }
    node = getOriginalNode(node);
    if (isParseTreeNode(node) &amp;&amp; (!nodeTest || nodeTest(node))) {
        return node;
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getPositionOfLineAndCharacter" id="apidoc.element.typescript.getPositionOfLineAndCharacter">
        function <span class="apidocSignatureSpan">typescript.</span>getPositionOfLineAndCharacter
        <span class="apidocSignatureSpan">(sourceFile, line, character)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPositionOfLineAndCharacter(sourceFile, line, character) {
    return computePositionOfLineAndCharacter(getLineStarts(sourceFile), line, character);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getPreEmitDiagnostics" id="apidoc.element.typescript.getPreEmitDiagnostics">
        function <span class="apidocSignatureSpan">typescript.</span>getPreEmitDiagnostics
        <span class="apidocSignatureSpan">(program, sourceFile, cancellationToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPreEmitDiagnostics(program, sourceFile, cancellationToken) {
    var diagnostics = program.getOptionsDiagnostics(cancellationToken).concat(program.getSyntacticDiagnostics(sourceFile, cancellationToken
), program.getGlobalDiagnostics(cancellationToken), program.getSemanticDiagnostics(sourceFile, cancellationToken));
    if (program.getCompilerOptions().declaration) {
        diagnostics = diagnostics.concat(program.getDeclarationDiagnostics(sourceFile, cancellationToken));
    }
    return ts.sortAndDeduplicateDiagnostics(diagnostics);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getProperty" id="apidoc.element.typescript.getProperty">
        function <span class="apidocSignatureSpan">typescript.</span>getProperty
        <span class="apidocSignatureSpan">(map, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getProperty(map, key) {
    return hasOwnProperty.call(map, key) ? map[key] : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getPropertyNameForKnownSymbolName" id="apidoc.element.typescript.getPropertyNameForKnownSymbolName">
        function <span class="apidocSignatureSpan">typescript.</span>getPropertyNameForKnownSymbolName
        <span class="apidocSignatureSpan">(symbolName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPropertyNameForKnownSymbolName(symbolName) {
    return "__@" + symbolName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getPropertyNameForPropertyNameNode" id="apidoc.element.typescript.getPropertyNameForPropertyNameNode">
        function <span class="apidocSignatureSpan">typescript.</span>getPropertyNameForPropertyNameNode
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPropertyNameForPropertyNameNode(name) {
    if (name.kind === 70 /* Identifier */ || name.kind === 9 /* StringLiteral */ || name.kind === 8 /* NumericLiteral */ || name
.kind === 145 /* Parameter */) {
        return name.text;
    }
    if (name.kind === 143 /* ComputedPropertyName */) {
        var nameExpression = name.expression;
        if (isWellKnownSymbolSyntactically(nameExpression)) {
            var rightHandSideName = nameExpression.name.text;
            return getPropertyNameForKnownSymbolName(rightHandSideName);
        }
        else if (nameExpression.kind === 9 /* StringLiteral */ || nameExpression.kind === 8 /* NumericLiteral */) {
            return nameExpression.text;
        }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getPropertyNameOfBindingOrAssignmentElement" id="apidoc.element.typescript.getPropertyNameOfBindingOrAssignmentElement">
        function <span class="apidocSignatureSpan">typescript.</span>getPropertyNameOfBindingOrAssignmentElement
        <span class="apidocSignatureSpan">(bindingElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPropertyNameOfBindingOrAssignmentElement(bindingElement) {
    switch (bindingElement.kind) {
        case 175 /* BindingElement */:
            // `a` in `let { a: b } = ...`
            // `[a]` in `let { [a]: b } = ...`
            // `"a"` in `let { "a": b } = ...`
            // `1` in `let { 1: b } = ...`
            if (bindingElement.propertyName) {
                var propertyName = bindingElement.propertyName;
                return ts.isComputedPropertyName(propertyName) &amp;&amp; ts.isStringOrNumericLiteral(propertyName.expression)
                    ? propertyName.expression
                    : propertyName;
            }
            break;
        case 259 /* PropertyAssignment */:
            // `a` in `({ a: b } = ...)`
            // `[a]` in `({ [a]: b } = ...)`
            // `"a"` in `({ "a": b } = ...)`
            // `1` in `({ 1: b } = ...)`
            if (bindingElement.name) {
                var propertyName = bindingElement.name;
                return ts.isComputedPropertyName(propertyName) &amp;&amp; ts.isStringOrNumericLiteral(propertyName.expression)
                    ? propertyName.expression
                    : propertyName;
            }
            break;
        case 261 /* SpreadAssignment */:
            // `a` in `({ ...a } = ...)`
            return bindingElement.name;
    }
    var target = getTargetOfBindingOrAssignmentElement(bindingElement);
    if (target &amp;&amp; ts.isPropertyName(target)) {
        return ts.isComputedPropertyName(target) &amp;&amp; ts.isStringOrNumericLiteral(target.expression)
            ? target.expression
            : target;
    }
    ts.Debug.fail("Invalid property name for binding element.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getRangeEnd" id="apidoc.element.typescript.getRangeEnd">
        function <span class="apidocSignatureSpan">typescript.</span>getRangeEnd
        <span class="apidocSignatureSpan">(range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRangeEnd(range) {
    return range ? range.end : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getRangePos" id="apidoc.element.typescript.getRangePos">
        function <span class="apidocSignatureSpan">typescript.</span>getRangePos
        <span class="apidocSignatureSpan">(range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRangePos(range) {
    return range ? range.pos : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getRegularExpressionForWildcard" id="apidoc.element.typescript.getRegularExpressionForWildcard">
        function <span class="apidocSignatureSpan">typescript.</span>getRegularExpressionForWildcard
        <span class="apidocSignatureSpan">(specs, basePath, usage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRegularExpressionForWildcard(specs, basePath, usage) {
    var patterns = getRegularExpressionsForWildcards(specs, basePath, usage);
    if (!patterns || !patterns.length) {
        return undefined;
    }
    var pattern = patterns.map(function (pattern) { return "(" + pattern + ")"; }).join("|");
    // If excluding, match "foo/bar/baz...", but if including, only allow "foo".
    var terminator = usage === "exclude" ? "($|/)" : "$";
    return "^(" + pattern + ")" + terminator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getRelativePathToDirectoryOrUrl" id="apidoc.element.typescript.getRelativePathToDirectoryOrUrl">
        function <span class="apidocSignatureSpan">typescript.</span>getRelativePathToDirectoryOrUrl
        <span class="apidocSignatureSpan">(directoryPathOrUrl, relativeOrAbsolutePath, currentDirectory, getCanonicalFileName, isAbsolutePathAnUrl )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRelativePathToDirectoryOrUrl(directoryPathOrUrl, relativeOrAbsolutePath, currentDirectory, getCanonicalFileName, isAbsolutePathAnUrl ) {
    var pathComponents = getNormalizedPathOrUrlComponents(relativeOrAbsolutePath, currentDirectory);
    var directoryComponents = getNormalizedPathOrUrlComponents(directoryPathOrUrl, currentDirectory);
    if (directoryComponents.length &gt; 1 &amp;&amp; lastOrUndefined(directoryComponents) === "") {
        // If the directory path given was of type test/cases/ then we really need components of directory to be only till its name
        // that is  ["test", "cases", ""] needs to be actually ["test", "cases"]
        directoryComponents.length--;
    }
    // Find the component that differs
    var joinStartIndex;
    for (joinStartIndex = 0; joinStartIndex &lt; pathComponents.length &amp;&amp; joinStartIndex &lt; directoryComponents.length; joinStartIndex
++) {
        if (getCanonicalFileName(directoryComponents[joinStartIndex]) !== getCanonicalFileName(pathComponents[joinStartIndex])) {
            break;
        }
    }
    // Get the relative path
    if (joinStartIndex) {
        var relativePath = "";
        var relativePathComponents = pathComponents.slice(joinStartIndex, pathComponents.length);
        for (; joinStartIndex &lt; directoryComponents.length; joinStartIndex++) {
            if (directoryComponents[joinStartIndex] !== "") {
                relativePath = relativePath + ".." + ts.directorySeparator;
            }
        }
        return relativePath + relativePathComponents.join(ts.directorySeparator);
    }
    // Cant find the relative path, get the absolute path
    var absolutePath = getNormalizedPathFromPathComponents(pathComponents);
    if (isAbsolutePathAnUrl &amp;&amp; isRootedDiskPath(absolutePath)) {
        absolutePath = "file:///" + absolutePath;
    }
    return absolutePath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getResolutionDiagnostic" id="apidoc.element.typescript.getResolutionDiagnostic">
        function <span class="apidocSignatureSpan">typescript.</span>getResolutionDiagnostic
        <span class="apidocSignatureSpan">(options, _a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getResolutionDiagnostic(options, _a) {
    var extension = _a.extension;
    switch (extension) {
        case ts.Extension.Ts:
        case ts.Extension.Dts:
            // These are always allowed.
            return undefined;
        case ts.Extension.Tsx:
            return needJsx();
        case ts.Extension.Jsx:
            return needJsx() || needAllowJs();
        case ts.Extension.Js:
            return needAllowJs();
    }
    function needJsx() {
        return options.jsx ? undefined : ts.Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set;
    }
    function needAllowJs() {
        return options.allowJs ? undefined : ts.Diagnostics.Module_0_was_resolved_to_1_but_allowJs_is_not_set;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getResolvedExternalModuleName" id="apidoc.element.typescript.getResolvedExternalModuleName">
        function <span class="apidocSignatureSpan">typescript.</span>getResolvedExternalModuleName
        <span class="apidocSignatureSpan">(host, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getResolvedExternalModuleName(host, file) {
    return file.moduleName || getExternalModuleNameFromPath(host, file.fileName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getResolvedModule" id="apidoc.element.typescript.getResolvedModule">
        function <span class="apidocSignatureSpan">typescript.</span>getResolvedModule
        <span class="apidocSignatureSpan">(sourceFile, moduleNameText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getResolvedModule(sourceFile, moduleNameText) {
    return hasResolvedModule(sourceFile, moduleNameText) ? sourceFile.resolvedModules.get(moduleNameText) : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getRestIndicatorOfBindingOrAssignmentElement" id="apidoc.element.typescript.getRestIndicatorOfBindingOrAssignmentElement">
        function <span class="apidocSignatureSpan">typescript.</span>getRestIndicatorOfBindingOrAssignmentElement
        <span class="apidocSignatureSpan">(bindingElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRestIndicatorOfBindingOrAssignmentElement(bindingElement) {
    switch (bindingElement.kind) {
        case 145 /* Parameter */:
        case 175 /* BindingElement */:
            // `...` in `let [...a] = ...`
            return bindingElement.dotDotDotToken;
        case 197 /* SpreadElement */:
        case 261 /* SpreadAssignment */:
            // `...` in `[...a] = ...`
            return bindingElement;
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getRestParameterElementType" id="apidoc.element.typescript.getRestParameterElementType">
        function <span class="apidocSignatureSpan">typescript.</span>getRestParameterElementType
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRestParameterElementType(node) {
    if (node &amp;&amp; node.kind === 163 /* ArrayType */) {
        return node.elementType;
    }
    else if (node &amp;&amp; node.kind === 158 /* TypeReference */) {
        return ts.singleOrUndefined(node.typeArguments);
    }
    else {
        return undefined;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getRootDeclaration" id="apidoc.element.typescript.getRootDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>getRootDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRootDeclaration(node) {
    while (node.kind === 175 /* BindingElement */) {
        node = node.parent.parent;
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getRootLength" id="apidoc.element.typescript.getRootLength">
        function <span class="apidocSignatureSpan">typescript.</span>getRootLength
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRootLength(path) {
    if (path.charCodeAt(0) === 47 /* slash */) {
        if (path.charCodeAt(1) !== 47 /* slash */)
            return 1;
        var p1 = path.indexOf("/", 2);
        if (p1 &lt; 0)
            return 2;
        var p2 = path.indexOf("/", p1 + 1);
        if (p2 &lt; 0)
            return p1 + 1;
        return p2 + 1;
    }
    if (path.charCodeAt(1) === 58 /* colon */) {
        if (path.charCodeAt(2) === 47 /* slash */)
            return 3;
        return 2;
    }
    // Per RFC 1738 'file' URI schema has the shape file://&lt;host&gt;/&lt;path&gt;
    // if &lt;host&gt; is omitted then it is assumed that host value is 'localhost',
    // however slash after the omitted &lt;host&gt; is not removed.
    // file:///folder1/file1 - this is a correct URI
    // file://folder2/file2 - this is an incorrect URI
    if (path.lastIndexOf("file:///", 0) === 0) {
        return "file:///".length;
    }
    var idx = path.indexOf("://");
    if (idx !== -1) {
        return idx + "://".length;
    }
    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getScriptKind" id="apidoc.element.typescript.getScriptKind">
        function <span class="apidocSignatureSpan">typescript.</span>getScriptKind
        <span class="apidocSignatureSpan">(fileName, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getScriptKind(fileName, host) {
    // First check to see if the script kind was specified by the host. Chances are the host
    // may override the default script kind for the file extension.
    var scriptKind;
    if (host &amp;&amp; host.getScriptKind) {
        scriptKind = host.getScriptKind(fileName);
    }
    if (!scriptKind) {
        scriptKind = ts.getScriptKindFromFileName(fileName);
    }
    return ts.ensureScriptKind(fileName, scriptKind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getScriptKindFromFileName" id="apidoc.element.typescript.getScriptKindFromFileName">
        function <span class="apidocSignatureSpan">typescript.</span>getScriptKindFromFileName
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getScriptKindFromFileName(fileName) {
    var ext = fileName.substr(fileName.lastIndexOf("."));
    switch (ext.toLowerCase()) {
        case ".js":
            return 1 /* JS */;
        case ".jsx":
            return 2 /* JSX */;
        case ".ts":
            return 3 /* TS */;
        case ".tsx":
            return 4 /* TSX */;
        default:
            return 0 /* Unknown */;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSemanticClassifications" id="apidoc.element.typescript.getSemanticClassifications">
        function <span class="apidocSignatureSpan">typescript.</span>getSemanticClassifications
        <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFile, classifiableNames, span)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
    return convertClassifications(getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames
, span));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSetAccessorTypeAnnotationNode" id="apidoc.element.typescript.getSetAccessorTypeAnnotationNode">
        function <span class="apidocSignatureSpan">typescript.</span>getSetAccessorTypeAnnotationNode
        <span class="apidocSignatureSpan">(accessor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSetAccessorTypeAnnotationNode(accessor) {
    if (accessor &amp;&amp; accessor.parameters.length &gt; 0) {
        var hasThis = accessor.parameters.length === 2 &amp;&amp; parameterIsThisKeyword(accessor.parameters[0]);
        return accessor.parameters[hasThis ? 1 : 0].type;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getShebang" id="apidoc.element.typescript.getShebang">
        function <span class="apidocSignatureSpan">typescript.</span>getShebang
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getShebang(text) {
    return shebangTriviaRegex.test(text)
        ? shebangTriviaRegex.exec(text)[0]
        : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSingleLineStringWriter" id="apidoc.element.typescript.getSingleLineStringWriter">
        function <span class="apidocSignatureSpan">typescript.</span>getSingleLineStringWriter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSingleLineStringWriter() {
    if (stringWriters.length === 0) {
        var str_1 = "";
        var writeText = function (text) { return str_1 += text; };
        return {
            string: function () { return str_1; },
            writeKeyword: writeText,
            writeOperator: writeText,
            writePunctuation: writeText,
            writeSpace: writeText,
            writeStringLiteral: writeText,
            writeParameter: writeText,
            writeProperty: writeText,
            writeSymbol: writeText,
            // Completely ignore indentation for string writers.  And map newlines to
            // a single space.
            writeLine: function () { return str_1 += " "; },
            increaseIndent: ts.noop,
            decreaseIndent: ts.noop,
            clear: function () { return str_1 = ""; },
            trackSymbol: ts.noop,
            reportInaccessibleThisError: ts.noop,
            reportIllegalExtends: ts.noop
        };
    }
    return stringWriters.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSourceFileOfNode" id="apidoc.element.typescript.getSourceFileOfNode">
        function <span class="apidocSignatureSpan">typescript.</span>getSourceFileOfNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSourceFileOfNode(node) {
    while (node &amp;&amp; node.kind !== 263 /* SourceFile */) {
        node = node.parent;
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSourceFilePathInNewDir" id="apidoc.element.typescript.getSourceFilePathInNewDir">
        function <span class="apidocSignatureSpan">typescript.</span>getSourceFilePathInNewDir
        <span class="apidocSignatureSpan">(sourceFile, host, newDirPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSourceFilePathInNewDir(sourceFile, host, newDirPath) {
    var sourceFilePath = ts.getNormalizedAbsolutePath(sourceFile.fileName, host.getCurrentDirectory());
    var commonSourceDirectory = host.getCommonSourceDirectory();
    var isSourceFileInCommonSourceDirectory = host.getCanonicalFileName(sourceFilePath).indexOf(host.getCanonicalFileName(commonSourceDirectory
)) === 0;
    sourceFilePath = isSourceFileInCommonSourceDirectory ? sourceFilePath.substring(commonSourceDirectory.length) : sourceFilePath
;
    return ts.combinePaths(newDirPath, sourceFilePath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSourceFilesToEmit" id="apidoc.element.typescript.getSourceFilesToEmit">
        function <span class="apidocSignatureSpan">typescript.</span>getSourceFilesToEmit
        <span class="apidocSignatureSpan">(host, targetSourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSourceFilesToEmit(host, targetSourceFile) {
    var options = host.getCompilerOptions();
    var isSourceFileFromExternalLibrary = function (file) { return host.isSourceFileFromExternalLibrary(file); };
    if (options.outFile || options.out) {
        var moduleKind = ts.getEmitModuleKind(options);
        var moduleEmitEnabled_1 = moduleKind === ts.ModuleKind.AMD || moduleKind === ts.ModuleKind.System;
        // Can emit only sources that are not declaration file and are either non module code or module with --module or --target
 es6 specified
        return ts.filter(host.getSourceFiles(), function (sourceFile) {
            return (moduleEmitEnabled_1 || !ts.isExternalModule(sourceFile)) &amp;&amp; sourceFileMayBeEmitted(sourceFile, options, isSourceFileFromExternalLibrary
);
        });
    }
    else {
        var sourceFiles = targetSourceFile === undefined ? host.getSourceFiles() : [targetSourceFile];
        return ts.filter(sourceFiles, function (sourceFile) { return sourceFileMayBeEmitted(sourceFile, options, isSourceFileFromExternalLibrary
); });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSourceMapRange" id="apidoc.element.typescript.getSourceMapRange">
        function <span class="apidocSignatureSpan">typescript.</span>getSourceMapRange
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSourceMapRange(node) {
    var emitNode = node.emitNode;
    return (emitNode &amp;&amp; emitNode.sourceMapRange) || node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSourceTextOfNodeFromSourceFile" id="apidoc.element.typescript.getSourceTextOfNodeFromSourceFile">
        function <span class="apidocSignatureSpan">typescript.</span>getSourceTextOfNodeFromSourceFile
        <span class="apidocSignatureSpan">(sourceFile, node, includeTrivia)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSourceTextOfNodeFromSourceFile(sourceFile, node, includeTrivia) {
    if (includeTrivia === void 0) { includeTrivia = false; }
    if (nodeIsMissing(node)) {
        return "";
    }
    var text = sourceFile.text;
    return text.substring(includeTrivia ? node.pos : ts.skipTrivia(text, node.pos), node.end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSpanOfTokenAtPosition" id="apidoc.element.typescript.getSpanOfTokenAtPosition">
        function <span class="apidocSignatureSpan">typescript.</span>getSpanOfTokenAtPosition
        <span class="apidocSignatureSpan">(sourceFile, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSpanOfTokenAtPosition(sourceFile, pos) {
    var scanner = ts.createScanner(sourceFile.languageVersion, /*skipTrivia*/ true, sourceFile.languageVariant, sourceFile.text, /*
onError:*/ undefined, pos);
    scanner.scan();
    var start = scanner.getTokenPos();
    return ts.createTextSpanFromBounds(start, scanner.getTextPos());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSpecialPropertyAssignmentKind" id="apidoc.element.typescript.getSpecialPropertyAssignmentKind">
        function <span class="apidocSignatureSpan">typescript.</span>getSpecialPropertyAssignmentKind
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSpecialPropertyAssignmentKind(expression) {
    if (!isInJavaScriptFile(expression)) {
        return 0 /* None */;
    }
    if (expression.kind !== 193 /* BinaryExpression */) {
        return 0 /* None */;
    }
    var expr = expression;
    if (expr.operatorToken.kind !== 57 /* EqualsToken */ || expr.left.kind !== 178 /* PropertyAccessExpression */) {
        return 0 /* None */;
    }
    var lhs = expr.left;
    if (lhs.expression.kind === 70 /* Identifier */) {
        var lhsId = lhs.expression;
        if (lhsId.text === "exports") {
            // exports.name = expr
            return 1 /* ExportsProperty */;
        }
        else if (lhsId.text === "module" &amp;&amp; lhs.name.text === "exports") {
            // module.exports = expr
            return 2 /* ModuleExports */;
        }
    }
    else if (lhs.expression.kind === 98 /* ThisKeyword */) {
        return 4 /* ThisProperty */;
    }
    else if (lhs.expression.kind === 178 /* PropertyAccessExpression */) {
        // chained dot, e.g. x.y.z = expr; this var is the 'x.y' part
        var innerPropertyAccess = lhs.expression;
        if (innerPropertyAccess.expression.kind === 70 /* Identifier */) {
            // module.exports.name = expr
            var innerPropertyAccessIdentifier = innerPropertyAccess.expression;
            if (innerPropertyAccessIdentifier.text === "module" &amp;&amp; innerPropertyAccess.name.text === "exports") {
                return 1 /* ExportsProperty */;
            }
            if (innerPropertyAccess.name.text === "prototype") {
                return 3 /* PrototypeProperty */;
            }
        }
    }
    return 0 /* None */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getStartPosOfNode" id="apidoc.element.typescript.getStartPosOfNode">
        function <span class="apidocSignatureSpan">typescript.</span>getStartPosOfNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStartPosOfNode(node) {
    return node.pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getStartPositionOfLine" id="apidoc.element.typescript.getStartPositionOfLine">
        function <span class="apidocSignatureSpan">typescript.</span>getStartPositionOfLine
        <span class="apidocSignatureSpan">(line, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStartPositionOfLine(line, sourceFile) {
    ts.Debug.assert(line &gt;= 0);
    return ts.getLineStarts(sourceFile)[line];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getStartPositionOfRange" id="apidoc.element.typescript.getStartPositionOfRange">
        function <span class="apidocSignatureSpan">typescript.</span>getStartPositionOfRange
        <span class="apidocSignatureSpan">(range, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStartPositionOfRange(range, sourceFile) {
    return ts.positionIsSynthesized(range.pos) ? -1 : ts.skipTrivia(sourceFile.text, range.pos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getStringLiteralTypeForNode" id="apidoc.element.typescript.getStringLiteralTypeForNode">
        function <span class="apidocSignatureSpan">typescript.</span>getStringLiteralTypeForNode
        <span class="apidocSignatureSpan">(node, typeChecker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStringLiteralTypeForNode(node, typeChecker) {
    var searchNode = node.parent.kind === 172 /* LiteralType */ ? node.parent : node;
    var type = typeChecker.getTypeAtLocation(searchNode);
    if (type &amp;&amp; type.flags &amp; 32 /* StringLiteral */) {
        return type;
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSuperContainer" id="apidoc.element.typescript.getSuperContainer">
        function <span class="apidocSignatureSpan">typescript.</span>getSuperContainer
        <span class="apidocSignatureSpan">(node, stopOnFunctions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSuperContainer(node, stopOnFunctions) {
    while (true) {
        node = node.parent;
        if (!node) {
            return node;
        }
        switch (node.kind) {
            case 143 /* ComputedPropertyName */:
                node = node.parent;
                break;
            case 227 /* FunctionDeclaration */:
            case 185 /* FunctionExpression */:
            case 186 /* ArrowFunction */:
                if (!stopOnFunctions) {
                    continue;
                }
            case 148 /* PropertyDeclaration */:
            case 147 /* PropertySignature */:
            case 150 /* MethodDeclaration */:
            case 149 /* MethodSignature */:
            case 151 /* Constructor */:
            case 152 /* GetAccessor */:
            case 153 /* SetAccessor */:
                return node;
            case 146 /* Decorator */:
                // Decorators are always applied outside of the body of a class or method.
                if (node.parent.kind === 145 /* Parameter */ &amp;&amp; isClassElement(node.parent.parent)) {
                    // If the decorator's parent is a Parameter, we resolve the this container from
                    // the grandparent class declaration.
                    node = node.parent.parent;
                }
                else if (isClassElement(node.parent)) {
                    // If the decorator's parent is a class element, we resolve the 'this' container
                    // from the parent class declaration.
                    node = node.parent;
                }
                break;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSupportedCodeFixes" id="apidoc.element.typescript.getSupportedCodeFixes">
        function <span class="apidocSignatureSpan">typescript.</span>getSupportedCodeFixes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSupportedCodeFixes() {
    return ts.codefix.getSupportedErrorCodes();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSupportedExtensions" id="apidoc.element.typescript.getSupportedExtensions">
        function <span class="apidocSignatureSpan">typescript.</span>getSupportedExtensions
        <span class="apidocSignatureSpan">(options, extraFileExtensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSupportedExtensions(options, extraFileExtensions) {
    var needAllExtensions = options &amp;&amp; options.allowJs;
    if (!extraFileExtensions || extraFileExtensions.length === 0 || !needAllExtensions) {
        return needAllExtensions ? allSupportedExtensions : ts.supportedTypeScriptExtensions;
    }
    var extensions = allSupportedExtensions.slice(0);
    for (var _i = 0, extraFileExtensions_1 = extraFileExtensions; _i &lt; extraFileExtensions_1.length; _i++) {
        var extInfo = extraFileExtensions_1[_i];
        if (extensions.indexOf(extInfo.extension) === -1) {
            extensions.push(extInfo.extension);
        }
    }
    return extensions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSymbolId" id="apidoc.element.typescript.getSymbolId">
        function <span class="apidocSignatureSpan">typescript.</span>getSymbolId
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSymbolId(symbol) {
    if (!symbol.id) {
        symbol.id = nextSymbolId;
        nextSymbolId++;
    }
    return symbol.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSyntacticClassifications" id="apidoc.element.typescript.getSyntacticClassifications">
        function <span class="apidocSignatureSpan">typescript.</span>getSyntacticClassifications
        <span class="apidocSignatureSpan">(cancellationToken, sourceFile, span)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSyntacticClassifications(cancellationToken, sourceFile, span) {
    return convertClassifications(getEncodedSyntacticClassifications(cancellationToken, sourceFile, span));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getSynthesizedClone" id="apidoc.element.typescript.getSynthesizedClone">
        function <span class="apidocSignatureSpan">typescript.</span>getSynthesizedClone
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSynthesizedClone(node) {
    // We don't use "clone" from core.ts here, as we need to preserve the prototype chain of
    // the original node. We also need to exclude specific properties and only include own-
    // properties (to skip members already defined on the shared prototype).
    var clone = createSynthesizedNode(node.kind);
    clone.flags |= node.flags;
    setOriginalNode(clone, node);
    for (var key in node) {
        if (clone.hasOwnProperty(key) || !node.hasOwnProperty(key)) {
            continue;
        }
        clone[key] = node[key];
    }
    return clone;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTargetLabel" id="apidoc.element.typescript.getTargetLabel">
        function <span class="apidocSignatureSpan">typescript.</span>getTargetLabel
        <span class="apidocSignatureSpan">(referenceNode, labelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTargetLabel(referenceNode, labelName) {
    while (referenceNode) {
        if (referenceNode.kind === 221 /* LabeledStatement */ &amp;&amp; referenceNode.label.text === labelName) {
            return referenceNode.label;
        }
        referenceNode = referenceNode.parent;
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTargetOfBindingOrAssignmentElement" id="apidoc.element.typescript.getTargetOfBindingOrAssignmentElement">
        function <span class="apidocSignatureSpan">typescript.</span>getTargetOfBindingOrAssignmentElement
        <span class="apidocSignatureSpan">(bindingElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTargetOfBindingOrAssignmentElement(bindingElement) {
    if (ts.isDeclarationBindingElement(bindingElement)) {
        // `a` in `let { a } = ...`
        // `a` in `let { a = 1 } = ...`
        // `b` in `let { a: b } = ...`
        // `b` in `let { a: b = 1 } = ...`
        // `a` in `let { ...a } = ...`
        // `{b}` in `let { a: {b} } = ...`
        // `{b}` in `let { a: {b} = 1 } = ...`
        // `[b]` in `let { a: [b] } = ...`
        // `[b]` in `let { a: [b] = 1 } = ...`
        // `a` in `let [a] = ...`
        // `a` in `let [a = 1] = ...`
        // `a` in `let [...a] = ...`
        // `{a}` in `let [{a}] = ...`
        // `{a}` in `let [{a} = 1] = ...`
        // `[a]` in `let [[a]] = ...`
        // `[a]` in `let [[a] = 1] = ...`
        return bindingElement.name;
    }
    if (ts.isObjectLiteralElementLike(bindingElement)) {
        switch (bindingElement.kind) {
            case 259 /* PropertyAssignment */:
                // `b` in `({ a: b } = ...)`
                // `b` in `({ a: b = 1 } = ...)`
                // `{b}` in `({ a: {b} } = ...)`
                // `{b}` in `({ a: {b} = 1 } = ...)`
                // `[b]` in `({ a: [b] } = ...)`
                // `[b]` in `({ a: [b] = 1 } = ...)`
                // `b.c` in `({ a: b.c } = ...)`
                // `b.c` in `({ a: b.c = 1 } = ...)`
                // `b[0]` in `({ a: b[0] } = ...)`
                // `b[0]` in `({ a: b[0] = 1 } = ...)`
                return getTargetOfBindingOrAssignmentElement(bindingElement.initializer);
            case 260 /* ShorthandPropertyAssignment */:
                // `a` in `({ a } = ...)`
                // `a` in `({ a = 1 } = ...)`
                return bindingElement.name;
            case 261 /* SpreadAssignment */:
                // `a` in `({ ...a } = ...)`
                return getTargetOfBindingOrAssignmentElement(bindingElement.expression);
        }
        // no target
        return undefined;
    }
    if (ts.isAssignmentExpression(bindingElement, /*excludeCompoundAssignment*/ true)) {
        // `a` in `[a = 1] = ...`
        // `{a}` in `[{a} = 1] = ...`
        // `[a]` in `[[a] = 1] = ...`
        // `a.b` in `[a.b = 1] = ...`
        // `a[0]` in `[a[0] = 1] = ...`
        return getTargetOfBindingOrAssignmentElement(bindingElement.left);
    }
    if (ts.isSpreadExpression(bindingElement)) {
        // `a` in `[...a] = ...`
        return getTargetOfBindingOrAssignmentElement(bindingElement.expression);
    }
    // `a` in `[a] = ...`
    // `{a}` in `[{a}] = ...`
    // `[a]` in `[[a]] = ...`
    // `a.b` in `[a.b] = ...`
    // `a[0]` in `[a[0]] = ...`
    return bindingElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTextOfNode" id="apidoc.element.typescript.getTextOfNode">
        function <span class="apidocSignatureSpan">typescript.</span>getTextOfNode
        <span class="apidocSignatureSpan">(node, includeTrivia)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTextOfNode(node, includeTrivia) {
    if (includeTrivia === void 0) { includeTrivia = false; }
    return getSourceTextOfNodeFromSourceFile(getSourceFileOfNode(node), node, includeTrivia);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTextOfNodeFromSourceText" id="apidoc.element.typescript.getTextOfNodeFromSourceText">
        function <span class="apidocSignatureSpan">typescript.</span>getTextOfNodeFromSourceText
        <span class="apidocSignatureSpan">(sourceText, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTextOfNodeFromSourceText(sourceText, node) {
    if (nodeIsMissing(node)) {
        return "";
    }
    return sourceText.substring(ts.skipTrivia(sourceText, node.pos), node.end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTextOfPropertyName" id="apidoc.element.typescript.getTextOfPropertyName">
        function <span class="apidocSignatureSpan">typescript.</span>getTextOfPropertyName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTextOfPropertyName(name) {
    switch (name.kind) {
        case 70 /* Identifier */:
            return name.text;
        case 9 /* StringLiteral */:
        case 8 /* NumericLiteral */:
            return name.text;
        case 143 /* ComputedPropertyName */:
            if (isStringOrNumericLiteral(name.expression)) {
                return name.expression.text;
            }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getThisContainer" id="apidoc.element.typescript.getThisContainer">
        function <span class="apidocSignatureSpan">typescript.</span>getThisContainer
        <span class="apidocSignatureSpan">(node, includeArrowFunctions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getThisContainer(node, includeArrowFunctions) {
    while (true) {
        node = node.parent;
        if (!node) {
            return undefined;
        }
        switch (node.kind) {
            case 143 /* ComputedPropertyName */:
                // If the grandparent node is an object literal (as opposed to a class),
                // then the computed property is not a 'this' container.
                // A computed property name in a class needs to be a this container
                // so that we can error on it.
                if (isClassLike(node.parent.parent)) {
                    return node;
                }
                // If this is a computed property, then the parent should not
                // make it a this container. The parent might be a property
                // in an object literal, like a method or accessor. But in order for
                // such a parent to be a this container, the reference must be in
                // the *body* of the container.
                node = node.parent;
                break;
            case 146 /* Decorator */:
                // Decorators are always applied outside of the body of a class or method.
                if (node.parent.kind === 145 /* Parameter */ &amp;&amp; isClassElement(node.parent.parent)) {
                    // If the decorator's parent is a Parameter, we resolve the this container from
                    // the grandparent class declaration.
                    node = node.parent.parent;
                }
                else if (isClassElement(node.parent)) {
                    // If the decorator's parent is a class element, we resolve the 'this' container
                    // from the parent class declaration.
                    node = node.parent;
                }
                break;
            case 186 /* ArrowFunction */:
                if (!includeArrowFunctions) {
                    continue;
                }
            // Fall through
            case 227 /* FunctionDeclaration */:
            case 185 /* FunctionExpression */:
            case 232 /* ModuleDeclaration */:
            case 148 /* PropertyDeclaration */:
            case 147 /* PropertySignature */:
            case 150 /* MethodDeclaration */:
            case 149 /* MethodSignature */:
            case 151 /* Constructor */:
            case 152 /* GetAccessor */:
            case 153 /* SetAccessor */:
            case 154 /* CallSignature */:
            case 155 /* ConstructSignature */:
            case 156 /* IndexSignature */:
            case 231 /* EnumDeclaration */:
            case 263 /* SourceFile */:
                return node;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getThisParameter" id="apidoc.element.typescript.getThisParameter">
        function <span class="apidocSignatureSpan">typescript.</span>getThisParameter
        <span class="apidocSignatureSpan">(signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getThisParameter(signature) {
    if (signature.parameters.length) {
        var thisParameter = signature.parameters[0];
        if (parameterIsThisKeyword(thisParameter)) {
            return thisParameter;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTokenAtPosition" id="apidoc.element.typescript.getTokenAtPosition">
        function <span class="apidocSignatureSpan">typescript.</span>getTokenAtPosition
        <span class="apidocSignatureSpan">(sourceFile, position, includeJsDocComment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTokenAtPosition(sourceFile, position, includeJsDocComment) {
    if (includeJsDocComment === void 0) { includeJsDocComment = false; }
    return getTokenAtPositionWorker(sourceFile, position, /*allowPositionInLeadingTrivia*/ true, /*includeItemAtEndPosition*/ undefined
, includeJsDocComment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTokenPosOfNode" id="apidoc.element.typescript.getTokenPosOfNode">
        function <span class="apidocSignatureSpan">typescript.</span>getTokenPosOfNode
        <span class="apidocSignatureSpan">(node, sourceFile, includeJsDoc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTokenPosOfNode(node, sourceFile, includeJsDoc) {
    // With nodes that have no width (i.e. 'Missing' nodes), we actually *don't*
    // want to skip trivia because this will launch us forward to the next token.
    if (nodeIsMissing(node)) {
        return node.pos;
    }
    if (isJSDocNode(node)) {
        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos, /*stopAfterLineBreak*/ false, /*stopAtComments
*/ true);
    }
    if (includeJsDoc &amp;&amp; node.jsDoc &amp;&amp; node.jsDoc.length &gt; 0) {
        return getTokenPosOfNode(node.jsDoc[0]);
    }
    // For a syntax list, it is possible that one of its children has JSDocComment nodes, while
    // the syntax list itself considers them as normal trivia. Therefore if we simply skip
    // trivia for the list, we may have skipped the JSDocComment as well. So we should process its
    // first child to determine the actual position of its first token.
    if (node.kind === 295 /* SyntaxList */ &amp;&amp; node._children.length &gt; 0) {
        return getTokenPosOfNode(node._children[0], sourceFile, includeJsDoc);
    }
    return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTokenSourceMapRange" id="apidoc.element.typescript.getTokenSourceMapRange">
        function <span class="apidocSignatureSpan">typescript.</span>getTokenSourceMapRange
        <span class="apidocSignatureSpan">(node, token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTokenSourceMapRange(node, token) {
    var emitNode = node.emitNode;
    var tokenSourceMapRanges = emitNode &amp;&amp; emitNode.tokenSourceMapRanges;
    return tokenSourceMapRanges &amp;&amp; tokenSourceMapRanges[token];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTouchingPropertyName" id="apidoc.element.typescript.getTouchingPropertyName">
        function <span class="apidocSignatureSpan">typescript.</span>getTouchingPropertyName
        <span class="apidocSignatureSpan">(sourceFile, position, includeJsDocComment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTouchingPropertyName(sourceFile, position, includeJsDocComment) {
    if (includeJsDocComment === void 0) { includeJsDocComment = false; }
    return getTouchingToken(sourceFile, position, function (n) { return isPropertyName(n.kind); }, includeJsDocComment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTouchingToken" id="apidoc.element.typescript.getTouchingToken">
        function <span class="apidocSignatureSpan">typescript.</span>getTouchingToken
        <span class="apidocSignatureSpan">(sourceFile, position, includeItemAtEndPosition, includeJsDocComment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTouchingToken(sourceFile, position, includeItemAtEndPosition, includeJsDocComment) {
    if (includeJsDocComment === void 0) { includeJsDocComment = false; }
    return getTokenAtPositionWorker(sourceFile, position, /*allowPositionInLeadingTrivia*/ false, includeItemAtEndPosition, includeJsDocComment
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTouchingWord" id="apidoc.element.typescript.getTouchingWord">
        function <span class="apidocSignatureSpan">typescript.</span>getTouchingWord
        <span class="apidocSignatureSpan">(sourceFile, position, includeJsDocComment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTouchingWord(sourceFile, position, includeJsDocComment) {
    if (includeJsDocComment === void 0) { includeJsDocComment = false; }
    return getTouchingToken(sourceFile, position, function (n) { return isWord(n.kind); }, includeJsDocComment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTrailingCommentRanges" id="apidoc.element.typescript.getTrailingCommentRanges">
        function <span class="apidocSignatureSpan">typescript.</span>getTrailingCommentRanges
        <span class="apidocSignatureSpan">(text, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTrailingCommentRanges(text, pos) {
    return reduceEachTrailingCommentRange(text, pos, appendCommentRange, undefined, undefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTransformFlagsSubtreeExclusions" id="apidoc.element.typescript.getTransformFlagsSubtreeExclusions">
        function <span class="apidocSignatureSpan">typescript.</span>getTransformFlagsSubtreeExclusions
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTransformFlagsSubtreeExclusions(kind) {
    if (kind &gt;= 157 /* FirstTypeNode */ &amp;&amp; kind &lt;= 172 /* LastTypeNode */) {
        return -3 /* TypeExcludes */;
    }
    switch (kind) {
        case 180 /* CallExpression */:
        case 181 /* NewExpression */:
        case 176 /* ArrayLiteralExpression */:
            return 537396545 /* ArrayLiteralOrCallOrNewExcludes */;
        case 232 /* ModuleDeclaration */:
            return 574674241 /* ModuleExcludes */;
        case 145 /* Parameter */:
            return 536872257 /* ParameterExcludes */;
        case 186 /* ArrowFunction */:
            return 601249089 /* ArrowFunctionExcludes */;
        case 185 /* FunctionExpression */:
        case 227 /* FunctionDeclaration */:
            return 601281857 /* FunctionExcludes */;
        case 226 /* VariableDeclarationList */:
            return 546309441 /* VariableDeclarationListExcludes */;
        case 228 /* ClassDeclaration */:
        case 198 /* ClassExpression */:
            return 539358529 /* ClassExcludes */;
        case 151 /* Constructor */:
            return 601015617 /* ConstructorExcludes */;
        case 150 /* MethodDeclaration */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
            return 601015617 /* MethodOrAccessorExcludes */;
        case 118 /* AnyKeyword */:
        case 132 /* NumberKeyword */:
        case 129 /* NeverKeyword */:
        case 135 /* StringKeyword */:
        case 133 /* ObjectKeyword */:
        case 121 /* BooleanKeyword */:
        case 136 /* SymbolKeyword */:
        case 104 /* VoidKeyword */:
        case 144 /* TypeParameter */:
        case 147 /* PropertySignature */:
        case 149 /* MethodSignature */:
        case 154 /* CallSignature */:
        case 155 /* ConstructSignature */:
        case 156 /* IndexSignature */:
        case 229 /* InterfaceDeclaration */:
        case 230 /* TypeAliasDeclaration */:
            return -3 /* TypeExcludes */;
        case 177 /* ObjectLiteralExpression */:
            return 540087617 /* ObjectLiteralExcludes */;
        case 258 /* CatchClause */:
            return 537920833 /* CatchClauseExcludes */;
        case 173 /* ObjectBindingPattern */:
        case 174 /* ArrayBindingPattern */:
            return 537396545 /* BindingPatternExcludes */;
        default:
            return 536872257 /* NodeExcludes */;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTransformers" id="apidoc.element.typescript.getTransformers">
        function <span class="apidocSignatureSpan">typescript.</span>getTransformers
        <span class="apidocSignatureSpan">(compilerOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTransformers(compilerOptions) {
    var jsx = compilerOptions.jsx;
    var languageVersion = ts.getEmitScriptTarget(compilerOptions);
    var moduleKind = ts.getEmitModuleKind(compilerOptions);
    var transformers = [];
    transformers.push(ts.transformTypeScript);
    if (jsx === 2 /* React */) {
        transformers.push(ts.transformJsx);
    }
    if (languageVersion &lt; 5 /* ESNext */) {
        transformers.push(ts.transformESNext);
    }
    if (languageVersion &lt; 4 /* ES2017 */) {
        transformers.push(ts.transformES2017);
    }
    if (languageVersion &lt; 3 /* ES2016 */) {
        transformers.push(ts.transformES2016);
    }
    if (languageVersion &lt; 2 /* ES2015 */) {
        transformers.push(ts.transformES2015);
        transformers.push(ts.transformGenerators);
    }
    transformers.push(getModuleTransformer(moduleKind));
    // The ES5 transformer is last so that it can substitute expressions like `exports.default`
    // for ES3.
    if (languageVersion &lt; 1 /* ES5 */) {
        transformers.push(ts.transformES5);
    }
    return transformers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTypeArgumentOrTypeParameterList" id="apidoc.element.typescript.getTypeArgumentOrTypeParameterList">
        function <span class="apidocSignatureSpan">typescript.</span>getTypeArgumentOrTypeParameterList
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTypeArgumentOrTypeParameterList(node) {
    if (node.kind === 158 /* TypeReference */ || node.kind === 180 /* CallExpression */) {
        return node.typeArguments;
    }
    if (ts.isFunctionLike(node) || node.kind === 228 /* ClassDeclaration */ || node.kind === 229 /* InterfaceDeclaration */) {
        return node.typeParameters;
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.getTypeParameterOwner" id="apidoc.element.typescript.getTypeParameterOwner">
        function <span class="apidocSignatureSpan">typescript.</span>getTypeParameterOwner
        <span class="apidocSignatureSpan">(d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTypeParameterOwner(d) {
    if (d &amp;&amp; d.kind === 144 /* TypeParameter */) {
        for (var current = d; current; current = current.parent) {
            if (ts.isFunctionLike(current) || ts.isClassLike(current) || current.kind === 229 /* InterfaceDeclaration */) {
                return current;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasChangesInResolutions" id="apidoc.element.typescript.hasChangesInResolutions">
        function <span class="apidocSignatureSpan">typescript.</span>hasChangesInResolutions
        <span class="apidocSignatureSpan">(names, newResolutions, oldResolutions, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasChangesInResolutions(names, newResolutions, oldResolutions, comparer) {
    if (names.length !== newResolutions.length) {
        return false;
    }
    for (var i = 0; i &lt; names.length; i++) {
        var newResolution = newResolutions[i];
        var oldResolution = oldResolutions &amp;&amp; oldResolutions.get(names[i]);
        var changed = oldResolution
            ? !newResolution || !comparer(oldResolution, newResolution)
            : newResolution;
        if (changed) {
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasChildOfKind" id="apidoc.element.typescript.hasChildOfKind">
        function <span class="apidocSignatureSpan">typescript.</span>hasChildOfKind
        <span class="apidocSignatureSpan">(n, kind, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasChildOfKind(n, kind, sourceFile) {
    return !!findChildOfKind(n, kind, sourceFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasDeclaredRestParameter" id="apidoc.element.typescript.hasDeclaredRestParameter">
        function <span class="apidocSignatureSpan">typescript.</span>hasDeclaredRestParameter
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasDeclaredRestParameter(s) {
    return isDeclaredRestParam(ts.lastOrUndefined(s.parameters));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasDocComment" id="apidoc.element.typescript.hasDocComment">
        function <span class="apidocSignatureSpan">typescript.</span>hasDocComment
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasDocComment(sourceFile, position) {
    var token = getTokenAtPosition(sourceFile, position);
    // First, we have to see if this position actually landed in a comment.
    var commentRanges = ts.getLeadingCommentRanges(sourceFile.text, token.pos);
    return ts.forEach(commentRanges, jsDocPrefix);
    function jsDocPrefix(c) {
        var text = sourceFile.text;
        return text.length &gt;= c.pos + 3 &amp;&amp; text[c.pos] === "/" &amp;&amp; text[c.pos + 1] === "*" &amp;&amp; text[c.pos + 2] === "*";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasDynamicName" id="apidoc.element.typescript.hasDynamicName">
        function <span class="apidocSignatureSpan">typescript.</span>hasDynamicName
        <span class="apidocSignatureSpan">(declaration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasDynamicName(declaration) {
    return declaration.name &amp;&amp; isDynamicName(declaration.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasExtension" id="apidoc.element.typescript.hasExtension">
        function <span class="apidocSignatureSpan">typescript.</span>hasExtension
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasExtension(fileName) {
    return getBaseFileName(fileName).indexOf(".") &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasJSDocParameterTags" id="apidoc.element.typescript.hasJSDocParameterTags">
        function <span class="apidocSignatureSpan">typescript.</span>hasJSDocParameterTags
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasJSDocParameterTags(node) {
    var parameterTags = getJSDocTags(node, 284 /* JSDocParameterTag */);
    return parameterTags &amp;&amp; parameterTags.length &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasJavaScriptFileExtension" id="apidoc.element.typescript.hasJavaScriptFileExtension">
        function <span class="apidocSignatureSpan">typescript.</span>hasJavaScriptFileExtension
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasJavaScriptFileExtension(fileName) {
    return forEach(ts.supportedJavascriptExtensions, function (extension) { return fileExtensionIs(fileName, extension); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasModifier" id="apidoc.element.typescript.hasModifier">
        function <span class="apidocSignatureSpan">typescript.</span>hasModifier
        <span class="apidocSignatureSpan">(node, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasModifier(node, flags) {
    return (getModifierFlags(node) &amp; flags) !== 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasModifiers" id="apidoc.element.typescript.hasModifiers">
        function <span class="apidocSignatureSpan">typescript.</span>hasModifiers
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasModifiers(node) {
    return getModifierFlags(node) !== 0 /* None */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasProperty" id="apidoc.element.typescript.hasProperty">
        function <span class="apidocSignatureSpan">typescript.</span>hasProperty
        <span class="apidocSignatureSpan">(map, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasProperty(map, key) {
    return hasOwnProperty.call(map, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasQuestionToken" id="apidoc.element.typescript.hasQuestionToken">
        function <span class="apidocSignatureSpan">typescript.</span>hasQuestionToken
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasQuestionToken(node) {
    if (node) {
        switch (node.kind) {
            case 145 /* Parameter */:
            case 150 /* MethodDeclaration */:
            case 149 /* MethodSignature */:
            case 260 /* ShorthandPropertyAssignment */:
            case 259 /* PropertyAssignment */:
            case 148 /* PropertyDeclaration */:
            case 147 /* PropertySignature */:
                return node.questionToken !== undefined;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasResolvedModule" id="apidoc.element.typescript.hasResolvedModule">
        function <span class="apidocSignatureSpan">typescript.</span>hasResolvedModule
        <span class="apidocSignatureSpan">(sourceFile, moduleNameText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasResolvedModule(sourceFile, moduleNameText) {
    return !!(sourceFile &amp;&amp; sourceFile.resolvedModules &amp;&amp; sourceFile.resolvedModules.get(moduleNameText));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasRestParameter" id="apidoc.element.typescript.hasRestParameter">
        function <span class="apidocSignatureSpan">typescript.</span>hasRestParameter
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasRestParameter(s) {
    return isRestParameter(ts.lastOrUndefined(s.parameters));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasTrailingDirectorySeparator" id="apidoc.element.typescript.hasTrailingDirectorySeparator">
        function <span class="apidocSignatureSpan">typescript.</span>hasTrailingDirectorySeparator
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasTrailingDirectorySeparator(path) {
    var lastCharacter = path.charAt(path.length - 1);
    return lastCharacter === "/" || lastCharacter === "\\";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasTypeScriptFileExtension" id="apidoc.element.typescript.hasTypeScriptFileExtension">
        function <span class="apidocSignatureSpan">typescript.</span>hasTypeScriptFileExtension
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasTypeScriptFileExtension(fileName) {
    return forEach(ts.supportedTypeScriptExtensions, function (extension) { return fileExtensionIs(fileName, extension); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.hasZeroOrOneAsteriskCharacter" id="apidoc.element.typescript.hasZeroOrOneAsteriskCharacter">
        function <span class="apidocSignatureSpan">typescript.</span>hasZeroOrOneAsteriskCharacter
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasZeroOrOneAsteriskCharacter(str) {
    var seenAsterisk = false;
    for (var i = 0; i &lt; str.length; i++) {
        if (str.charCodeAt(i) === 42 /* asterisk */) {
            if (!seenAsterisk) {
                seenAsterisk = true;
            }
            else {
                // have already seen asterisk
                return false;
            }
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.identifierIsThisKeyword" id="apidoc.element.typescript.identifierIsThisKeyword">
        function <span class="apidocSignatureSpan">typescript.</span>identifierIsThisKeyword
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function identifierIsThisKeyword(id) {
    return id.originalKeywordKind === 98 /* ThisKeyword */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.indexOf" id="apidoc.element.typescript.indexOf">
        function <span class="apidocSignatureSpan">typescript.</span>indexOf
        <span class="apidocSignatureSpan">(array, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function indexOf(array, value) {
    if (array) {
        for (var i = 0; i &lt; array.length; i++) {
            if (array[i] === value) {
                return i;
            }
        }
    }
    return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.indexOfAnyCharCode" id="apidoc.element.typescript.indexOfAnyCharCode">
        function <span class="apidocSignatureSpan">typescript.</span>indexOfAnyCharCode
        <span class="apidocSignatureSpan">(text, charCodes, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function indexOfAnyCharCode(text, charCodes, start) {
    for (var i = start || 0; i &lt; text.length; i++) {
        if (contains(charCodes, text.charCodeAt(i))) {
            return i;
        }
    }
    return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.inlineExpressions" id="apidoc.element.typescript.inlineExpressions">
        function <span class="apidocSignatureSpan">typescript.</span>inlineExpressions
        <span class="apidocSignatureSpan">(expressions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inlineExpressions(expressions) {
    return ts.reduceLeft(expressions, ts.createComma);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.introducesArgumentsExoticObject" id="apidoc.element.typescript.introducesArgumentsExoticObject">
        function <span class="apidocSignatureSpan">typescript.</span>introducesArgumentsExoticObject
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function introducesArgumentsExoticObject(node) {
    switch (node.kind) {
        case 150 /* MethodDeclaration */:
        case 149 /* MethodSignature */:
        case 151 /* Constructor */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        case 227 /* FunctionDeclaration */:
        case 185 /* FunctionExpression */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAccessibilityModifier" id="apidoc.element.typescript.isAccessibilityModifier">
        function <span class="apidocSignatureSpan">typescript.</span>isAccessibilityModifier
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAccessibilityModifier(kind) {
    switch (kind) {
        case 113 /* PublicKeyword */:
        case 111 /* PrivateKeyword */:
        case 112 /* ProtectedKeyword */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAccessor" id="apidoc.element.typescript.isAccessor">
        function <span class="apidocSignatureSpan">typescript.</span>isAccessor
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAccessor(node) {
    return node &amp;&amp; (node.kind === 152 /* GetAccessor */ || node.kind === 153 /* SetAccessor */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAliasSymbolDeclaration" id="apidoc.element.typescript.isAliasSymbolDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isAliasSymbolDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAliasSymbolDeclaration(node) {
    return node.kind === 236 /* ImportEqualsDeclaration */ ||
        node.kind === 235 /* NamespaceExportDeclaration */ ||
        node.kind === 238 /* ImportClause */ &amp;&amp; !!node.name ||
        node.kind === 239 /* NamespaceImport */ ||
        node.kind === 241 /* ImportSpecifier */ ||
        node.kind === 245 /* ExportSpecifier */ ||
        node.kind === 242 /* ExportAssignment */ &amp;&amp; exportAssignmentIsAlias(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAmbientModule" id="apidoc.element.typescript.isAmbientModule">
        function <span class="apidocSignatureSpan">typescript.</span>isAmbientModule
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAmbientModule(node) {
    return node &amp;&amp; node.kind === 232 /* ModuleDeclaration */ &amp;&amp;
        (node.name.kind === 9 /* StringLiteral */ || isGlobalScopeAugmentation(node));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isArray" id="apidoc.element.typescript.isArray">
        function <span class="apidocSignatureSpan">typescript.</span>isArray
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray(value) {
    return Array.isArray ? Array.isArray(value) : value instanceof Array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isArrayBindingElement" id="apidoc.element.typescript.isArrayBindingElement">
        function <span class="apidocSignatureSpan">typescript.</span>isArrayBindingElement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrayBindingElement(node) {
    var kind = node.kind;
    return kind === 175<span class="apidocCodeCommentSpan"> /* BindingElement */
</span>        || kind === 199 /* OmittedExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isArrayBindingOrAssignmentPattern" id="apidoc.element.typescript.isArrayBindingOrAssignmentPattern">
        function <span class="apidocSignatureSpan">typescript.</span>isArrayBindingOrAssignmentPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrayBindingOrAssignmentPattern(node) {
    switch (node.kind) {
        case 174 /* ArrayBindingPattern */:
        case 176 /* ArrayLiteralExpression */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isArrayBindingPattern" id="apidoc.element.typescript.isArrayBindingPattern">
        function <span class="apidocSignatureSpan">typescript.</span>isArrayBindingPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrayBindingPattern(node) {
    return node.kind === 174 /* ArrayBindingPattern */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isArrayLiteralExpression" id="apidoc.element.typescript.isArrayLiteralExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isArrayLiteralExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrayLiteralExpression(node) {
    return node.kind === 176 /* ArrayLiteralExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isArrayLiteralOrObjectLiteralDestructuringPattern" id="apidoc.element.typescript.isArrayLiteralOrObjectLiteralDestructuringPattern">
        function <span class="apidocSignatureSpan">typescript.</span>isArrayLiteralOrObjectLiteralDestructuringPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrayLiteralOrObjectLiteralDestructuringPattern(node) {
    if (node.kind === 176 /* ArrayLiteralExpression */ ||
        node.kind === 177 /* ObjectLiteralExpression */) {
        // [a,b,c] from:
        // [a, b, c] = someExpression;
        if (node.parent.kind === 193 /* BinaryExpression */ &amp;&amp;
            node.parent.left === node &amp;&amp;
            node.parent.operatorToken.kind === 57 /* EqualsToken */) {
            return true;
        }
        // [a, b, c] from:
        // for([a, b, c] of expression)
        if (node.parent.kind === 215 /* ForOfStatement */ &amp;&amp;
            node.parent.initializer === node) {
            return true;
        }
        // [a, b, c] of
        // [x, [a, b, c] ] = someExpression
        // or
        // {x, a: {a, b, c} } = someExpression
        if (isArrayLiteralOrObjectLiteralDestructuringPattern(node.parent.kind === 259 /* PropertyAssignment */ ? node.parent.parent
 : node.parent)) {
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAssertionExpression" id="apidoc.element.typescript.isAssertionExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isAssertionExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAssertionExpression(node) {
    var kind = node.kind;
    return kind === 183<span class="apidocCodeCommentSpan"> /* TypeAssertionExpression */
</span>        || kind === 201 /* AsExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAssignmentExpression" id="apidoc.element.typescript.isAssignmentExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isAssignmentExpression
        <span class="apidocSignatureSpan">(node, excludeCompoundAssignment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAssignmentExpression(node, excludeCompoundAssignment) {
    return isBinaryExpression(node)
        &amp;&amp; (excludeCompoundAssignment
            ? node.operatorToken.kind === 57<span class="apidocCodeCommentSpan"> /* EqualsToken */
</span>            : isAssignmentOperator(node.operatorToken.kind))
        &amp;&amp; isLeftHandSideExpression(node.left);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAssignmentOperator" id="apidoc.element.typescript.isAssignmentOperator">
        function <span class="apidocSignatureSpan">typescript.</span>isAssignmentOperator
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAssignmentOperator(token) {
    return token &gt;= 57 /* FirstAssignment */ &amp;&amp; token &lt;= 69 /* LastAssignment */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAssignmentPattern" id="apidoc.element.typescript.isAssignmentPattern">
        function <span class="apidocSignatureSpan">typescript.</span>isAssignmentPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAssignmentPattern(node) {
    var kind = node.kind;
    return kind === 176<span class="apidocCodeCommentSpan"> /* ArrayLiteralExpression */
</span>        || kind === 177 /* ObjectLiteralExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAssignmentTarget" id="apidoc.element.typescript.isAssignmentTarget">
        function <span class="apidocSignatureSpan">typescript.</span>isAssignmentTarget
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAssignmentTarget(node) {
    return getAssignmentTargetKind(node) !== 0 /* None */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isAsyncFunctionLike" id="apidoc.element.typescript.isAsyncFunctionLike">
        function <span class="apidocSignatureSpan">typescript.</span>isAsyncFunctionLike
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAsyncFunctionLike(node) {
    return isFunctionLike(node) &amp;&amp; hasModifier(node, 256 /* Async */) &amp;&amp; !isAccessor(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBinaryExpression" id="apidoc.element.typescript.isBinaryExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isBinaryExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBinaryExpression(node) {
    return node.kind === 193 /* BinaryExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBinaryOrOctalIntegerLiteral" id="apidoc.element.typescript.isBinaryOrOctalIntegerLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>isBinaryOrOctalIntegerLiteral
        <span class="apidocSignatureSpan">(node, text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBinaryOrOctalIntegerLiteral(node, text) {
    return node.kind === 8<span class="apidocCodeCommentSpan"> /* NumericLiteral */
</span>        &amp;&amp; (getNumericLiteralFlags(text, /*hint*/ 6 /* BinaryOrOctal */) &amp; 6 /* BinaryOrOctal */) !== 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBindingElement" id="apidoc.element.typescript.isBindingElement">
        function <span class="apidocSignatureSpan">typescript.</span>isBindingElement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBindingElement(node) {
    return node.kind === 175 /* BindingElement */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBindingName" id="apidoc.element.typescript.isBindingName">
        function <span class="apidocSignatureSpan">typescript.</span>isBindingName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBindingName(node) {
    var kind = node.kind;
    return kind === 70<span class="apidocCodeCommentSpan"> /* Identifier */
</span>        || kind === 173 /* ObjectBindingPattern */
        || kind === 174 /* ArrayBindingPattern */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBindingOrAssignmentPattern" id="apidoc.element.typescript.isBindingOrAssignmentPattern">
        function <span class="apidocSignatureSpan">typescript.</span>isBindingOrAssignmentPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBindingOrAssignmentPattern(node) {
    return isObjectBindingOrAssignmentPattern(node)
        || isArrayBindingOrAssignmentPattern(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBindingPattern" id="apidoc.element.typescript.isBindingPattern">
        function <span class="apidocSignatureSpan">typescript.</span>isBindingPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBindingPattern(node) {
    if (node) {
        var kind = node.kind;
        return kind === 174<span class="apidocCodeCommentSpan"> /* ArrayBindingPattern */
</span>            || kind === 173 /* ObjectBindingPattern */;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBlock" id="apidoc.element.typescript.isBlock">
        function <span class="apidocSignatureSpan">typescript.</span>isBlock
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBlock(node) {
    return node.kind === 206 /* Block */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBlockOrCatchScoped" id="apidoc.element.typescript.isBlockOrCatchScoped">
        function <span class="apidocSignatureSpan">typescript.</span>isBlockOrCatchScoped
        <span class="apidocSignatureSpan">(declaration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBlockOrCatchScoped(declaration) {
    return (ts.getCombinedNodeFlags(declaration) &amp; 3 /* BlockScoped */) !== 0 ||
        isCatchClauseVariableDeclarationOrBindingElement(declaration);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBlockScope" id="apidoc.element.typescript.isBlockScope">
        function <span class="apidocSignatureSpan">typescript.</span>isBlockScope
        <span class="apidocSignatureSpan">(node, parentNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBlockScope(node, parentNode) {
    switch (node.kind) {
        case 263 /* SourceFile */:
        case 234 /* CaseBlock */:
        case 258 /* CatchClause */:
        case 232 /* ModuleDeclaration */:
        case 213 /* ForStatement */:
        case 214 /* ForInStatement */:
        case 215 /* ForOfStatement */:
        case 151 /* Constructor */:
        case 150 /* MethodDeclaration */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        case 227 /* FunctionDeclaration */:
        case 185 /* FunctionExpression */:
        case 186 /* ArrowFunction */:
            return true;
        case 206 /* Block */:
            // function block is not considered block-scope container
            // see comment in binder.ts: bind(...), case for SyntaxKind.Block
            return parentNode &amp;&amp; !isFunctionLike(parentNode);
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isBlockScopedContainerTopLevel" id="apidoc.element.typescript.isBlockScopedContainerTopLevel">
        function <span class="apidocSignatureSpan">typescript.</span>isBlockScopedContainerTopLevel
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBlockScopedContainerTopLevel(node) {
    return node.kind === 263 /* SourceFile */ ||
        node.kind === 232 /* ModuleDeclaration */ ||
        isFunctionLike(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isCallExpression" id="apidoc.element.typescript.isCallExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isCallExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCallExpression(node) {
    return node.kind === 180 /* CallExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isCallExpressionTarget" id="apidoc.element.typescript.isCallExpressionTarget">
        function <span class="apidocSignatureSpan">typescript.</span>isCallExpressionTarget
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCallExpressionTarget(node) {
    return isCallOrNewExpressionTarget(node, 180 /* CallExpression */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isCallLikeExpression" id="apidoc.element.typescript.isCallLikeExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isCallLikeExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCallLikeExpression(node) {
    switch (node.kind) {
        case 180 /* CallExpression */:
        case 181 /* NewExpression */:
        case 182 /* TaggedTemplateExpression */:
        case 146 /* Decorator */:
            return true;
        default:
            return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isCaseBlock" id="apidoc.element.typescript.isCaseBlock">
        function <span class="apidocSignatureSpan">typescript.</span>isCaseBlock
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCaseBlock(node) {
    return node.kind === 234 /* CaseBlock */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isCaseOrDefaultClause" id="apidoc.element.typescript.isCaseOrDefaultClause">
        function <span class="apidocSignatureSpan">typescript.</span>isCaseOrDefaultClause
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCaseOrDefaultClause(node) {
    var kind = node.kind;
    return kind === 255<span class="apidocCodeCommentSpan"> /* CaseClause */
</span>        || kind === 256 /* DefaultClause */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isCatchClause" id="apidoc.element.typescript.isCatchClause">
        function <span class="apidocSignatureSpan">typescript.</span>isCatchClause
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCatchClause(node) {
    return node.kind === 258 /* CatchClause */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isCatchClauseVariableDeclarationOrBindingElement" id="apidoc.element.typescript.isCatchClauseVariableDeclarationOrBindingElement">
        function <span class="apidocSignatureSpan">typescript.</span>isCatchClauseVariableDeclarationOrBindingElement
        <span class="apidocSignatureSpan">(declaration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCatchClauseVariableDeclarationOrBindingElement(declaration) {
    var node = getRootDeclaration(declaration);
    return node.kind === 225 /* VariableDeclaration */ &amp;&amp; node.parent.kind === 258 /* CatchClause */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isChildOfNodeWithKind" id="apidoc.element.typescript.isChildOfNodeWithKind">
        function <span class="apidocSignatureSpan">typescript.</span>isChildOfNodeWithKind
        <span class="apidocSignatureSpan">(node, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isChildOfNodeWithKind(node, kind) {
    while (node) {
        if (node.kind === kind) {
            return true;
        }
        node = node.parent;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isClassElement" id="apidoc.element.typescript.isClassElement">
        function <span class="apidocSignatureSpan">typescript.</span>isClassElement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isClassElement(node) {
    var kind = node.kind;
    return kind === 151<span class="apidocCodeCommentSpan"> /* Constructor */
</span>        || kind === 148 /* PropertyDeclaration */
        || kind === 150 /* MethodDeclaration */
        || kind === 152 /* GetAccessor */
        || kind === 153 /* SetAccessor */
        || kind === 156 /* IndexSignature */
        || kind === 205 /* SemicolonClassElement */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isClassLike" id="apidoc.element.typescript.isClassLike">
        function <span class="apidocSignatureSpan">typescript.</span>isClassLike
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isClassLike(node) {
    return node &amp;&amp; (node.kind === 228 /* ClassDeclaration */ || node.kind === 198 /* ClassExpression */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isCollapsedRange" id="apidoc.element.typescript.isCollapsedRange">
        function <span class="apidocSignatureSpan">typescript.</span>isCollapsedRange
        <span class="apidocSignatureSpan">(range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCollapsedRange(range) {
    return range.pos === range.end;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isComment" id="apidoc.element.typescript.isComment">
        function <span class="apidocSignatureSpan">typescript.</span>isComment
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isComment(kind) {
    return kind === 2 /* SingleLineCommentTrivia */ || kind === 3 /* MultiLineCommentTrivia */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isCompletedNode" id="apidoc.element.typescript.isCompletedNode">
        function <span class="apidocSignatureSpan">typescript.</span>isCompletedNode
        <span class="apidocSignatureSpan">(n, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCompletedNode(n, sourceFile) {
    if (ts.nodeIsMissing(n)) {
        return false;
    }
    switch (n.kind) {
        case 228 /* ClassDeclaration */:
        case 229 /* InterfaceDeclaration */:
        case 231 /* EnumDeclaration */:
        case 177 /* ObjectLiteralExpression */:
        case 173 /* ObjectBindingPattern */:
        case 162 /* TypeLiteral */:
        case 206 /* Block */:
        case 233 /* ModuleBlock */:
        case 234 /* CaseBlock */:
        case 240 /* NamedImports */:
        case 244 /* NamedExports */:
            return nodeEndsWith(n, 17 /* CloseBraceToken */, sourceFile);
        case 258 /* CatchClause */:
            return isCompletedNode(n.block, sourceFile);
        case 181 /* NewExpression */:
            if (!n.arguments) {
                return true;
            }
        // fall through
        case 180 /* CallExpression */:
        case 184 /* ParenthesizedExpression */:
        case 167 /* ParenthesizedType */:
            return nodeEndsWith(n, 19 /* CloseParenToken */, sourceFile);
        case 159 /* FunctionType */:
        case 160 /* ConstructorType */:
            return isCompletedNode(n.type, sourceFile);
        case 151 /* Constructor */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        case 227 /* FunctionDeclaration */:
        case 185 /* FunctionExpression */:
        case 150 /* MethodDeclaration */:
        case 149 /* MethodSignature */:
        case 155 /* ConstructSignature */:
        case 154 /* CallSignature */:
        case 186 /* ArrowFunction */:
            if (n.body) {
                return isCompletedNode(n.body, sourceFile);
            }
            if (n.type) {
                return isCompletedNode(n.type, sourceFile);
            }
            // Even though type parameters can be unclosed, we can get away with
            // having at least a closing paren.
            return hasChildOfKind(n, 19 /* CloseParenToken */, sourceFile);
        case 232 /* ModuleDeclaration */:
            return n.body &amp;&amp; isCompletedNode(n.body, sourceFile);
        case 210 /* IfStatement */:
            if (n.elseStatement) {
                return isCompletedNode(n.elseStatement, sourceFile);
            }
            return isCompletedNode(n.thenStatement, sourceFile);
        case 209 /* ExpressionStatement */:
            return isCompletedNode(n.expression, sourceFile) ||
                hasChildOfKind(n, 24 /* SemicolonToken */);
        case 176 /* ArrayLiteralExpression */:
        case 174 /* ArrayBindingPattern */:
        case 179 /* ElementAccessExpression */:
        case 143 /* ComputedPropertyName */:
        case 164 /* TupleType */:
            return nodeEndsWith(n, 21 /* CloseBracketToken */, sourceFile);
        case 156 /* IndexSignature */:
            if (n.type) {
                return isCompletedNode(n.type, sourceFile);
            }
            return hasChildOfKind(n, 21 /* CloseBracketToken */, sourceFile);
        case 255 /* CaseClause */:
        case 256 /* DefaultClause */:
            // there is no such thing as terminator token for CaseClause/DefaultClause so for simplicity always consider them non
-completed
            return false;
        case 213 /* ForStatement */:
        case 214 /* ForInStatement */:
        case 215 /* ForOfStatement */:
        case 212 /* WhileStatement */:
            return isCompletedNode(n.statement, sourceFile);
        case 211 /* DoStatement */:
            // rough approximation: if DoStatement has While keyword - then if node is completed is checking the presence of ')';
            var hasWhileKeyword = findChildOfKind(n, 105 /* WhileKeyword */, sourceFile);
            if (hasWhileKeyword) {
                return nodeEndsWith(n, 19 /* CloseParenToken */, sourceFile);
            }
            return isCompletedNode(n.statement, sourceFile);
        case 161 /* TypeQuery */:
            return isCompletedNode(n.exprName, sourceFile);
        case 188 /* TypeOfExpression */:
        case 187 /* DeleteExpression */:
        case 189 /* Vo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isComputedPropertyName" id="apidoc.element.typescript.isComputedPropertyName">
        function <span class="apidocSignatureSpan">typescript.</span>isComputedPropertyName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isComputedPropertyName(node) {
    return node.kind === 143 /* ComputedPropertyName */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isConciseBody" id="apidoc.element.typescript.isConciseBody">
        function <span class="apidocSignatureSpan">typescript.</span>isConciseBody
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isConciseBody(node) {
    return isBlock(node)
        || isExpression(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isConditionalExpression" id="apidoc.element.typescript.isConditionalExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isConditionalExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isConditionalExpression(node) {
    return node.kind === 194 /* ConditionalExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isConst" id="apidoc.element.typescript.isConst">
        function <span class="apidocSignatureSpan">typescript.</span>isConst
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isConst(node) {
    return !!(ts.getCombinedNodeFlags(node) &amp; 2 /* Const */)
        || !!(ts.getCombinedModifierFlags(node) &amp; 2048 /* Const */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isConstEnumDeclaration" id="apidoc.element.typescript.isConstEnumDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isConstEnumDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isConstEnumDeclaration(node) {
    return node.kind === 231 /* EnumDeclaration */ &amp;&amp; isConst(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDeclaration" id="apidoc.element.typescript.isDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDeclaration(node) {
    return isDeclarationKind(node.kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDeclarationBindingElement" id="apidoc.element.typescript.isDeclarationBindingElement">
        function <span class="apidocSignatureSpan">typescript.</span>isDeclarationBindingElement
        <span class="apidocSignatureSpan">(bindingElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDeclarationBindingElement(bindingElement) {
    switch (bindingElement.kind) {
        case 225 /* VariableDeclaration */:
        case 145 /* Parameter */:
        case 175 /* BindingElement */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDeclarationFile" id="apidoc.element.typescript.isDeclarationFile">
        function <span class="apidocSignatureSpan">typescript.</span>isDeclarationFile
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDeclarationFile(file) {
    return file.isDeclarationFile;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDeclarationName" id="apidoc.element.typescript.isDeclarationName">
        function <span class="apidocSignatureSpan">typescript.</span>isDeclarationName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDeclarationName(name) {
    if (name.kind !== 70 /* Identifier */ &amp;&amp; name.kind !== 9 /* StringLiteral */ &amp;&amp; name.kind !== 8 /* NumericLiteral */) {
        return false;
    }
    var parent = name.parent;
    if (parent.kind === 241 /* ImportSpecifier */ || parent.kind === 245 /* ExportSpecifier */) {
        if (parent.propertyName) {
            return true;
        }
    }
    if (isDeclaration(parent)) {
        return parent.name === name;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDeclarationNameOfEnumOrNamespace" id="apidoc.element.typescript.isDeclarationNameOfEnumOrNamespace">
        function <span class="apidocSignatureSpan">typescript.</span>isDeclarationNameOfEnumOrNamespace
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDeclarationNameOfEnumOrNamespace(node) {
    var parseNode = ts.getParseTreeNode(node);
    if (parseNode) {
        switch (parseNode.parent.kind) {
            case 231 /* EnumDeclaration */:
            case 232 /* ModuleDeclaration */:
                return parseNode === parseNode.parent.name;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDeclarationOfFunctionExpression" id="apidoc.element.typescript.isDeclarationOfFunctionExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isDeclarationOfFunctionExpression
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDeclarationOfFunctionExpression(s) {
    if (s.valueDeclaration &amp;&amp; s.valueDeclaration.kind === 225 /* VariableDeclaration */) {
        var declaration = s.valueDeclaration;
        return declaration.initializer &amp;&amp; declaration.initializer.kind === 185 /* FunctionExpression */;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDeclarationStatement" id="apidoc.element.typescript.isDeclarationStatement">
        function <span class="apidocSignatureSpan">typescript.</span>isDeclarationStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDeclarationStatement(node) {
    return isDeclarationStatementKind(node.kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDeclaredRestParam" id="apidoc.element.typescript.isDeclaredRestParam">
        function <span class="apidocSignatureSpan">typescript.</span>isDeclaredRestParam
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDeclaredRestParam(node) {
    return node &amp;&amp; node.dotDotDotToken !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDecorator" id="apidoc.element.typescript.isDecorator">
        function <span class="apidocSignatureSpan">typescript.</span>isDecorator
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDecorator(node) {
    return node.kind === 146 /* Decorator */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDefaultImport" id="apidoc.element.typescript.isDefaultImport">
        function <span class="apidocSignatureSpan">typescript.</span>isDefaultImport
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDefaultImport(node) {
    return node.kind === 237<span class="apidocCodeCommentSpan"> /* ImportDeclaration */
</span>        &amp;&amp; node.importClause
        &amp;&amp; !!node.importClause.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDefined" id="apidoc.element.typescript.isDefined">
        function <span class="apidocSignatureSpan">typescript.</span>isDefined
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDefined(value) {
    return value !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDeleteTarget" id="apidoc.element.typescript.isDeleteTarget">
        function <span class="apidocSignatureSpan">typescript.</span>isDeleteTarget
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDeleteTarget(node) {
    if (node.kind !== 178 /* PropertyAccessExpression */ &amp;&amp; node.kind !== 179 /* ElementAccessExpression */) {
        return false;
    }
    node = node.parent;
    while (node &amp;&amp; node.kind === 184 /* ParenthesizedExpression */) {
        node = node.parent;
    }
    return node &amp;&amp; node.kind === 187 /* DeleteExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDestructuringAssignment" id="apidoc.element.typescript.isDestructuringAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>isDestructuringAssignment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDestructuringAssignment(node) {
    if (isAssignmentExpression(node,<span class="apidocCodeCommentSpan"> /*excludeCompoundAssignment*/ true)) {
        var kind = node.left.kind;
        return kind === 177 /* ObjectLiteralExpression */
</span>            || kind === 176 /* ArrayLiteralExpression */;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isDynamicName" id="apidoc.element.typescript.isDynamicName">
        function <span class="apidocSignatureSpan">typescript.</span>isDynamicName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDynamicName(name) {
    return name.kind === 143 /* ComputedPropertyName */ &amp;&amp;
        !isStringOrNumericLiteral(name.expression) &amp;&amp;
        !isWellKnownSymbolSyntactically(name.expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isESSymbolIdentifier" id="apidoc.element.typescript.isESSymbolIdentifier">
        function <span class="apidocSignatureSpan">typescript.</span>isESSymbolIdentifier
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isESSymbolIdentifier(node) {
    return node.kind === 70 /* Identifier */ &amp;&amp; node.text === "Symbol";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isEffectiveExternalModule" id="apidoc.element.typescript.isEffectiveExternalModule">
        function <span class="apidocSignatureSpan">typescript.</span>isEffectiveExternalModule
        <span class="apidocSignatureSpan">(node, compilerOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEffectiveExternalModule(node, compilerOptions) {
    return ts.isExternalModule(node) || compilerOptions.isolatedModules;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isElementAccessExpression" id="apidoc.element.typescript.isElementAccessExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isElementAccessExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isElementAccessExpression(node) {
    return node.kind === 179 /* ElementAccessExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isEmptyObjectLiteralOrArrayLiteral" id="apidoc.element.typescript.isEmptyObjectLiteralOrArrayLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>isEmptyObjectLiteralOrArrayLiteral
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEmptyObjectLiteralOrArrayLiteral(expression) {
    var kind = expression.kind;
    if (kind === 177 /* ObjectLiteralExpression */) {
        return expression.properties.length === 0;
    }
    if (kind === 176 /* ArrayLiteralExpression */) {
        return expression.elements.length === 0;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isEntityName" id="apidoc.element.typescript.isEntityName">
        function <span class="apidocSignatureSpan">typescript.</span>isEntityName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEntityName(node) {
    var kind = node.kind;
    return kind === 142<span class="apidocCodeCommentSpan"> /* QualifiedName */
</span>        || kind === 70 /* Identifier */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isEntityNameExpression" id="apidoc.element.typescript.isEntityNameExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isEntityNameExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEntityNameExpression(node) {
    return node.kind === 70 /* Identifier */ ||
        node.kind === 178 /* PropertyAccessExpression */ &amp;&amp; isEntityNameExpression(node.expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isEnumMember" id="apidoc.element.typescript.isEnumMember">
        function <span class="apidocSignatureSpan">typescript.</span>isEnumMember
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEnumMember(node) {
    return node.kind === 262 /* EnumMember */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExportDefaultSymbol" id="apidoc.element.typescript.isExportDefaultSymbol">
        function <span class="apidocSignatureSpan">typescript.</span>isExportDefaultSymbol
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExportDefaultSymbol(symbol) {
    return symbol &amp;&amp; symbol.valueDeclaration &amp;&amp; hasModifier(symbol.valueDeclaration, 512 /* Default */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExportName" id="apidoc.element.typescript.isExportName">
        function <span class="apidocSignatureSpan">typescript.</span>isExportName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExportName(node) {
    return (ts.getEmitFlags(node) &amp; 8192 /* ExportName */) !== 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExportSpecifier" id="apidoc.element.typescript.isExportSpecifier">
        function <span class="apidocSignatureSpan">typescript.</span>isExportSpecifier
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExportSpecifier(node) {
    return node.kind === 245 /* ExportSpecifier */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExpression" id="apidoc.element.typescript.isExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExpression(node) {
    return isExpressionKind(ts.skipPartiallyEmittedExpressions(node).kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExpressionOfExternalModuleImportEqualsDeclaration" id="apidoc.element.typescript.isExpressionOfExternalModuleImportEqualsDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isExpressionOfExternalModuleImportEqualsDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExpressionOfExternalModuleImportEqualsDeclaration(node) {
    return ts.isExternalModuleImportEqualsDeclaration(node.parent.parent) &amp;&amp;
        ts.getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExpressionWithTypeArguments" id="apidoc.element.typescript.isExpressionWithTypeArguments">
        function <span class="apidocSignatureSpan">typescript.</span>isExpressionWithTypeArguments
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExpressionWithTypeArguments(node) {
    return node.kind === 200 /* ExpressionWithTypeArguments */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExpressionWithTypeArgumentsInClassExtendsClause" id="apidoc.element.typescript.isExpressionWithTypeArgumentsInClassExtendsClause">
        function <span class="apidocSignatureSpan">typescript.</span>isExpressionWithTypeArgumentsInClassExtendsClause
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExpressionWithTypeArgumentsInClassExtendsClause(node) {
    return tryGetClassExtendingExpressionWithTypeArguments(node) !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExternalModule" id="apidoc.element.typescript.isExternalModule">
        function <span class="apidocSignatureSpan">typescript.</span>isExternalModule
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExternalModule(file) {
    return file.externalModuleIndicator !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExternalModuleAugmentation" id="apidoc.element.typescript.isExternalModuleAugmentation">
        function <span class="apidocSignatureSpan">typescript.</span>isExternalModuleAugmentation
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExternalModuleAugmentation(node) {
    // external module augmentation is a ambient module declaration that is either:
    // - defined in the top level scope and source file is an external module
    // - defined inside ambient module declaration located in the top level scope and source file not an external module
    if (!node || !isAmbientModule(node)) {
        return false;
    }
    switch (node.parent.kind) {
        case 263 /* SourceFile */:
            return ts.isExternalModule(node.parent);
        case 233 /* ModuleBlock */:
            return isAmbientModule(node.parent.parent) &amp;&amp; !ts.isExternalModule(node.parent.parent.parent);
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExternalModuleImportEqualsDeclaration" id="apidoc.element.typescript.isExternalModuleImportEqualsDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isExternalModuleImportEqualsDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExternalModuleImportEqualsDeclaration(node) {
    return node.kind === 236 /* ImportEqualsDeclaration */ &amp;&amp; node.moduleReference.kind === 247 /* ExternalModuleReference */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExternalModuleNameRelative" id="apidoc.element.typescript.isExternalModuleNameRelative">
        function <span class="apidocSignatureSpan">typescript.</span>isExternalModuleNameRelative
        <span class="apidocSignatureSpan">(moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExternalModuleNameRelative(moduleName) {
    // TypeScript 1.0 spec (April 2014): 11.2.1
    // An external module name is "relative" if the first term is "." or "..".
    return /^\.\.?($|[\\/])/.test(moduleName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isExternalOrCommonJsModule" id="apidoc.element.typescript.isExternalOrCommonJsModule">
        function <span class="apidocSignatureSpan">typescript.</span>isExternalOrCommonJsModule
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExternalOrCommonJsModule(file) {
    return (file.externalModuleIndicator || file.commonJsModuleIndicator) !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isFirstDeclarationOfKind" id="apidoc.element.typescript.isFirstDeclarationOfKind">
        function <span class="apidocSignatureSpan">typescript.</span>isFirstDeclarationOfKind
        <span class="apidocSignatureSpan">(node, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFirstDeclarationOfKind(node, kind) {
    return node.symbol &amp;&amp; getDeclarationOfKind(node.symbol, kind) === node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isFirstDeclarationOfSymbolParameter" id="apidoc.element.typescript.isFirstDeclarationOfSymbolParameter">
        function <span class="apidocSignatureSpan">typescript.</span>isFirstDeclarationOfSymbolParameter
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFirstDeclarationOfSymbolParameter(symbol) {
    return symbol.declarations &amp;&amp; symbol.declarations.length &gt; 0 &amp;&amp; symbol.declarations[0].kind === 145 /* Parameter */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isForInitializer" id="apidoc.element.typescript.isForInitializer">
        function <span class="apidocSignatureSpan">typescript.</span>isForInitializer
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isForInitializer(node) {
    return isVariableDeclarationList(node)
        || isExpression(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isFunctionBlock" id="apidoc.element.typescript.isFunctionBlock">
        function <span class="apidocSignatureSpan">typescript.</span>isFunctionBlock
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunctionBlock(node) {
    return node &amp;&amp; node.kind === 206 /* Block */ &amp;&amp; isFunctionLike(node.parent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isFunctionBody" id="apidoc.element.typescript.isFunctionBody">
        function <span class="apidocSignatureSpan">typescript.</span>isFunctionBody
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunctionBody(node) {
    return isBlock(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isFunctionLike" id="apidoc.element.typescript.isFunctionLike">
        function <span class="apidocSignatureSpan">typescript.</span>isFunctionLike
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunctionLike(node) {
    return node &amp;&amp; isFunctionLikeKind(node.kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isFunctionLikeKind" id="apidoc.element.typescript.isFunctionLikeKind">
        function <span class="apidocSignatureSpan">typescript.</span>isFunctionLikeKind
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunctionLikeKind(kind) {
    switch (kind) {
        case 151 /* Constructor */:
        case 185 /* FunctionExpression */:
        case 227 /* FunctionDeclaration */:
        case 186 /* ArrowFunction */:
        case 150 /* MethodDeclaration */:
        case 149 /* MethodSignature */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        case 154 /* CallSignature */:
        case 155 /* ConstructSignature */:
        case 156 /* IndexSignature */:
        case 159 /* FunctionType */:
        case 160 /* ConstructorType */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isGeneratedIdentifier" id="apidoc.element.typescript.isGeneratedIdentifier">
        function <span class="apidocSignatureSpan">typescript.</span>isGeneratedIdentifier
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isGeneratedIdentifier(node) {
    // Using `&gt;` here catches both `GeneratedIdentifierKind.None` and `undefined`.
    return isIdentifier(node) &amp;&amp; node.autoGenerateKind &gt; 0 /* None */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isGlobalScopeAugmentation" id="apidoc.element.typescript.isGlobalScopeAugmentation">
        function <span class="apidocSignatureSpan">typescript.</span>isGlobalScopeAugmentation
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isGlobalScopeAugmentation(module) {
    return !!(module.flags &amp; 512 /* GlobalAugmentation */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isHeritageClause" id="apidoc.element.typescript.isHeritageClause">
        function <span class="apidocSignatureSpan">typescript.</span>isHeritageClause
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isHeritageClause(node) {
    return node.kind === 257 /* HeritageClause */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isIdentifier" id="apidoc.element.typescript.isIdentifier">
        function <span class="apidocSignatureSpan">typescript.</span>isIdentifier
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifier(node) {
    return node.kind === 70 /* Identifier */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isIdentifierName" id="apidoc.element.typescript.isIdentifierName">
        function <span class="apidocSignatureSpan">typescript.</span>isIdentifierName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierName(node) {
    var parent = node.parent;
    switch (parent.kind) {
        case 148 /* PropertyDeclaration */:
        case 147 /* PropertySignature */:
        case 150 /* MethodDeclaration */:
        case 149 /* MethodSignature */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        case 262 /* EnumMember */:
        case 259 /* PropertyAssignment */:
        case 178 /* PropertyAccessExpression */:
            // Name in member declaration or property name in property access
            return parent.name === node;
        case 142 /* QualifiedName */:
            // Name on right hand side of dot in a type query
            if (parent.right === node) {
                while (parent.kind === 142 /* QualifiedName */) {
                    parent = parent.parent;
                }
                return parent.kind === 161 /* TypeQuery */;
            }
            return false;
        case 175 /* BindingElement */:
        case 241 /* ImportSpecifier */:
            // Property name in binding element or import specifier
            return parent.propertyName === node;
        case 245 /* ExportSpecifier */:
            // Any name in an export specifier
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isIdentifierPart" id="apidoc.element.typescript.isIdentifierPart">
        function <span class="apidocSignatureSpan">typescript.</span>isIdentifierPart
        <span class="apidocSignatureSpan">(ch, languageVersion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierPart(ch, languageVersion) {
    return ch &gt;= 65 /* A */ &amp;&amp; ch &lt;= 90 /* Z */ || ch &gt;= 97 /* a */ &amp;&amp; ch &lt;= 122 /* z */ ||
        ch &gt;= 48 /* _0 */ &amp;&amp; ch &lt;= 57 /* _9 */ || ch === 36 /* $ */ || ch === 95 /* _ */ ||
        ch &gt; 127 /* maxAsciiCharacter */ &amp;&amp; isUnicodeIdentifierPart(ch, languageVersion);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isIdentifierStart" id="apidoc.element.typescript.isIdentifierStart">
        function <span class="apidocSignatureSpan">typescript.</span>isIdentifierStart
        <span class="apidocSignatureSpan">(ch, languageVersion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierStart(ch, languageVersion) {
    return ch &gt;= 65 /* A */ &amp;&amp; ch &lt;= 90 /* Z */ || ch &gt;= 97 /* a */ &amp;&amp; ch &lt;= 122 /* z */ ||
        ch === 36 /* $ */ || ch === 95 /* _ */ ||
        ch &gt; 127 /* maxAsciiCharacter */ &amp;&amp; isUnicodeIdentifierStart(ch, languageVersion);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isIdentifierText" id="apidoc.element.typescript.isIdentifierText">
        function <span class="apidocSignatureSpan">typescript.</span>isIdentifierText
        <span class="apidocSignatureSpan">(name, languageVersion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierText(name, languageVersion) {
    if (!isIdentifierStart(name.charCodeAt(0), languageVersion)) {
        return false;
    }
    for (var i = 1; i &lt; name.length; i++) {
        if (!isIdentifierPart(name.charCodeAt(i), languageVersion)) {
            return false;
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isIdentifierTypePredicate" id="apidoc.element.typescript.isIdentifierTypePredicate">
        function <span class="apidocSignatureSpan">typescript.</span>isIdentifierTypePredicate
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierTypePredicate(predicate) {
    return predicate &amp;&amp; predicate.kind === 1 /* Identifier */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isImplicitGlob" id="apidoc.element.typescript.isImplicitGlob">
        function <span class="apidocSignatureSpan">typescript.</span>isImplicitGlob
        <span class="apidocSignatureSpan">(lastPathComponent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isImplicitGlob(lastPathComponent) {
    return !/[.*?]/.test(lastPathComponent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isImportClause" id="apidoc.element.typescript.isImportClause">
        function <span class="apidocSignatureSpan">typescript.</span>isImportClause
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isImportClause(node) {
    return node.kind === 238 /* ImportClause */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isImportEqualsDeclaration" id="apidoc.element.typescript.isImportEqualsDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isImportEqualsDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isImportEqualsDeclaration(node) {
    return node.kind === 236 /* ImportEqualsDeclaration */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isImportOrExportSpecifierName" id="apidoc.element.typescript.isImportOrExportSpecifierName">
        function <span class="apidocSignatureSpan">typescript.</span>isImportOrExportSpecifierName
        <span class="apidocSignatureSpan">(location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isImportOrExportSpecifierName(location) {
    return location.parent &amp;&amp;
        (location.parent.kind === 241 /* ImportSpecifier */ || location.parent.kind === 245 /* ExportSpecifier */) &amp;&amp;
        location.parent.propertyName === location;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isImportSpecifier" id="apidoc.element.typescript.isImportSpecifier">
        function <span class="apidocSignatureSpan">typescript.</span>isImportSpecifier
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isImportSpecifier(node) {
    return node.kind === 241 /* ImportSpecifier */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInAmbientContext" id="apidoc.element.typescript.isInAmbientContext">
        function <span class="apidocSignatureSpan">typescript.</span>isInAmbientContext
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInAmbientContext(node) {
    while (node) {
        if (hasModifier(node, 2 /* Ambient */) || (node.kind === 263 /* SourceFile */ &amp;&amp; node.isDeclarationFile)) {
            return true;
        }
        node = node.parent;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInComment" id="apidoc.element.typescript.isInComment">
        function <span class="apidocSignatureSpan">typescript.</span>isInComment
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInComment(sourceFile, position) {
    return isInCommentHelper(sourceFile, position, /*predicate*/ undefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInCommentHelper" id="apidoc.element.typescript.isInCommentHelper">
        function <span class="apidocSignatureSpan">typescript.</span>isInCommentHelper
        <span class="apidocSignatureSpan">(sourceFile, position, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInCommentHelper(sourceFile, position, predicate) {
    var token = getTokenAtPosition(sourceFile, position);
    if (token &amp;&amp; position &lt;= token.getStart(sourceFile)) {
        var commentRanges = ts.getLeadingCommentRanges(sourceFile.text, token.pos);
        // The end marker of a single-line comment does not include the newline character.
        // In the following case, we are inside a comment (^ denotes the cursor position):
        //
        //    // asdf   ^\n
        //
        // But for multi-line comments, we don't want to be inside the comment in the following case:
        //
        //    /* asdf */^
        //
        // Internally, we represent the end of the comment at the newline and closing '/', respectively.
        return predicate ?
            ts.forEach(commentRanges, function (c) { return c.pos &lt; position &amp;&amp;
                (c.kind == 2 /* SingleLineCommentTrivia */ ? position &lt;= c.end : position &lt; c.end) &amp;&amp;
                predicate(c); }) :
            ts.forEach(commentRanges, function (c) { return c.pos &lt; position &amp;&amp;
                (c.kind == 2 /* SingleLineCommentTrivia */ ? position &lt;= c.end : position &lt; c.end); });
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInJavaScriptFile" id="apidoc.element.typescript.isInJavaScriptFile">
        function <span class="apidocSignatureSpan">typescript.</span>isInJavaScriptFile
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInJavaScriptFile(node) {
    return node &amp;&amp; !!(node.flags &amp; 65536 /* JavaScriptFile */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInNonReferenceComment" id="apidoc.element.typescript.isInNonReferenceComment">
        function <span class="apidocSignatureSpan">typescript.</span>isInNonReferenceComment
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInNonReferenceComment(sourceFile, position) {
    return isInCommentHelper(sourceFile, position, isNonReferenceComment);
    function isNonReferenceComment(c) {
        var commentText = sourceFile.text.substring(c.pos, c.end);
        return !tripleSlashDirectivePrefixRegex.test(commentText);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInReferenceComment" id="apidoc.element.typescript.isInReferenceComment">
        function <span class="apidocSignatureSpan">typescript.</span>isInReferenceComment
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInReferenceComment(sourceFile, position) {
    return isInCommentHelper(sourceFile, position, isReferenceComment);
    function isReferenceComment(c) {
        var commentText = sourceFile.text.substring(c.pos, c.end);
        return tripleSlashDirectivePrefixRegex.test(commentText);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInString" id="apidoc.element.typescript.isInString">
        function <span class="apidocSignatureSpan">typescript.</span>isInString
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInString(sourceFile, position) {
    var previousToken = findPrecedingToken(position, sourceFile);
    if (previousToken &amp;&amp; previousToken.kind === 9 /* StringLiteral */) {
        var start = previousToken.getStart();
        var end = previousToken.getEnd();
        // To be "in" one of these literals, the position has to be:
        //   1. entirely within the token text.
        //   2. at the end position of an unterminated token.
        //   3. at the end of a regular expression (due to trailing flags like '/foo/g').
        if (start &lt; position &amp;&amp; position &lt; end) {
            return true;
        }
        if (position === end) {
            return !!previousToken.isUnterminated;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInTemplateString" id="apidoc.element.typescript.isInTemplateString">
        function <span class="apidocSignatureSpan">typescript.</span>isInTemplateString
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInTemplateString(sourceFile, position) {
    var token = getTokenAtPosition(sourceFile, position);
    return ts.isTemplateLiteralKind(token.kind) &amp;&amp; position &gt; token.getStart(sourceFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInsideComment" id="apidoc.element.typescript.isInsideComment">
        function <span class="apidocSignatureSpan">typescript.</span>isInsideComment
        <span class="apidocSignatureSpan">(sourceFile, token, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInsideComment(sourceFile, token, position) {
    // The position has to be: 1. in the leading trivia (before token.getStart()), and 2. within a comment
    return position &lt;= token.getStart(sourceFile) &amp;&amp;
        (isInsideCommentRange(ts.getTrailingCommentRanges(sourceFile.text, token.getFullStart())) ||
            isInsideCommentRange(ts.getLeadingCommentRanges(sourceFile.text, token.getFullStart())));
    function isInsideCommentRange(comments) {
        return ts.forEach(comments, function (comment) {
            // either we are 1. completely inside the comment, or 2. at the end of the comment
            if (comment.pos &lt; position &amp;&amp; position &lt; comment.end) {
                return true;
            }
            else if (position === comment.end) {
                var text = sourceFile.text;
                var width = comment.end - comment.pos;
                // is single line comment or just /*
                if (width &lt;= 2 || text.charCodeAt(comment.pos + 1) === 47 /* slash */) {
                    return true;
                }
                else {
                    // is unterminated multi-line comment
                    return !(text.charCodeAt(comment.end - 1) === 47 /* slash */ &amp;&amp;
                        text.charCodeAt(comment.end - 2) === 42 /* asterisk */);
                }
            }
            return false;
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInsideJsxElementOrAttribute" id="apidoc.element.typescript.isInsideJsxElementOrAttribute">
        function <span class="apidocSignatureSpan">typescript.</span>isInsideJsxElementOrAttribute
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInsideJsxElementOrAttribute(sourceFile, position) {
    var token = getTokenAtPosition(sourceFile, position);
    if (!token) {
        return false;
    }
    if (token.kind === 10 /* JsxText */) {
        return true;
    }
    // &lt;div&gt;Hello |&lt;/div&gt;
    if (token.kind === 26 /* LessThanToken */ &amp;&amp; token.parent.kind === 10 /* JsxText */) {
        return true;
    }
    // &lt;div&gt; { | &lt;/div&gt; or &lt;div a={| &lt;/div&gt;
    if (token.kind === 26 /* LessThanToken */ &amp;&amp; token.parent.kind === 254 /* JsxExpression */) {
        return true;
    }
    // &lt;div&gt; {
    // |
    // } &lt; /div&gt;
    if (token &amp;&amp; token.kind === 17 /* CloseBraceToken */ &amp;&amp; token.parent.kind === 254 /* JsxExpression */) {
        return true;
    }
    // &lt;div&gt;|&lt;/div&gt;
    if (token.kind === 26 /* LessThanToken */ &amp;&amp; token.parent.kind === 251 /* JsxClosingElement */) {
        return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInsideTemplateLiteral" id="apidoc.element.typescript.isInsideTemplateLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>isInsideTemplateLiteral
        <span class="apidocSignatureSpan">(node, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInsideTemplateLiteral(node, position) {
    return ts.isTemplateLiteralKind(node.kind)
        &amp;&amp; (node.getStart() &lt; position &amp;&amp; position &lt; node.getEnd()) || (!!node.isUnterminated &amp;&amp; position === node.getEnd());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInstantiatedModule" id="apidoc.element.typescript.isInstantiatedModule">
        function <span class="apidocSignatureSpan">typescript.</span>isInstantiatedModule
        <span class="apidocSignatureSpan">(node, preserveConstEnums)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInstantiatedModule(node, preserveConstEnums) {
    var moduleState = ts.getModuleInstanceState(node);
    return moduleState === 1 /* Instantiated */ ||
        (preserveConstEnums &amp;&amp; moduleState === 2 /* ConstEnumOnly */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isInternalModuleImportEqualsDeclaration" id="apidoc.element.typescript.isInternalModuleImportEqualsDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isInternalModuleImportEqualsDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInternalModuleImportEqualsDeclaration(node) {
    return node.kind === 236 /* ImportEqualsDeclaration */ &amp;&amp; node.moduleReference.kind !== 247 /* ExternalModuleReference */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isIntrinsicJsxName" id="apidoc.element.typescript.isIntrinsicJsxName">
        function <span class="apidocSignatureSpan">typescript.</span>isIntrinsicJsxName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIntrinsicJsxName(name) {
    var ch = name.substr(0, 1);
    return ch.toLowerCase() === ch;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isIterationStatement" id="apidoc.element.typescript.isIterationStatement">
        function <span class="apidocSignatureSpan">typescript.</span>isIterationStatement
        <span class="apidocSignatureSpan">(node, lookInLabeledStatements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIterationStatement(node, lookInLabeledStatements) {
    switch (node.kind) {
        case 213 /* ForStatement */:
        case 214 /* ForInStatement */:
        case 215 /* ForOfStatement */:
        case 211 /* DoStatement */:
        case 212 /* WhileStatement */:
            return true;
        case 221 /* LabeledStatement */:
            return lookInLabeledStatements &amp;&amp; isIterationStatement(node.statement, lookInLabeledStatements);
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJSDocConstructSignature" id="apidoc.element.typescript.isJSDocConstructSignature">
        function <span class="apidocSignatureSpan">typescript.</span>isJSDocConstructSignature
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJSDocConstructSignature(node) {
    return node.kind === 277 /* JSDocFunctionType */ &amp;&amp;
        node.parameters.length &gt; 0 &amp;&amp;
        node.parameters[0].type.kind === 279 /* JSDocConstructorType */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJSDocNamespaceBody" id="apidoc.element.typescript.isJSDocNamespaceBody">
        function <span class="apidocSignatureSpan">typescript.</span>isJSDocNamespaceBody
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJSDocNamespaceBody(node) {
    var kind = node.kind;
    return kind === 70<span class="apidocCodeCommentSpan"> /* Identifier */
</span>        || kind === 232 /* ModuleDeclaration */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJSDocNode" id="apidoc.element.typescript.isJSDocNode">
        function <span class="apidocSignatureSpan">typescript.</span>isJSDocNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJSDocNode(node) {
    return node.kind &gt;= 265 /* FirstJSDocNode */ &amp;&amp; node.kind &lt;= 294 /* LastJSDocNode */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJSDocTag" id="apidoc.element.typescript.isJSDocTag">
        function <span class="apidocSignatureSpan">typescript.</span>isJSDocTag
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJSDocTag(node) {
    return node.kind &gt;= 281 /* FirstJSDocTagNode */ &amp;&amp; node.kind &lt;= 294 /* LastJSDocTagNode */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJSXTagName" id="apidoc.element.typescript.isJSXTagName">
        function <span class="apidocSignatureSpan">typescript.</span>isJSXTagName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJSXTagName(node) {
    var parent = node.parent;
    if (parent.kind === 250 /* JsxOpeningElement */ ||
        parent.kind === 249 /* JsxSelfClosingElement */ ||
        parent.kind === 251 /* JsxClosingElement */) {
        return parent.tagName === node;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJsxAttribute" id="apidoc.element.typescript.isJsxAttribute">
        function <span class="apidocSignatureSpan">typescript.</span>isJsxAttribute
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJsxAttribute(node) {
    return node.kind === 252 /* JsxAttribute */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJsxAttributeLike" id="apidoc.element.typescript.isJsxAttributeLike">
        function <span class="apidocSignatureSpan">typescript.</span>isJsxAttributeLike
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJsxAttributeLike(node) {
    var kind = node.kind;
    return kind === 252<span class="apidocCodeCommentSpan"> /* JsxAttribute */
</span>        || kind === 253 /* JsxSpreadAttribute */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJsxChild" id="apidoc.element.typescript.isJsxChild">
        function <span class="apidocSignatureSpan">typescript.</span>isJsxChild
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJsxChild(node) {
    var kind = node.kind;
    return kind === 248<span class="apidocCodeCommentSpan"> /* JsxElement */
</span>        || kind === 254 /* JsxExpression */
        || kind === 249 /* JsxSelfClosingElement */
        || kind === 10 /* JsxText */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJsxClosingElement" id="apidoc.element.typescript.isJsxClosingElement">
        function <span class="apidocSignatureSpan">typescript.</span>isJsxClosingElement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJsxClosingElement(node) {
    return node.kind === 251 /* JsxClosingElement */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJsxOpeningElement" id="apidoc.element.typescript.isJsxOpeningElement">
        function <span class="apidocSignatureSpan">typescript.</span>isJsxOpeningElement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJsxOpeningElement(node) {
    return node.kind === 250 /* JsxOpeningElement */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJsxSpreadAttribute" id="apidoc.element.typescript.isJsxSpreadAttribute">
        function <span class="apidocSignatureSpan">typescript.</span>isJsxSpreadAttribute
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJsxSpreadAttribute(node) {
    return node.kind === 253 /* JsxSpreadAttribute */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJsxTagNameExpression" id="apidoc.element.typescript.isJsxTagNameExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isJsxTagNameExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJsxTagNameExpression(node) {
    var kind = node.kind;
    return kind === 98<span class="apidocCodeCommentSpan"> /* ThisKeyword */
</span>        || kind === 70 /* Identifier */
        || kind === 178 /* PropertyAccessExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isJumpStatementTarget" id="apidoc.element.typescript.isJumpStatementTarget">
        function <span class="apidocSignatureSpan">typescript.</span>isJumpStatementTarget
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJumpStatementTarget(node) {
    return node.kind === 70 /* Identifier */ &amp;&amp;
        (node.parent.kind === 217 /* BreakStatement */ || node.parent.kind === 216 /* ContinueStatement */) &amp;&amp;
        node.parent.label === node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isKeyword" id="apidoc.element.typescript.isKeyword">
        function <span class="apidocSignatureSpan">typescript.</span>isKeyword
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isKeyword(token) {
    return 71 /* FirstKeyword */ &lt;= token &amp;&amp; token &lt;= 141 /* LastKeyword */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLabelName" id="apidoc.element.typescript.isLabelName">
        function <span class="apidocSignatureSpan">typescript.</span>isLabelName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLabelName(node) {
    return isLabelOfLabeledStatement(node) || isJumpStatementTarget(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLeftHandSideExpression" id="apidoc.element.typescript.isLeftHandSideExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isLeftHandSideExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLeftHandSideExpression(node) {
    return isLeftHandSideExpressionKind(ts.skipPartiallyEmittedExpressions(node).kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLet" id="apidoc.element.typescript.isLet">
        function <span class="apidocSignatureSpan">typescript.</span>isLet
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLet(node) {
    return !!(ts.getCombinedNodeFlags(node) &amp; 1 /* Let */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLineBreak" id="apidoc.element.typescript.isLineBreak">
        function <span class="apidocSignatureSpan">typescript.</span>isLineBreak
        <span class="apidocSignatureSpan">(ch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLineBreak(ch) {
    // ES5 7.3:
    // The ECMAScript line terminator characters are listed in Table 3.
    //     Table 3: Line Terminator Characters
    //     Code Unit Value     Name                    Formal Name
    //     \u000A              Line Feed               &lt;LF&gt;
    //     \u000D              Carriage Return         &lt;CR&gt;
    //     \u2028              Line separator          &lt;LS&gt;
    //     \u2029              Paragraph separator     &lt;PS&gt;
    // Only the characters in Table 3 are treated as line terminators. Other new line or line
    // breaking characters are treated as white space but not as line terminators.
    return ch === 10 /* lineFeed */ ||
        ch === 13 /* carriageReturn */ ||
        ch === 8232 /* lineSeparator */ ||
        ch === 8233 /* paragraphSeparator */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLiteralComputedPropertyDeclarationName" id="apidoc.element.typescript.isLiteralComputedPropertyDeclarationName">
        function <span class="apidocSignatureSpan">typescript.</span>isLiteralComputedPropertyDeclarationName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLiteralComputedPropertyDeclarationName(node) {
    return (node.kind === 9 /* StringLiteral */ || node.kind === 8 /* NumericLiteral */) &amp;&amp;
        node.parent.kind === 143 /* ComputedPropertyName */ &amp;&amp;
        isDeclaration(node.parent.parent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLiteralExpression" id="apidoc.element.typescript.isLiteralExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isLiteralExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLiteralExpression(node) {
    return isLiteralKind(node.kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLiteralKind" id="apidoc.element.typescript.isLiteralKind">
        function <span class="apidocSignatureSpan">typescript.</span>isLiteralKind
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLiteralKind(kind) {
    return 8 /* FirstLiteralToken */ &lt;= kind &amp;&amp; kind &lt;= 12 /* LastLiteralToken */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLiteralNameOfPropertyDeclarationOrIndexAccess" id="apidoc.element.typescript.isLiteralNameOfPropertyDeclarationOrIndexAccess">
        function <span class="apidocSignatureSpan">typescript.</span>isLiteralNameOfPropertyDeclarationOrIndexAccess
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLiteralNameOfPropertyDeclarationOrIndexAccess(node) {
    if (node.kind === 9 /* StringLiteral */ || node.kind === 8 /* NumericLiteral */) {
        switch (node.parent.kind) {
            case 148 /* PropertyDeclaration */:
            case 147 /* PropertySignature */:
            case 259 /* PropertyAssignment */:
            case 262 /* EnumMember */:
            case 150 /* MethodDeclaration */:
            case 149 /* MethodSignature */:
            case 152 /* GetAccessor */:
            case 153 /* SetAccessor */:
            case 232 /* ModuleDeclaration */:
                return node.parent.name === node;
            case 179 /* ElementAccessExpression */:
                return node.parent.argumentExpression === node;
            case 143 /* ComputedPropertyName */:
                return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLocalName" id="apidoc.element.typescript.isLocalName">
        function <span class="apidocSignatureSpan">typescript.</span>isLocalName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLocalName(node) {
    return (ts.getEmitFlags(node) &amp; 16384 /* LocalName */) !== 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isLogicalOperator" id="apidoc.element.typescript.isLogicalOperator">
        function <span class="apidocSignatureSpan">typescript.</span>isLogicalOperator
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLogicalOperator(token) {
    return token === 53<span class="apidocCodeCommentSpan"> /* BarBarToken */
</span>        || token === 52 /* AmpersandAmpersandToken */
        || token === 50 /* ExclamationToken */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isMergedWithClass" id="apidoc.element.typescript.isMergedWithClass">
        function <span class="apidocSignatureSpan">typescript.</span>isMergedWithClass
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isMergedWithClass(node) {
    if (node.symbol) {
        for (var _i = 0, _a = node.symbol.declarations; _i &lt; _a.length; _i++) {
            var declaration = _a[_i];
            if (declaration.kind === 228 /* ClassDeclaration */ &amp;&amp; declaration !== node) {
                return true;
            }
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isMethodDeclaration" id="apidoc.element.typescript.isMethodDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isMethodDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isMethodDeclaration(node) {
    return node.kind === 150 /* MethodDeclaration */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isModifier" id="apidoc.element.typescript.isModifier">
        function <span class="apidocSignatureSpan">typescript.</span>isModifier
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isModifier(node) {
    return isModifierKind(node.kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isModifierKind" id="apidoc.element.typescript.isModifierKind">
        function <span class="apidocSignatureSpan">typescript.</span>isModifierKind
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isModifierKind(token) {
    switch (token) {
        case 116 /* AbstractKeyword */:
        case 119 /* AsyncKeyword */:
        case 75 /* ConstKeyword */:
        case 123 /* DeclareKeyword */:
        case 78 /* DefaultKeyword */:
        case 83 /* ExportKeyword */:
        case 113 /* PublicKeyword */:
        case 111 /* PrivateKeyword */:
        case 112 /* ProtectedKeyword */:
        case 130 /* ReadonlyKeyword */:
        case 114 /* StaticKeyword */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isModuleBody" id="apidoc.element.typescript.isModuleBody">
        function <span class="apidocSignatureSpan">typescript.</span>isModuleBody
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isModuleBody(node) {
    var kind = node.kind;
    return kind === 233<span class="apidocCodeCommentSpan"> /* ModuleBlock */
</span>        || kind === 232 /* ModuleDeclaration */
        || kind === 70 /* Identifier */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isModuleName" id="apidoc.element.typescript.isModuleName">
        function <span class="apidocSignatureSpan">typescript.</span>isModuleName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isModuleName(node) {
    var kind = node.kind;
    return kind === 70<span class="apidocCodeCommentSpan"> /* Identifier */
</span>        || kind === 9 /* StringLiteral */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isModuleOrEnumDeclaration" id="apidoc.element.typescript.isModuleOrEnumDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isModuleOrEnumDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isModuleOrEnumDeclaration(node) {
    return node.kind === 232 /* ModuleDeclaration */ || node.kind === 231 /* EnumDeclaration */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isModuleReference" id="apidoc.element.typescript.isModuleReference">
        function <span class="apidocSignatureSpan">typescript.</span>isModuleReference
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isModuleReference(node) {
    var kind = node.kind;
    return kind === 247<span class="apidocCodeCommentSpan"> /* ExternalModuleReference */
</span>        || kind === 142 /* QualifiedName */
        || kind === 70 /* Identifier */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNameOfFunctionDeclaration" id="apidoc.element.typescript.isNameOfFunctionDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isNameOfFunctionDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNameOfFunctionDeclaration(node) {
    return node.kind === 70 /* Identifier */ &amp;&amp;
        ts.isFunctionLike(node.parent) &amp;&amp; node.parent.name === node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNameOfModuleDeclaration" id="apidoc.element.typescript.isNameOfModuleDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isNameOfModuleDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNameOfModuleDeclaration(node) {
    return node.parent.kind === 232 /* ModuleDeclaration */ &amp;&amp; node.parent.name === node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNamedExports" id="apidoc.element.typescript.isNamedExports">
        function <span class="apidocSignatureSpan">typescript.</span>isNamedExports
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNamedExports(node) {
    return node.kind === 244 /* NamedExports */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNamedImportBindings" id="apidoc.element.typescript.isNamedImportBindings">
        function <span class="apidocSignatureSpan">typescript.</span>isNamedImportBindings
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNamedImportBindings(node) {
    var kind = node.kind;
    return kind === 240<span class="apidocCodeCommentSpan"> /* NamedImports */
</span>        || kind === 239 /* NamespaceImport */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNamespaceBody" id="apidoc.element.typescript.isNamespaceBody">
        function <span class="apidocSignatureSpan">typescript.</span>isNamespaceBody
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNamespaceBody(node) {
    var kind = node.kind;
    return kind === 233<span class="apidocCodeCommentSpan"> /* ModuleBlock */
</span>        || kind === 232 /* ModuleDeclaration */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNewExpressionTarget" id="apidoc.element.typescript.isNewExpressionTarget">
        function <span class="apidocSignatureSpan">typescript.</span>isNewExpressionTarget
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNewExpressionTarget(node) {
    return isCallOrNewExpressionTarget(node, 181 /* NewExpression */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNoSubstitutionTemplateLiteral" id="apidoc.element.typescript.isNoSubstitutionTemplateLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>isNoSubstitutionTemplateLiteral
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNoSubstitutionTemplateLiteral(node) {
    return node.kind === 12 /* NoSubstitutionTemplateLiteral */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNodeArray" id="apidoc.element.typescript.isNodeArray">
        function <span class="apidocSignatureSpan">typescript.</span>isNodeArray
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNodeArray(array) {
    return array.hasOwnProperty("pos")
        &amp;&amp; array.hasOwnProperty("end");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNodeDescendantOf" id="apidoc.element.typescript.isNodeDescendantOf">
        function <span class="apidocSignatureSpan">typescript.</span>isNodeDescendantOf
        <span class="apidocSignatureSpan">(node, ancestor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNodeDescendantOf(node, ancestor) {
    while (node) {
        if (node === ancestor)
            return true;
        node = node.parent;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNotEmittedOrPartiallyEmittedNode" id="apidoc.element.typescript.isNotEmittedOrPartiallyEmittedNode">
        function <span class="apidocSignatureSpan">typescript.</span>isNotEmittedOrPartiallyEmittedNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNotEmittedOrPartiallyEmittedNode(node) {
    return isNotEmittedStatement(node)
        || isPartiallyEmittedExpression(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isNotEmittedStatement" id="apidoc.element.typescript.isNotEmittedStatement">
        function <span class="apidocSignatureSpan">typescript.</span>isNotEmittedStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNotEmittedStatement(node) {
    return node.kind === 296 /* NotEmittedStatement */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isObjectBindingOrAssignmentPattern" id="apidoc.element.typescript.isObjectBindingOrAssignmentPattern">
        function <span class="apidocSignatureSpan">typescript.</span>isObjectBindingOrAssignmentPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObjectBindingOrAssignmentPattern(node) {
    switch (node.kind) {
        case 173 /* ObjectBindingPattern */:
        case 177 /* ObjectLiteralExpression */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isObjectBindingPattern" id="apidoc.element.typescript.isObjectBindingPattern">
        function <span class="apidocSignatureSpan">typescript.</span>isObjectBindingPattern
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObjectBindingPattern(node) {
    return node.kind === 173 /* ObjectBindingPattern */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isObjectLiteralElementLike" id="apidoc.element.typescript.isObjectLiteralElementLike">
        function <span class="apidocSignatureSpan">typescript.</span>isObjectLiteralElementLike
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObjectLiteralElementLike(node) {
    var kind = node.kind;
    return kind === 259<span class="apidocCodeCommentSpan"> /* PropertyAssignment */
</span>        || kind === 260 /* ShorthandPropertyAssignment */
        || kind === 261 /* SpreadAssignment */
        || kind === 150 /* MethodDeclaration */
        || kind === 152 /* GetAccessor */
        || kind === 153 /* SetAccessor */
        || kind === 246 /* MissingDeclaration */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isObjectLiteralExpression" id="apidoc.element.typescript.isObjectLiteralExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isObjectLiteralExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObjectLiteralExpression(node) {
    return node.kind === 177 /* ObjectLiteralExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isObjectLiteralMethod" id="apidoc.element.typescript.isObjectLiteralMethod">
        function <span class="apidocSignatureSpan">typescript.</span>isObjectLiteralMethod
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObjectLiteralMethod(node) {
    return node &amp;&amp; node.kind === 150 /* MethodDeclaration */ &amp;&amp; node.parent.kind === 177 /* ObjectLiteralExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isObjectLiteralOrClassExpressionMethod" id="apidoc.element.typescript.isObjectLiteralOrClassExpressionMethod">
        function <span class="apidocSignatureSpan">typescript.</span>isObjectLiteralOrClassExpressionMethod
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObjectLiteralOrClassExpressionMethod(node) {
    return node.kind === 150 /* MethodDeclaration */ &amp;&amp;
        (node.parent.kind === 177 /* ObjectLiteralExpression */ ||
            node.parent.kind === 198 /* ClassExpression */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isOctalDigit" id="apidoc.element.typescript.isOctalDigit">
        function <span class="apidocSignatureSpan">typescript.</span>isOctalDigit
        <span class="apidocSignatureSpan">(ch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOctalDigit(ch) {
    return ch &gt;= 48 /* _0 */ &amp;&amp; ch &lt;= 55 /* _7 */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isOmittedExpression" id="apidoc.element.typescript.isOmittedExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isOmittedExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOmittedExpression(node) {
    return node.kind === 199 /* OmittedExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isParameter" id="apidoc.element.typescript.isParameter">
        function <span class="apidocSignatureSpan">typescript.</span>isParameter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isParameter(node) {
    return node.kind === 145 /* Parameter */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isParameterDeclaration" id="apidoc.element.typescript.isParameterDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isParameterDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isParameterDeclaration(node) {
    var root = getRootDeclaration(node);
    return root.kind === 145 /* Parameter */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isParameterPropertyDeclaration" id="apidoc.element.typescript.isParameterPropertyDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isParameterPropertyDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isParameterPropertyDeclaration(node) {
    return ts.hasModifier(node, 92 /* ParameterPropertyModifier */) &amp;&amp; node.parent.kind === 151 /* Constructor */ &amp;&amp; ts.isClassLike
(node.parent.parent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isParseTreeNode" id="apidoc.element.typescript.isParseTreeNode">
        function <span class="apidocSignatureSpan">typescript.</span>isParseTreeNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isParseTreeNode(node) {
    return (node.flags &amp; 8 /* Synthesized */) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPartOfExpression" id="apidoc.element.typescript.isPartOfExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isPartOfExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPartOfExpression(node) {
    switch (node.kind) {
        case 98 /* ThisKeyword */:
        case 96 /* SuperKeyword */:
        case 94 /* NullKeyword */:
        case 100 /* TrueKeyword */:
        case 85 /* FalseKeyword */:
        case 11 /* RegularExpressionLiteral */:
        case 176 /* ArrayLiteralExpression */:
        case 177 /* ObjectLiteralExpression */:
        case 178 /* PropertyAccessExpression */:
        case 179 /* ElementAccessExpression */:
        case 180 /* CallExpression */:
        case 181 /* NewExpression */:
        case 182 /* TaggedTemplateExpression */:
        case 201 /* AsExpression */:
        case 183 /* TypeAssertionExpression */:
        case 202 /* NonNullExpression */:
        case 184 /* ParenthesizedExpression */:
        case 185 /* FunctionExpression */:
        case 198 /* ClassExpression */:
        case 186 /* ArrowFunction */:
        case 189 /* VoidExpression */:
        case 187 /* DeleteExpression */:
        case 188 /* TypeOfExpression */:
        case 191 /* PrefixUnaryExpression */:
        case 192 /* PostfixUnaryExpression */:
        case 193 /* BinaryExpression */:
        case 194 /* ConditionalExpression */:
        case 197 /* SpreadElement */:
        case 195 /* TemplateExpression */:
        case 12 /* NoSubstitutionTemplateLiteral */:
        case 199 /* OmittedExpression */:
        case 248 /* JsxElement */:
        case 249 /* JsxSelfClosingElement */:
        case 196 /* YieldExpression */:
        case 190 /* AwaitExpression */:
        case 203 /* MetaProperty */:
            return true;
        case 142 /* QualifiedName */:
            while (node.parent.kind === 142 /* QualifiedName */) {
                node = node.parent;
            }
            return node.parent.kind === 161 /* TypeQuery */ || isJSXTagName(node);
        case 70 /* Identifier */:
            if (node.parent.kind === 161 /* TypeQuery */ || isJSXTagName(node)) {
                return true;
            }
        // fall through
        case 8 /* NumericLiteral */:
        case 9 /* StringLiteral */:
        case 98 /* ThisKeyword */:
            var parent = node.parent;
            switch (parent.kind) {
                case 225 /* VariableDeclaration */:
                case 145 /* Parameter */:
                case 148 /* PropertyDeclaration */:
                case 147 /* PropertySignature */:
                case 262 /* EnumMember */:
                case 259 /* PropertyAssignment */:
                case 175 /* BindingElement */:
                    return parent.initializer === node;
                case 209 /* ExpressionStatement */:
                case 210 /* IfStatement */:
                case 211 /* DoStatement */:
                case 212 /* WhileStatement */:
                case 218 /* ReturnStatement */:
                case 219 /* WithStatement */:
                case 220 /* SwitchStatement */:
                case 255 /* CaseClause */:
                case 222 /* ThrowStatement */:
                case 220 /* SwitchStatement */:
                    return parent.expression === node;
                case 213 /* ForStatement */:
                    var forStatement = parent;
                    return (forStatement.initializer === node &amp;&amp; forStatement.initializer.kind !== 226 /* VariableDeclarationList
 */) ||
                        forStatement.condition === node ||
                        forStatement.incrementor === node;
                case 214 /* ForInStatement */:
                case 215 /* ForOfStatement */:
                    var forInStatement = parent;
                    return (forInStatement.initializer === node &amp;&amp; forInStatement.initializer.kind !== 226 /* VariableDeclarationList
 */) ||
                        forInStatement.expression === node;
                case 183 /* TypeAssertionExpression */:
                case 201 /* AsExpression */:
                    return node === parent.expression;
                case 204 /* TemplateSpan */:
                    return node === parent.expression;
                case 143 /* C ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPartOfTypeNode" id="apidoc.element.typescript.isPartOfTypeNode">
        function <span class="apidocSignatureSpan">typescript.</span>isPartOfTypeNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPartOfTypeNode(node) {
    if (157 /* FirstTypeNode */ &lt;= node.kind &amp;&amp; node.kind &lt;= 172 /* LastTypeNode */) {
        return true;
    }
    switch (node.kind) {
        case 118 /* AnyKeyword */:
        case 132 /* NumberKeyword */:
        case 135 /* StringKeyword */:
        case 121 /* BooleanKeyword */:
        case 136 /* SymbolKeyword */:
        case 138 /* UndefinedKeyword */:
        case 129 /* NeverKeyword */:
            return true;
        case 104 /* VoidKeyword */:
            return node.parent.kind !== 189 /* VoidExpression */;
        case 200 /* ExpressionWithTypeArguments */:
            return !isExpressionWithTypeArgumentsInClassExtendsClause(node);
        // Identifiers and qualified names may be type nodes, depending on their context. Climb
        // above them to find the lowest container
        case 70 /* Identifier */:
            // If the identifier is the RHS of a qualified name, then it's a type iff its parent is.
            if (node.parent.kind === 142 /* QualifiedName */ &amp;&amp; node.parent.right === node) {
                node = node.parent;
            }
            else if (node.parent.kind === 178 /* PropertyAccessExpression */ &amp;&amp; node.parent.name === node) {
                node = node.parent;
            }
            // At this point, node is either a qualified name or an identifier
            ts.Debug.assert(node.kind === 70 /* Identifier */ || node.kind === 142 /* QualifiedName */ || node.kind === 178 /* PropertyAccessExpression
 */, "'node' was expected to be a qualified name, identifier or property access in 'isPartOfTypeNode'.");
        case 142 /* QualifiedName */:
        case 178 /* PropertyAccessExpression */:
        case 98 /* ThisKeyword */:
            var parent = node.parent;
            if (parent.kind === 161 /* TypeQuery */) {
                return false;
            }
            // Do not recursively call isPartOfTypeNode on the parent. In the example:
            //
            //     let a: A.B.C;
            //
            // Calling isPartOfTypeNode would consider the qualified name A.B a type node. Only C or
            // A.B.C is a type node.
            if (157 /* FirstTypeNode */ &lt;= parent.kind &amp;&amp; parent.kind &lt;= 172 /* LastTypeNode */) {
                return true;
            }
            switch (parent.kind) {
                case 200 /* ExpressionWithTypeArguments */:
                    return !isExpressionWithTypeArgumentsInClassExtendsClause(parent);
                case 144 /* TypeParameter */:
                    return node === parent.constraint;
                case 148 /* PropertyDeclaration */:
                case 147 /* PropertySignature */:
                case 145 /* Parameter */:
                case 225 /* VariableDeclaration */:
                    return node === parent.type;
                case 227 /* FunctionDeclaration */:
                case 185 /* FunctionExpression */:
                case 186 /* ArrowFunction */:
                case 151 /* Constructor */:
                case 150 /* MethodDeclaration */:
                case 149 /* MethodSignature */:
                case 152 /* GetAccessor */:
                case 153 /* SetAccessor */:
                    return node === parent.type;
                case 154 /* CallSignature */:
                case 155 /* ConstructSignature */:
                case 156 /* IndexSignature */:
                    return node === parent.type;
                case 183 /* TypeAssertionExpression */:
                    return node === parent.type;
                case 180 /* CallExpression */:
                case 181 /* NewExpression */:
                    return parent.typeArguments &amp;&amp; ts.indexOf(parent.typeArguments, node) &gt;= 0;
                case 182 /* TaggedTemplateExpression */:
                    // TODO (drosen): TaggedTemplateExpressions may eventually support type arguments.
                    return false;
            }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPartiallyEmittedExpression" id="apidoc.element.typescript.isPartiallyEmittedExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isPartiallyEmittedExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPartiallyEmittedExpression(node) {
    return node.kind === 297 /* PartiallyEmittedExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPrefixUnaryExpression" id="apidoc.element.typescript.isPrefixUnaryExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isPrefixUnaryExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPrefixUnaryExpression(node) {
    return node.kind === 191 /* PrefixUnaryExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPrologueDirective" id="apidoc.element.typescript.isPrologueDirective">
        function <span class="apidocSignatureSpan">typescript.</span>isPrologueDirective
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPrologueDirective(node) {
    return node.kind === 209<span class="apidocCodeCommentSpan"> /* ExpressionStatement */
</span>        &amp;&amp; node.expression.kind === 9 /* StringLiteral */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPropertyAccessExpression" id="apidoc.element.typescript.isPropertyAccessExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isPropertyAccessExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPropertyAccessExpression(node) {
    return node.kind === 178 /* PropertyAccessExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPropertyAssignment" id="apidoc.element.typescript.isPropertyAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>isPropertyAssignment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPropertyAssignment(node) {
    return node.kind === 259 /* PropertyAssignment */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPropertyName" id="apidoc.element.typescript.isPropertyName">
        function <span class="apidocSignatureSpan">typescript.</span>isPropertyName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPropertyName(node) {
    var kind = node.kind;
    return kind === 70<span class="apidocCodeCommentSpan"> /* Identifier */
</span>        || kind === 9 /* StringLiteral */
        || kind === 8 /* NumericLiteral */
        || kind === 143 /* ComputedPropertyName */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPunctuation" id="apidoc.element.typescript.isPunctuation">
        function <span class="apidocSignatureSpan">typescript.</span>isPunctuation
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPunctuation(kind) {
    return 16 /* FirstPunctuation */ &lt;= kind &amp;&amp; kind &lt;= 69 /* LastPunctuation */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isPushOrUnshiftIdentifier" id="apidoc.element.typescript.isPushOrUnshiftIdentifier">
        function <span class="apidocSignatureSpan">typescript.</span>isPushOrUnshiftIdentifier
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPushOrUnshiftIdentifier(node) {
    return node.text === "push" || node.text === "unshift";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isQualifiedName" id="apidoc.element.typescript.isQualifiedName">
        function <span class="apidocSignatureSpan">typescript.</span>isQualifiedName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isQualifiedName(node) {
    return node.kind === 142 /* QualifiedName */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isRequireCall" id="apidoc.element.typescript.isRequireCall">
        function <span class="apidocSignatureSpan">typescript.</span>isRequireCall
        <span class="apidocSignatureSpan">(expression, checkArgumentIsStringLiteral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRequireCall(expression, checkArgumentIsStringLiteral) {
    // of the form 'require("name")'
    var isRequire = expression.kind === 180 /* CallExpression */ &amp;&amp;
        expression.expression.kind === 70 /* Identifier */ &amp;&amp;
        expression.expression.text === "require" &amp;&amp;
        expression.arguments.length === 1;
    return isRequire &amp;&amp; (!checkArgumentIsStringLiteral || expression.arguments[0].kind === 9 /* StringLiteral */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isRestParameter" id="apidoc.element.typescript.isRestParameter">
        function <span class="apidocSignatureSpan">typescript.</span>isRestParameter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRestParameter(node) {
    if (node &amp;&amp; (node.flags &amp; 65536 /* JavaScriptFile */)) {
        if (node.type &amp;&amp; node.type.kind === 278 /* JSDocVariadicType */ ||
            ts.forEach(getJSDocParameterTags(node), function (t) { return t.typeExpression &amp;&amp; t.typeExpression.type.kind === 278
 /* JSDocVariadicType */; })) {
            return true;
        }
    }
    return isDeclaredRestParam(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isRightSideOfPropertyAccess" id="apidoc.element.typescript.isRightSideOfPropertyAccess">
        function <span class="apidocSignatureSpan">typescript.</span>isRightSideOfPropertyAccess
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRightSideOfPropertyAccess(node) {
    return node &amp;&amp; node.parent &amp;&amp; node.parent.kind === 178 /* PropertyAccessExpression */ &amp;&amp; node.parent.name === node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isRightSideOfQualifiedName" id="apidoc.element.typescript.isRightSideOfQualifiedName">
        function <span class="apidocSignatureSpan">typescript.</span>isRightSideOfQualifiedName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRightSideOfQualifiedName(node) {
    return node.parent.kind === 142 /* QualifiedName */ &amp;&amp; node.parent.right === node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isRightSideOfQualifiedNameOrPropertyAccess" id="apidoc.element.typescript.isRightSideOfQualifiedNameOrPropertyAccess">
        function <span class="apidocSignatureSpan">typescript.</span>isRightSideOfQualifiedNameOrPropertyAccess
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRightSideOfQualifiedNameOrPropertyAccess(node) {
    return (node.parent.kind === 142 /* QualifiedName */ &amp;&amp; node.parent.right === node) ||
        (node.parent.kind === 178 /* PropertyAccessExpression */ &amp;&amp; node.parent.name === node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isRootedDiskPath" id="apidoc.element.typescript.isRootedDiskPath">
        function <span class="apidocSignatureSpan">typescript.</span>isRootedDiskPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRootedDiskPath(path) {
    return getRootLength(path) !== 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isShorthandAmbientModuleSymbol" id="apidoc.element.typescript.isShorthandAmbientModuleSymbol">
        function <span class="apidocSignatureSpan">typescript.</span>isShorthandAmbientModuleSymbol
        <span class="apidocSignatureSpan">(moduleSymbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isShorthandAmbientModuleSymbol(moduleSymbol) {
    return isShorthandAmbientModule(moduleSymbol.valueDeclaration);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isShorthandPropertyAssignment" id="apidoc.element.typescript.isShorthandPropertyAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>isShorthandPropertyAssignment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isShorthandPropertyAssignment(node) {
    return node.kind === 260 /* ShorthandPropertyAssignment */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isSimpleExpression" id="apidoc.element.typescript.isSimpleExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isSimpleExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSimpleExpression(node) {
    return isSimpleExpressionWorker(node, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isSingleOrDoubleQuote" id="apidoc.element.typescript.isSingleOrDoubleQuote">
        function <span class="apidocSignatureSpan">typescript.</span>isSingleOrDoubleQuote
        <span class="apidocSignatureSpan">(charCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSingleOrDoubleQuote(charCode) {
    return charCode === 39 /* singleQuote */ || charCode === 34 /* doubleQuote */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isSourceFile" id="apidoc.element.typescript.isSourceFile">
        function <span class="apidocSignatureSpan">typescript.</span>isSourceFile
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSourceFile(node) {
    return node.kind === 263 /* SourceFile */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isSourceFileJavaScript" id="apidoc.element.typescript.isSourceFileJavaScript">
        function <span class="apidocSignatureSpan">typescript.</span>isSourceFileJavaScript
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSourceFileJavaScript(file) {
    return isInJavaScriptFile(file);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isSpreadExpression" id="apidoc.element.typescript.isSpreadExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isSpreadExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSpreadExpression(node) {
    return node.kind === 197 /* SpreadElement */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isStatement" id="apidoc.element.typescript.isStatement">
        function <span class="apidocSignatureSpan">typescript.</span>isStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStatement(node) {
    var kind = node.kind;
    return isStatementKindButNotDeclarationKind(kind)
        || isDeclarationStatementKind(kind)
        || kind === 206 /* Block */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isStatementButNotDeclaration" id="apidoc.element.typescript.isStatementButNotDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isStatementButNotDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStatementButNotDeclaration(node) {
    return isStatementKindButNotDeclarationKind(node.kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isStatementWithLocals" id="apidoc.element.typescript.isStatementWithLocals">
        function <span class="apidocSignatureSpan">typescript.</span>isStatementWithLocals
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStatementWithLocals(node) {
    switch (node.kind) {
        case 206 /* Block */:
        case 234 /* CaseBlock */:
        case 213 /* ForStatement */:
        case 214 /* ForInStatement */:
        case 215 /* ForOfStatement */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isStringLiteralOrJsxExpression" id="apidoc.element.typescript.isStringLiteralOrJsxExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isStringLiteralOrJsxExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStringLiteralOrJsxExpression(node) {
    var kind = node.kind;
    return kind === 9<span class="apidocCodeCommentSpan"> /* StringLiteral */
</span>        || kind === 254 /* JsxExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isStringOrNumericLiteral" id="apidoc.element.typescript.isStringOrNumericLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>isStringOrNumericLiteral
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStringOrNumericLiteral(node) {
    var kind = node.kind;
    return kind === 9<span class="apidocCodeCommentSpan"> /* StringLiteral */
</span>        || kind === 8 /* NumericLiteral */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isStringOrRegularExpressionOrTemplateLiteral" id="apidoc.element.typescript.isStringOrRegularExpressionOrTemplateLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>isStringOrRegularExpressionOrTemplateLiteral
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStringOrRegularExpressionOrTemplateLiteral(kind) {
    if (kind === 9<span class="apidocCodeCommentSpan"> /* StringLiteral */
</span>        || kind === 11 /* RegularExpressionLiteral */
        || ts.isTemplateLiteralKind(kind)) {
        return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isSuperCall" id="apidoc.element.typescript.isSuperCall">
        function <span class="apidocSignatureSpan">typescript.</span>isSuperCall
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSuperCall(n) {
    return n.kind === 180 /* CallExpression */ &amp;&amp; n.expression.kind === 96 /* SuperKeyword */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isSuperProperty" id="apidoc.element.typescript.isSuperProperty">
        function <span class="apidocSignatureSpan">typescript.</span>isSuperProperty
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSuperProperty(node) {
    var kind = node.kind;
    return (kind === 178 /* PropertyAccessExpression */ || kind === 179 /* ElementAccessExpression */)
        &amp;&amp; node.expression.kind === 96 /* SuperKeyword */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isSupportedExpressionWithTypeArguments" id="apidoc.element.typescript.isSupportedExpressionWithTypeArguments">
        function <span class="apidocSignatureSpan">typescript.</span>isSupportedExpressionWithTypeArguments
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSupportedExpressionWithTypeArguments(node) {
    return isSupportedExpressionWithTypeArgumentsRest(node.expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isSupportedSourceFileName" id="apidoc.element.typescript.isSupportedSourceFileName">
        function <span class="apidocSignatureSpan">typescript.</span>isSupportedSourceFileName
        <span class="apidocSignatureSpan">(fileName, compilerOptions, extraFileExtensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSupportedSourceFileName(fileName, compilerOptions, extraFileExtensions) {
    if (!fileName) {
        return false;
    }
    for (var _i = 0, _a = getSupportedExtensions(compilerOptions, extraFileExtensions); _i &lt; _a.length; _i++) {
        var extension = _a[_i];
        if (fileExtensionIs(fileName, extension)) {
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTemplateHead" id="apidoc.element.typescript.isTemplateHead">
        function <span class="apidocSignatureSpan">typescript.</span>isTemplateHead
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTemplateHead(node) {
    return node.kind === 13 /* TemplateHead */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTemplateLiteral" id="apidoc.element.typescript.isTemplateLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>isTemplateLiteral
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTemplateLiteral(node) {
    var kind = node.kind;
    return kind === 195<span class="apidocCodeCommentSpan"> /* TemplateExpression */
</span>        || kind === 12 /* NoSubstitutionTemplateLiteral */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTemplateLiteralKind" id="apidoc.element.typescript.isTemplateLiteralKind">
        function <span class="apidocSignatureSpan">typescript.</span>isTemplateLiteralKind
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTemplateLiteralKind(kind) {
    return 12 /* FirstTemplateToken */ &lt;= kind &amp;&amp; kind &lt;= 15 /* LastTemplateToken */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTemplateMiddleOrTemplateTail" id="apidoc.element.typescript.isTemplateMiddleOrTemplateTail">
        function <span class="apidocSignatureSpan">typescript.</span>isTemplateMiddleOrTemplateTail
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTemplateMiddleOrTemplateTail(node) {
    var kind = node.kind;
    return kind === 14<span class="apidocCodeCommentSpan"> /* TemplateMiddle */
</span>        || kind === 15 /* TemplateTail */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTemplateSpan" id="apidoc.element.typescript.isTemplateSpan">
        function <span class="apidocSignatureSpan">typescript.</span>isTemplateSpan
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTemplateSpan(node) {
    return node.kind === 204 /* TemplateSpan */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTextualLiteralKind" id="apidoc.element.typescript.isTextualLiteralKind">
        function <span class="apidocSignatureSpan">typescript.</span>isTextualLiteralKind
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTextualLiteralKind(kind) {
    return kind === 9 /* StringLiteral */ || kind === 12 /* NoSubstitutionTemplateLiteral */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isThis" id="apidoc.element.typescript.isThis">
        function <span class="apidocSignatureSpan">typescript.</span>isThis
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isThis(node) {
    switch (node.kind) {
        case 98 /* ThisKeyword */:
            // case SyntaxKind.ThisType: TODO: GH#9267
            return true;
        case 70 /* Identifier */:
            // 'this' as a parameter
            return ts.identifierIsThisKeyword(node) &amp;&amp; node.parent.kind === 145 /* Parameter */;
        default:
            return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isThisIdentifier" id="apidoc.element.typescript.isThisIdentifier">
        function <span class="apidocSignatureSpan">typescript.</span>isThisIdentifier
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isThisIdentifier(node) {
    return node &amp;&amp; node.kind === 70 /* Identifier */ &amp;&amp; identifierIsThisKeyword(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isThisTypePredicate" id="apidoc.element.typescript.isThisTypePredicate">
        function <span class="apidocSignatureSpan">typescript.</span>isThisTypePredicate
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isThisTypePredicate(predicate) {
    return predicate &amp;&amp; predicate.kind === 0 /* This */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isToken" id="apidoc.element.typescript.isToken">
        function <span class="apidocSignatureSpan">typescript.</span>isToken
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isToken(n) {
    return n.kind &gt;= 0 /* FirstToken */ &amp;&amp; n.kind &lt;= 141 /* LastToken */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTraceEnabled" id="apidoc.element.typescript.isTraceEnabled">
        function <span class="apidocSignatureSpan">typescript.</span>isTraceEnabled
        <span class="apidocSignatureSpan">(compilerOptions, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTraceEnabled(compilerOptions, host) {
    return compilerOptions.traceResolution &amp;&amp; host.trace !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTrivia" id="apidoc.element.typescript.isTrivia">
        function <span class="apidocSignatureSpan">typescript.</span>isTrivia
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTrivia(token) {
    return 2 /* FirstTriviaToken */ &lt;= token &amp;&amp; token &lt;= 7 /* LastTriviaToken */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTypeKeyword" id="apidoc.element.typescript.isTypeKeyword">
        function <span class="apidocSignatureSpan">typescript.</span>isTypeKeyword
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTypeKeyword(kind) {
    switch (kind) {
        case 118 /* AnyKeyword */:
        case 121 /* BooleanKeyword */:
        case 129 /* NeverKeyword */:
        case 132 /* NumberKeyword */:
        case 133 /* ObjectKeyword */:
        case 135 /* StringKeyword */:
        case 136 /* SymbolKeyword */:
        case 104 /* VoidKeyword */:
            return true;
        default:
            return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTypeNode" id="apidoc.element.typescript.isTypeNode">
        function <span class="apidocSignatureSpan">typescript.</span>isTypeNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTypeNode(node) {
    return isTypeNodeKind(node.kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isTypeParameter" id="apidoc.element.typescript.isTypeParameter">
        function <span class="apidocSignatureSpan">typescript.</span>isTypeParameter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTypeParameter(node) {
    return node.kind === 144 /* TypeParameter */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isUnaryExpression" id="apidoc.element.typescript.isUnaryExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isUnaryExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isUnaryExpression(node) {
    return isUnaryExpressionKind(ts.skipPartiallyEmittedExpressions(node).kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isUnicodeIdentifierStart" id="apidoc.element.typescript.isUnicodeIdentifierStart">
        function <span class="apidocSignatureSpan">typescript.</span>isUnicodeIdentifierStart
        <span class="apidocSignatureSpan">(code, languageVersion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isUnicodeIdentifierStart(code, languageVersion) {
    return languageVersion &gt;= 1 /* ES5 */ ?
        lookupInUnicodeMap(code, unicodeES5IdentifierStart) :
        lookupInUnicodeMap(code, unicodeES3IdentifierStart);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isUrl" id="apidoc.element.typescript.isUrl">
        function <span class="apidocSignatureSpan">typescript.</span>isUrl
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isUrl(path) {
    return path &amp;&amp; !isRootedDiskPath(path) &amp;&amp; path.indexOf("://") !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isVariableDeclaration" id="apidoc.element.typescript.isVariableDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>isVariableDeclaration
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isVariableDeclaration(node) {
    return node.kind === 225 /* VariableDeclaration */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isVariableDeclarationList" id="apidoc.element.typescript.isVariableDeclarationList">
        function <span class="apidocSignatureSpan">typescript.</span>isVariableDeclarationList
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isVariableDeclarationList(node) {
    return node.kind === 226 /* VariableDeclarationList */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isVariableLike" id="apidoc.element.typescript.isVariableLike">
        function <span class="apidocSignatureSpan">typescript.</span>isVariableLike
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isVariableLike(node) {
    if (node) {
        switch (node.kind) {
            case 175 /* BindingElement */:
            case 262 /* EnumMember */:
            case 145 /* Parameter */:
            case 259 /* PropertyAssignment */:
            case 148 /* PropertyDeclaration */:
            case 147 /* PropertySignature */:
            case 260 /* ShorthandPropertyAssignment */:
            case 225 /* VariableDeclaration */:
                return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isVoidExpression" id="apidoc.element.typescript.isVoidExpression">
        function <span class="apidocSignatureSpan">typescript.</span>isVoidExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isVoidExpression(node) {
    return node.kind === 189 /* VoidExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isWatchSet" id="apidoc.element.typescript.isWatchSet">
        function <span class="apidocSignatureSpan">typescript.</span>isWatchSet
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isWatchSet(options) {
    // Firefox has Object.prototype.watch
    return options.watch &amp;&amp; options.hasOwnProperty("watch");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isWellKnownSymbolSyntactically" id="apidoc.element.typescript.isWellKnownSymbolSyntactically">
        function <span class="apidocSignatureSpan">typescript.</span>isWellKnownSymbolSyntactically
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isWellKnownSymbolSyntactically(node) {
    return isPropertyAccessExpression(node) &amp;&amp; isESSymbolIdentifier(node.expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isWhiteSpace" id="apidoc.element.typescript.isWhiteSpace">
        function <span class="apidocSignatureSpan">typescript.</span>isWhiteSpace
        <span class="apidocSignatureSpan">(ch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isWhiteSpace(ch) {
    return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isWhiteSpaceSingleLine" id="apidoc.element.typescript.isWhiteSpaceSingleLine">
        function <span class="apidocSignatureSpan">typescript.</span>isWhiteSpaceSingleLine
        <span class="apidocSignatureSpan">(ch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isWhiteSpaceSingleLine(ch) {
    // Note: nextLine is in the Zs space, and should be considered to be a whitespace.
    // It is explicitly not a line-break as it isn't in the exact set specified by EcmaScript.
    return ch === 32 /* space */ ||
        ch === 9 /* tab */ ||
        ch === 11 /* verticalTab */ ||
        ch === 12 /* formFeed */ ||
        ch === 160 /* nonBreakingSpace */ ||
        ch === 133 /* nextLine */ ||
        ch === 5760 /* ogham */ ||
        ch &gt;= 8192 /* enQuad */ &amp;&amp; ch &lt;= 8203 /* zeroWidthSpace */ ||
        ch === 8239 /* narrowNoBreakSpace */ ||
        ch === 8287 /* mathematicalSpace */ ||
        ch === 12288 /* ideographicSpace */ ||
        ch === 65279 /* byteOrderMark */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.isWord" id="apidoc.element.typescript.isWord">
        function <span class="apidocSignatureSpan">typescript.</span>isWord
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isWord(kind) {
    return kind === 70 /* Identifier */ || ts.isKeyword(kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.keywordPart" id="apidoc.element.typescript.keywordPart">
        function <span class="apidocSignatureSpan">typescript.</span>keywordPart
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function keywordPart(kind) {
    return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.keyword);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.lastOrUndefined" id="apidoc.element.typescript.lastOrUndefined">
        function <span class="apidocSignatureSpan">typescript.</span>lastOrUndefined
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lastOrUndefined(array) {
    return array &amp;&amp; array.length &gt; 0
        ? array[array.length - 1]
        : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.length" id="apidoc.element.typescript.length">
        function <span class="apidocSignatureSpan">typescript.</span>length
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function length(array) {
    return array ? array.length : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.liftToBlock" id="apidoc.element.typescript.liftToBlock">
        function <span class="apidocSignatureSpan">typescript.</span>liftToBlock
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function liftToBlock(nodes) {
    Debug.assert(ts.every(nodes, ts.isStatement), "Cannot lift nodes to a Block.");
    return ts.singleOrUndefined(nodes) || ts.createBlock(nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.lineBreakPart" id="apidoc.element.typescript.lineBreakPart">
        function <span class="apidocSignatureSpan">typescript.</span>lineBreakPart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lineBreakPart() {
    return displayPart("\n", ts.SymbolDisplayPartKind.lineBreak);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.loadModuleFromGlobalCache" id="apidoc.element.typescript.loadModuleFromGlobalCache">
        function <span class="apidocSignatureSpan">typescript.</span>loadModuleFromGlobalCache
        <span class="apidocSignatureSpan">(moduleName, projectName, compilerOptions, host, globalCache)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadModuleFromGlobalCache(moduleName, projectName, compilerOptions, host, globalCache) {
    var traceEnabled = isTraceEnabled(compilerOptions, host);
    if (traceEnabled) {
        trace(host, ts.Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2
, projectName, moduleName, globalCache);
    }
    var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled };
    var failedLookupLocations = [];
    var resolved = loadModuleFromNodeModulesOneLevel(Extensions.DtsOnly, moduleName, globalCache, failedLookupLocations, state);
    return createResolvedModuleWithFailedLookupLocations(resolved, /*isExternalLibraryImport*/ true, failedLookupLocations);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.makeIdentifierFromModuleName" id="apidoc.element.typescript.makeIdentifierFromModuleName">
        function <span class="apidocSignatureSpan">typescript.</span>makeIdentifierFromModuleName
        <span class="apidocSignatureSpan">(moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeIdentifierFromModuleName(moduleName) {
    return ts.getBaseFileName(moduleName).replace(/^(\d)/, "_$1").replace(/\W/g, "_");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.map" id="apidoc.element.typescript.map">
        function <span class="apidocSignatureSpan">typescript.</span>map
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(array, f) {
    var result;
    if (array) {
        result = [];
        for (var i = 0; i &lt; array.length; i++) {
            result.push(f(array[i], i));
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.mapEntries" id="apidoc.element.typescript.mapEntries">
        function <span class="apidocSignatureSpan">typescript.</span>mapEntries
        <span class="apidocSignatureSpan">(map, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapEntries(map, f) {
    if (!map) {
        return undefined;
    }
    var result = createMap();
    map.forEach(function (value, key) {
        var _a = f(key, value), newKey = _a[0], newValue = _a[1];
        result.set(newKey, newValue);
    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.mapToDisplayParts" id="apidoc.element.typescript.mapToDisplayParts">
        function <span class="apidocSignatureSpan">typescript.</span>mapToDisplayParts
        <span class="apidocSignatureSpan">(writeDisplayParts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapToDisplayParts(writeDisplayParts) {
    writeDisplayParts(displayPartWriter);
    var result = displayPartWriter.displayParts();
    displayPartWriter.clear();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.matchFiles" id="apidoc.element.typescript.matchFiles">
        function <span class="apidocSignatureSpan">typescript.</span>matchFiles
        <span class="apidocSignatureSpan">(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, getFileSystemEntries)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, getFileSystemEntries) {
    path = normalizePath(path);
    currentDirectory = normalizePath(currentDirectory);
    var patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);
    var regexFlag = useCaseSensitiveFileNames ? "" : "i";
    var includeFileRegexes = patterns.includeFilePatterns &amp;&amp; patterns.includeFilePatterns.map(function (pattern) { return new RegExp
(pattern, regexFlag); });
    var includeDirectoryRegex = patterns.includeDirectoryPattern &amp;&amp; new RegExp(patterns.includeDirectoryPattern, regexFlag);
    var excludeRegex = patterns.excludePattern &amp;&amp; new RegExp(patterns.excludePattern, regexFlag);
    // Associate an array of results with each include regex. This keeps results in order of the "include" order.
    // If there are no "includes", then just put everything in results[0].
    var results = includeFileRegexes ? includeFileRegexes.map(function () { return []; }) : [[]];
    var comparer = useCaseSensitiveFileNames ? compareStrings : compareStringsCaseInsensitive;
    for (var _i = 0, _a = patterns.basePaths; _i &lt; _a.length; _i++) {
        var basePath = _a[_i];
        visitDirectory(basePath, combinePaths(currentDirectory, basePath));
    }
    return flatten(results);
    function visitDirectory(path, absolutePath) {
        var _a = getFileSystemEntries(path), files = _a.files, directories = _a.directories;
        files = files.slice().sort(comparer);
        directories = directories.slice().sort(comparer);
        var _loop_1 = function (current) {
            var name = combinePaths(path, current);
            var absoluteName = combinePaths(absolutePath, current);
            if (extensions &amp;&amp; !fileExtensionIsAny(name, extensions))
                return "continue";
            if (excludeRegex &amp;&amp; excludeRegex.test(absoluteName))
                return "continue";
            if (!includeFileRegexes) {
                results[0].push(name);
            }
            else {
                var includeIndex = findIndex(includeFileRegexes, function (re) { return re.test(absoluteName); });
                if (includeIndex !== -1) {
                    results[includeIndex].push(name);
                }
            }
        };
        for (var _i = 0, files_1 = files; _i &lt; files_1.length; _i++) {
            var current = files_1[_i];
            _loop_1(current);
        }
        for (var _b = 0, directories_1 = directories; _b &lt; directories_1.length; _b++) {
            var current = directories_1[_b];
            var name = combinePaths(path, current);
            var absoluteName = combinePaths(absolutePath, current);
            if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) &amp;&amp;
                (!excludeRegex || !excludeRegex.test(absoluteName))) {
                visitDirectory(name, absoluteName);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.matchPatternOrExact" id="apidoc.element.typescript.matchPatternOrExact">
        function <span class="apidocSignatureSpan">typescript.</span>matchPatternOrExact
        <span class="apidocSignatureSpan">(patternStrings, candidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchPatternOrExact(patternStrings, candidate) {
    var patterns = [];
    for (var _i = 0, patternStrings_1 = patternStrings; _i &lt; patternStrings_1.length; _i++) {
        var patternString = patternStrings_1[_i];
        var pattern = tryParsePattern(patternString);
        if (pattern) {
            patterns.push(pattern);
        }
        else if (patternString === candidate) {
            // pattern was matched as is - no need to search further
            return patternString;
        }
    }
    return findBestPatternMatch(patterns, function (_) { return _; }, candidate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.matchedText" id="apidoc.element.typescript.matchedText">
        function <span class="apidocSignatureSpan">typescript.</span>matchedText
        <span class="apidocSignatureSpan">(pattern, candidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchedText(pattern, candidate) {
    Debug.assert(isPatternMatch(pattern, candidate));
    return candidate.substr(pattern.prefix.length, candidate.length - pattern.suffix.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.memoize" id="apidoc.element.typescript.memoize">
        function <span class="apidocSignatureSpan">typescript.</span>memoize
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(callback) {
    var value;
    return function () {
        if (callback) {
            value = callback();
            callback = undefined;
        }
        return value;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.mergeFunctionBodyLexicalEnvironment" id="apidoc.element.typescript.mergeFunctionBodyLexicalEnvironment">
        function <span class="apidocSignatureSpan">typescript.</span>mergeFunctionBodyLexicalEnvironment
        <span class="apidocSignatureSpan">(body, declarations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeFunctionBodyLexicalEnvironment(body, declarations) {
    if (body &amp;&amp; declarations !== undefined &amp;&amp; declarations.length &gt; 0) {
        if (ts.isBlock(body)) {
            return ts.updateBlock(body, ts.setTextRange(ts.createNodeArray(ts.concatenate(body.statements, declarations)), body.
statements));
        }
        else {
            return ts.setTextRange(ts.createBlock(ts.setTextRange(ts.createNodeArray([ts.setTextRange(ts.createReturn(body), body
)].concat(declarations)), body),
            /*multiLine*/ true),
            /*location*/ body);
        }
    }
    return body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.mergeLexicalEnvironment" id="apidoc.element.typescript.mergeLexicalEnvironment">
        function <span class="apidocSignatureSpan">typescript.</span>mergeLexicalEnvironment
        <span class="apidocSignatureSpan">(statements, declarations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeLexicalEnvironment(statements, declarations) {
    if (!ts.some(declarations)) {
        return statements;
    }
    return ts.isNodeArray(statements)
        ? ts.setTextRange(ts.createNodeArray(ts.concatenate(statements, declarations)), statements)
        : ts.addRange(statements, declarations);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.modifierToFlag" id="apidoc.element.typescript.modifierToFlag">
        function <span class="apidocSignatureSpan">typescript.</span>modifierToFlag
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modifierToFlag(token) {
    switch (token) {
        case 114 /* StaticKeyword */: return 32 /* Static */;
        case 113 /* PublicKeyword */: return 4 /* Public */;
        case 112 /* ProtectedKeyword */: return 16 /* Protected */;
        case 111 /* PrivateKeyword */: return 8 /* Private */;
        case 116 /* AbstractKeyword */: return 128 /* Abstract */;
        case 83 /* ExportKeyword */: return 1 /* Export */;
        case 123 /* DeclareKeyword */: return 2 /* Ambient */;
        case 75 /* ConstKeyword */: return 2048 /* Const */;
        case 78 /* DefaultKeyword */: return 512 /* Default */;
        case 119 /* AsyncKeyword */: return 256 /* Async */;
        case 130 /* ReadonlyKeyword */: return 64 /* Readonly */;
    }
    return 0 /* None */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.moduleHasNonRelativeName" id="apidoc.element.typescript.moduleHasNonRelativeName">
        function <span class="apidocSignatureSpan">typescript.</span>moduleHasNonRelativeName
        <span class="apidocSignatureSpan">(moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moduleHasNonRelativeName(moduleName) {
    return !(ts.isRootedDiskPath(moduleName) || ts.isExternalModuleNameRelative(moduleName));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.moduleResolutionIsEqualTo" id="apidoc.element.typescript.moduleResolutionIsEqualTo">
        function <span class="apidocSignatureSpan">typescript.</span>moduleResolutionIsEqualTo
        <span class="apidocSignatureSpan">(oldResolution, newResolution)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moduleResolutionIsEqualTo(oldResolution, newResolution) {
    return oldResolution.isExternalLibraryImport === newResolution.isExternalLibraryImport &amp;&amp;
        oldResolution.extension === newResolution.extension &amp;&amp;
        oldResolution.resolvedFileName === newResolution.resolvedFileName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.moveEmitHelpers" id="apidoc.element.typescript.moveEmitHelpers">
        function <span class="apidocSignatureSpan">typescript.</span>moveEmitHelpers
        <span class="apidocSignatureSpan">(source, target, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moveEmitHelpers(source, target, predicate) {
    var sourceEmitNode = source.emitNode;
    var sourceEmitHelpers = sourceEmitNode &amp;&amp; sourceEmitNode.helpers;
    if (!ts.some(sourceEmitHelpers))
        return;
    var targetEmitNode = getOrCreateEmitNode(target);
    var helpersRemoved = 0;
    for (var i = 0; i &lt; sourceEmitHelpers.length; i++) {
        var helper = sourceEmitHelpers[i];
        if (predicate(helper)) {
            helpersRemoved++;
            if (!ts.contains(targetEmitNode.helpers, helper)) {
                targetEmitNode.helpers = ts.append(targetEmitNode.helpers, helper);
            }
        }
        else if (helpersRemoved &gt; 0) {
            sourceEmitHelpers[i - helpersRemoved] = helper;
        }
    }
    if (helpersRemoved &gt; 0) {
        sourceEmitHelpers.length -= helpersRemoved;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.movePos" id="apidoc.element.typescript.movePos">
        function <span class="apidocSignatureSpan">typescript.</span>movePos
        <span class="apidocSignatureSpan">(pos, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function movePos(pos, value) {
    return ts.positionIsSynthesized(pos) ? -1 : pos + value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.moveRangeEnd" id="apidoc.element.typescript.moveRangeEnd">
        function <span class="apidocSignatureSpan">typescript.</span>moveRangeEnd
        <span class="apidocSignatureSpan">(range, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moveRangeEnd(range, end) {
    return createRange(range.pos, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.moveRangePastDecorators" id="apidoc.element.typescript.moveRangePastDecorators">
        function <span class="apidocSignatureSpan">typescript.</span>moveRangePastDecorators
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moveRangePastDecorators(node) {
    return node.decorators &amp;&amp; node.decorators.length &gt; 0
        ? moveRangePos(node, node.decorators.end)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.moveRangePastModifiers" id="apidoc.element.typescript.moveRangePastModifiers">
        function <span class="apidocSignatureSpan">typescript.</span>moveRangePastModifiers
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moveRangePastModifiers(node) {
    return node.modifiers &amp;&amp; node.modifiers.length &gt; 0
        ? moveRangePos(node, node.modifiers.end)
        : moveRangePastDecorators(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.moveRangePos" id="apidoc.element.typescript.moveRangePos">
        function <span class="apidocSignatureSpan">typescript.</span>moveRangePos
        <span class="apidocSignatureSpan">(range, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moveRangePos(range, pos) {
    return createRange(pos, range.end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodeCanBeDecorated" id="apidoc.element.typescript.nodeCanBeDecorated">
        function <span class="apidocSignatureSpan">typescript.</span>nodeCanBeDecorated
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeCanBeDecorated(node) {
    switch (node.kind) {
        case 228<span class="apidocCodeCommentSpan"> /* ClassDeclaration */:
            // classes are valid targets
            return true;
        case 148 /* PropertyDeclaration */:
            // property declarations are valid if their parent is a class declaration.
            return node.parent.kind === 228 /* ClassDeclaration */;
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        case 150 /* MethodDeclaration */:
            // if this method has a body and its parent is a class declaration, this is a valid target.
            return node.body !== undefined
                &amp;&amp; node.parent.kind === 228 /* ClassDeclaration */;
        case 145 /* Parameter */:
            // if the parameter's parent has a body and its grandparent is a class declaration, this is a valid target;
            return node.parent.body !== undefined
                &amp;&amp; (node.parent.kind === 151 /* Constructor */
</span>                    || node.parent.kind === 150 /* MethodDeclaration */
                    || node.parent.kind === 153 /* SetAccessor */)
                &amp;&amp; node.parent.parent.kind === 228 /* ClassDeclaration */;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodeIsDecorated" id="apidoc.element.typescript.nodeIsDecorated">
        function <span class="apidocSignatureSpan">typescript.</span>nodeIsDecorated
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeIsDecorated(node) {
    return node.decorators !== undefined
        &amp;&amp; nodeCanBeDecorated(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodeIsMissing" id="apidoc.element.typescript.nodeIsMissing">
        function <span class="apidocSignatureSpan">typescript.</span>nodeIsMissing
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeIsMissing(node) {
    if (node === undefined) {
        return true;
    }
    return node.pos === node.end &amp;&amp; node.pos &gt;= 0 &amp;&amp; node.kind !== 1 /* EndOfFileToken */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodeIsPresent" id="apidoc.element.typescript.nodeIsPresent">
        function <span class="apidocSignatureSpan">typescript.</span>nodeIsPresent
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeIsPresent(node) {
    return !nodeIsMissing(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodeIsSynthesized" id="apidoc.element.typescript.nodeIsSynthesized">
        function <span class="apidocSignatureSpan">typescript.</span>nodeIsSynthesized
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeIsSynthesized(node) {
    return ts.positionIsSynthesized(node.pos)
        || ts.positionIsSynthesized(node.end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodeModuleNameResolver" id="apidoc.element.typescript.nodeModuleNameResolver">
        function <span class="apidocSignatureSpan">typescript.</span>nodeModuleNameResolver
        <span class="apidocSignatureSpan">(moduleName, containingFile, compilerOptions, host, cache)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache) {
    return nodeModuleNameResolverWorker(moduleName, containingFile, compilerOptions, host, cache, /* jsOnly*/ false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodeModuleNameResolverWorker" id="apidoc.element.typescript.nodeModuleNameResolverWorker">
        function <span class="apidocSignatureSpan">typescript.</span>nodeModuleNameResolverWorker
        <span class="apidocSignatureSpan">(moduleName, containingFile, compilerOptions, host, cache, jsOnly)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeModuleNameResolverWorker(moduleName, containingFile, compilerOptions, host, cache, jsOnly) {
    if (jsOnly === void 0) { jsOnly = false; }
    var containingDirectory = ts.getDirectoryPath(containingFile);
    var traceEnabled = isTraceEnabled(compilerOptions, host);
    var failedLookupLocations = [];
    var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled };
    var result = jsOnly ? tryResolve(Extensions.JavaScript) : (tryResolve(Extensions.TypeScript) || tryResolve(Extensions.JavaScript
));
    if (result &amp;&amp; result.value) {
        var _a = result.value, resolved = _a.resolved, isExternalLibraryImport = _a.isExternalLibraryImport;
        return createResolvedModuleWithFailedLookupLocations(resolved, isExternalLibraryImport, failedLookupLocations);
    }
    return { resolvedModule: undefined, failedLookupLocations: failedLookupLocations };
    function tryResolve(extensions) {
        var loader = function (extensions, candidate, failedLookupLocations, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName
(extensions, candidate, failedLookupLocations, onlyRecordFailures, state, /*considerPackageJson*/ true); };
        var resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, failedLookupLocations
, state);
        if (resolved) {
            return toSearchResult({ resolved: resolved, isExternalLibraryImport: false });
        }
        if (moduleHasNonRelativeName(moduleName)) {
            if (traceEnabled) {
                trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[
extensions]);
            }
            var resolved_1 = loadModuleFromNodeModules(extensions, moduleName, containingDirectory, failedLookupLocations, state
, cache);
            // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate
 files.
            return resolved_1 &amp;&amp; { value: resolved_1.value &amp;&amp; { resolved: { path: realpath(resolved_1.value.path, host, traceEnabled
), extension: resolved_1.value.extension }, isExternalLibraryImport: true } };
        }
        else {
            var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
            var resolved_2 = nodeLoadModuleByRelativeName(extensions, candidate, failedLookupLocations, /*onlyRecordFailures*/ false
, state, /*considerPackageJson*/ true);
            return resolved_2 &amp;&amp; toSearchResult({ resolved: resolved_2, isExternalLibraryImport: false });
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodeOrChildIsDecorated" id="apidoc.element.typescript.nodeOrChildIsDecorated">
        function <span class="apidocSignatureSpan">typescript.</span>nodeOrChildIsDecorated
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeOrChildIsDecorated(node) {
    return nodeIsDecorated(node) || childIsDecorated(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodePosToString" id="apidoc.element.typescript.nodePosToString">
        function <span class="apidocSignatureSpan">typescript.</span>nodePosToString
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodePosToString(node) {
    var file = getSourceFileOfNode(node);
    var loc = ts.getLineAndCharacterOfPosition(file, node.pos);
    return file.fileName + "(" + (loc.line + 1) + "," + (loc.character + 1) + ")";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.nodeStartsNewLexicalEnvironment" id="apidoc.element.typescript.nodeStartsNewLexicalEnvironment">
        function <span class="apidocSignatureSpan">typescript.</span>nodeStartsNewLexicalEnvironment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeStartsNewLexicalEnvironment(node) {
    var kind = node.kind;
    return kind === 151<span class="apidocCodeCommentSpan"> /* Constructor */
</span>        || kind === 185 /* FunctionExpression */
        || kind === 227 /* FunctionDeclaration */
        || kind === 186 /* ArrowFunction */
        || kind === 150 /* MethodDeclaration */
        || kind === 152 /* GetAccessor */
        || kind === 153 /* SetAccessor */
        || kind === 232 /* ModuleDeclaration */
        || kind === 263 /* SourceFile */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.noop" id="apidoc.element.typescript.noop">
        function <span class="apidocSignatureSpan">typescript.</span>noop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.normalizePath" id="apidoc.element.typescript.normalizePath">
        function <span class="apidocSignatureSpan">typescript.</span>normalizePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizePath(path) {
    path = normalizeSlashes(path);
    var rootLength = getRootLength(path);
    var root = path.substr(0, rootLength);
    var normalized = getNormalizedParts(path, rootLength);
    if (normalized.length) {
        var joinedParts = root + normalized.join(ts.directorySeparator);
        return pathEndsWithDirectorySeparator(path) ? joinedParts + ts.directorySeparator : joinedParts;
    }
    else {
        return root;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.normalizeSlashes" id="apidoc.element.typescript.normalizeSlashes">
        function <span class="apidocSignatureSpan">typescript.</span>normalizeSlashes
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizeSlashes(path) {
    return path.replace(/\\/g, "/");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.notImplemented" id="apidoc.element.typescript.notImplemented">
        function <span class="apidocSignatureSpan">typescript.</span>notImplemented
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notImplemented() {
    throw new Error("Not implemented");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.operatorPart" id="apidoc.element.typescript.operatorPart">
        function <span class="apidocSignatureSpan">typescript.</span>operatorPart
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function operatorPart(kind) {
    return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.operator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.orderedRemoveItem" id="apidoc.element.typescript.orderedRemoveItem">
        function <span class="apidocSignatureSpan">typescript.</span>orderedRemoveItem
        <span class="apidocSignatureSpan">(array, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function orderedRemoveItem(array, item) {
    for (var i = 0; i &lt; array.length; i++) {
        if (array[i] === item) {
            orderedRemoveItemAt(array, i);
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.orderedRemoveItemAt" id="apidoc.element.typescript.orderedRemoveItemAt">
        function <span class="apidocSignatureSpan">typescript.</span>orderedRemoveItemAt
        <span class="apidocSignatureSpan">(array, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function orderedRemoveItemAt(array, index) {
    // This seems to be faster than either `array.splice(i, 1)` or `array.copyWithin(i, i+ 1)`.
    for (var i = index; i &lt; array.length - 1; i++) {
        array[i] = array[i + 1];
    }
    array.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parameterIsThisKeyword" id="apidoc.element.typescript.parameterIsThisKeyword">
        function <span class="apidocSignatureSpan">typescript.</span>parameterIsThisKeyword
        <span class="apidocSignatureSpan">(parameter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parameterIsThisKeyword(parameter) {
    return isThisIdentifier(parameter.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizeBinaryOperand" id="apidoc.element.typescript.parenthesizeBinaryOperand">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizeBinaryOperand
        <span class="apidocSignatureSpan">(binaryOperator, operand, isLeftSideOfBinary, leftOperand)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizeBinaryOperand(binaryOperator, operand, isLeftSideOfBinary, leftOperand) {
    var skipped = skipPartiallyEmittedExpressions(operand);
    // If the resulting expression is already parenthesized, we do not need to do any further processing.
    if (skipped.kind === 184 /* ParenthesizedExpression */) {
        return operand;
    }
    return binaryOperandNeedsParentheses(binaryOperator, operand, isLeftSideOfBinary, leftOperand)
        ? ts.createParen(operand)
        : operand;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizeConciseBody" id="apidoc.element.typescript.parenthesizeConciseBody">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizeConciseBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizeConciseBody(body) {
    var emittedBody = skipPartiallyEmittedExpressions(body);
    if (emittedBody.kind === 177 /* ObjectLiteralExpression */) {
        return ts.setTextRange(ts.createParen(body), body);
    }
    return body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizeExpressionForExpressionStatement" id="apidoc.element.typescript.parenthesizeExpressionForExpressionStatement">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizeExpressionForExpressionStatement
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizeExpressionForExpressionStatement(expression) {
    var emittedExpression = skipPartiallyEmittedExpressions(expression);
    if (ts.isCallExpression(emittedExpression)) {
        var callee = emittedExpression.expression;
        var kind = skipPartiallyEmittedExpressions(callee).kind;
        if (kind === 185 /* FunctionExpression */ || kind === 186 /* ArrowFunction */) {
            var mutableCall = ts.getMutableClone(emittedExpression);
            mutableCall.expression = ts.setTextRange(ts.createParen(callee), callee);
            return recreatePartiallyEmittedExpressions(expression, mutableCall);
        }
    }
    else {
        var leftmostExpressionKind = getLeftmostExpression(emittedExpression).kind;
        if (leftmostExpressionKind === 177 /* ObjectLiteralExpression */ || leftmostExpressionKind === 185 /* FunctionExpression
 */) {
            return ts.setTextRange(ts.createParen(expression), expression);
        }
    }
    return expression;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizeExpressionForList" id="apidoc.element.typescript.parenthesizeExpressionForList">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizeExpressionForList
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizeExpressionForList(expression) {
    var emittedExpression = skipPartiallyEmittedExpressions(expression);
    var expressionPrecedence = ts.getExpressionPrecedence(emittedExpression);
    var commaPrecedence = ts.getOperatorPrecedence(193 /* BinaryExpression */, 25 /* CommaToken */);
    return expressionPrecedence &gt; commaPrecedence
        ? expression
        : ts.setTextRange(ts.createParen(expression), expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizeForAccess" id="apidoc.element.typescript.parenthesizeForAccess">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizeForAccess
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizeForAccess(expression) {
    // isLeftHandSideExpression is almost the correct criterion for when it is not necessary
    // to parenthesize the expression before a dot. The known exceptions are:
    //
    //    NewExpression:
    //       new C.x        -&gt; not the same as (new C).x
    //    NumericLiteral
    //       1.x            -&gt; not the same as (1).x
    //
    var emittedExpression = skipPartiallyEmittedExpressions(expression);
    if (ts.isLeftHandSideExpression(emittedExpression)
        &amp;&amp; (emittedExpression.kind !== 181 /* NewExpression */ || emittedExpression.arguments)
        &amp;&amp; emittedExpression.kind !== 8 /* NumericLiteral */) {
        return expression;
    }
    return ts.setTextRange(ts.createParen(expression), expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizeForConditionalHead" id="apidoc.element.typescript.parenthesizeForConditionalHead">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizeForConditionalHead
        <span class="apidocSignatureSpan">(condition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizeForConditionalHead(condition) {
    var conditionalPrecedence = ts.getOperatorPrecedence(194 /* ConditionalExpression */, 54 /* QuestionToken */);
    var emittedCondition = skipPartiallyEmittedExpressions(condition);
    var conditionPrecedence = ts.getExpressionPrecedence(emittedCondition);
    if (ts.compareValues(conditionPrecedence, conditionalPrecedence) === -1 /* LessThan */) {
        return ts.createParen(condition);
    }
    return condition;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizeForNew" id="apidoc.element.typescript.parenthesizeForNew">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizeForNew
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizeForNew(expression) {
    var emittedExpression = skipPartiallyEmittedExpressions(expression);
    switch (emittedExpression.kind) {
        case 180 /* CallExpression */:
            return ts.createParen(expression);
        case 181 /* NewExpression */:
            return emittedExpression.arguments
                ? expression
                : ts.createParen(expression);
    }
    return parenthesizeForAccess(expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizeListElements" id="apidoc.element.typescript.parenthesizeListElements">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizeListElements
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizeListElements(elements) {
    var result;
    for (var i = 0; i &lt; elements.length; i++) {
        var element = parenthesizeExpressionForList(elements[i]);
        if (result !== undefined || element !== elements[i]) {
            if (result === undefined) {
                result = elements.slice(0, i);
            }
            result.push(element);
        }
    }
    if (result !== undefined) {
        return ts.setTextRange(ts.createNodeArray(result, elements.hasTrailingComma), elements);
    }
    return elements;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizePostfixOperand" id="apidoc.element.typescript.parenthesizePostfixOperand">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizePostfixOperand
        <span class="apidocSignatureSpan">(operand)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizePostfixOperand(operand) {
    return ts.isLeftHandSideExpression(operand)
        ? operand
        : ts.setTextRange(ts.createParen(operand), operand);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizePrefixOperand" id="apidoc.element.typescript.parenthesizePrefixOperand">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizePrefixOperand
        <span class="apidocSignatureSpan">(operand)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizePrefixOperand(operand) {
    return ts.isUnaryExpression(operand)
        ? operand
        : ts.setTextRange(ts.createParen(operand), operand);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parenthesizeSubexpressionOfConditionalExpression" id="apidoc.element.typescript.parenthesizeSubexpressionOfConditionalExpression">
        function <span class="apidocSignatureSpan">typescript.</span>parenthesizeSubexpressionOfConditionalExpression
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parenthesizeSubexpressionOfConditionalExpression(e) {
    // per ES grammar both 'whenTrue' and 'whenFalse' parts of conditional expression are assignment expressions
    // so in case when comma expression is introduced as a part of previous transformations
    // if should be wrapped in parens since comma operator has the lowest precedence
    return e.kind === 193<span class="apidocCodeCommentSpan"> /* BinaryExpression */ &amp;&amp; e.operatorToken.kind === 25 /* CommaToken */
</span>        ? ts.createParen(e)
        : e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parseCommandLine" id="apidoc.element.typescript.parseCommandLine">
        function <span class="apidocSignatureSpan">typescript.</span>parseCommandLine
        <span class="apidocSignatureSpan">(commandLine, readFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseCommandLine(commandLine, readFile) {
    var options = {};
    var fileNames = [];
    var errors = [];
    var _a = getOptionNameMap(), optionNameMap = _a.optionNameMap, shortOptionNames = _a.shortOptionNames;
    parseStrings(commandLine);
    return {
        options: options,
        fileNames: fileNames,
        errors: errors
    };
    function parseStrings(args) {
        var i = 0;
        while (i &lt; args.length) {
            var s = args[i];
            i++;
            if (s.charCodeAt(0) === 64 /* at */) {
                parseResponseFile(s.slice(1));
            }
            else if (s.charCodeAt(0) === 45 /* minus */) {
                s = s.slice(s.charCodeAt(1) === 45 /* minus */ ? 2 : 1).toLowerCase();
                // Try to translate short option names to their full equivalents.
                var short = shortOptionNames.get(s);
                if (short !== undefined) {
                    s = short;
                }
                var opt = optionNameMap.get(s);
                if (opt) {
                    if (opt.isTSConfigOnly) {
                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_0_can_only_be_specified_in_tsconfig_json_file
, opt.name));
                    }
                    else {
                        // Check to see if no argument was provided (e.g. "--locale" is the last command-line argument).
                        if (!args[i] &amp;&amp; opt.type !== "boolean") {
                            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Compiler_option_0_expects_an_argument, opt.name
));
                        }
                        switch (opt.type) {
                            case "number":
                                options[opt.name] = parseInt(args[i]);
                                i++;
                                break;
                            case "boolean":
                                // boolean flag has optional value true, false, others
                                var optValue = args[i];
                                options[opt.name] = optValue !== "false";
                                // consume next argument as boolean flag value
                                if (optValue === "false" || optValue === "true") {
                                    i++;
                                }
                                break;
                            case "string":
                                options[opt.name] = args[i] || "";
                                i++;
                                break;
                            case "list":
                                var result = parseListTypeOption(opt, args[i], errors);
                                options[opt.name] = result || [];
                                if (result) {
                                    i++;
                                }
                                break;
                            // If not a primitive, the possible types are specified in what is effectively a map of options.
                            default:
                                options[opt.name] = parseCustomTypeOption(opt, args[i], errors);
                                i++;
                                break;
                        }
                    }
                }
                else {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unknown_compiler_option_0, s));
                }
            }
            else {
                fileNames.push(s);
            }
        }
    }
    function parseResponseFile(fileName) {
        var text = readFile ? readFile(fileName) : ts.sys.readFile(fileName);
        if (!text) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.File_0_not_found, fileName));
            return;
        }
        var args = [];
        var pos = 0;
        while (true) {
            while (pos &lt; text.length &amp;&amp; text.charCodeAt(pos) &lt;= 32 /* space */)
                pos++;
            if (pos &gt;= text.length)
                break; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parseConfigFileTextToJson" id="apidoc.element.typescript.parseConfigFileTextToJson">
        function <span class="apidocSignatureSpan">typescript.</span>parseConfigFileTextToJson
        <span class="apidocSignatureSpan">(fileName, jsonText, stripComments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseConfigFileTextToJson(fileName, jsonText, stripComments) {
    if (stripComments === void 0) { stripComments = true; }
    try {
        var jsonTextToParse = stripComments ? removeComments(jsonText) : jsonText;
        return { config: /\S/.test(jsonTextToParse) ? JSON.parse(jsonTextToParse) : {} };
    }
    catch (e) {
        return { error: ts.createCompilerDiagnostic(ts.Diagnostics.Failed_to_parse_file_0_Colon_1, fileName, e.message) };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parseCustomTypeOption" id="apidoc.element.typescript.parseCustomTypeOption">
        function <span class="apidocSignatureSpan">typescript.</span>parseCustomTypeOption
        <span class="apidocSignatureSpan">(opt, value, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseCustomTypeOption(opt, value, errors) {
    return convertJsonOptionOfCustomType(opt, trimString(value || ""), errors);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parseIsolatedEntityName" id="apidoc.element.typescript.parseIsolatedEntityName">
        function <span class="apidocSignatureSpan">typescript.</span>parseIsolatedEntityName
        <span class="apidocSignatureSpan">(text, languageVersion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseIsolatedEntityName(text, languageVersion) {
    return Parser.parseIsolatedEntityName(text, languageVersion);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parseIsolatedJSDocComment" id="apidoc.element.typescript.parseIsolatedJSDocComment">
        function <span class="apidocSignatureSpan">typescript.</span>parseIsolatedJSDocComment
        <span class="apidocSignatureSpan">(content, start, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseIsolatedJSDocComment(content, start, length) {
    var result = Parser.JSDocParser.parseIsolatedJSDocComment(content, start, length);
    if (result &amp;&amp; result.jsDoc) {
        // because the jsDocComment was parsed out of the source file, it might
        // not be covered by the fixupParentReferences.
        Parser.fixupParentReferences(result.jsDoc);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parseJSDocTypeExpressionForTests" id="apidoc.element.typescript.parseJSDocTypeExpressionForTests">
        function <span class="apidocSignatureSpan">typescript.</span>parseJSDocTypeExpressionForTests
        <span class="apidocSignatureSpan">(content, start, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseJSDocTypeExpressionForTests(content, start, length) {
    return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parseJsonConfigFileContent" id="apidoc.element.typescript.parseJsonConfigFileContent">
        function <span class="apidocSignatureSpan">typescript.</span>parseJsonConfigFileContent
        <span class="apidocSignatureSpan">(json, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseJsonConfigFileContent(json, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions) {
    if (existingOptions === void 0) { existingOptions = {}; }
    if (resolutionStack === void 0) { resolutionStack = []; }
    if (extraFileExtensions === void 0) { extraFileExtensions = []; }
    var errors = [];
    basePath = ts.normalizeSlashes(basePath);
    var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames);
    var resolvedPath = ts.toPath(configFileName || "", basePath, getCanonicalFileName);
    if (resolutionStack.indexOf(resolvedPath) &gt;= 0) {
        return {
            options: {},
            fileNames: [],
            typeAcquisition: {},
            raw: json,
            errors: [ts.createCompilerDiagnostic(ts.Diagnostics.Circularity_detected_while_resolving_configuration_Colon_0, resolutionStack
.concat([resolvedPath]).join(" -&gt; "))],
            wildcardDirectories: {}
        };
    }
    var options = convertCompilerOptionsFromJsonWorker(json["compilerOptions"], basePath, errors, configFileName);
    // typingOptions has been deprecated and is only supported for backward compatibility purposes.
    // It should be removed in future releases - use typeAcquisition instead.
    var jsonOptions = json["typeAcquisition"] || json["typingOptions"];
    var typeAcquisition = convertTypeAcquisitionFromJsonWorker(jsonOptions, basePath, errors, configFileName);
    if (json["extends"]) {
        var _a = [undefined, undefined, undefined, {}], include = _a[0], exclude = _a[1], files = _a[2], baseOptions = _a[3];
        if (typeof json["extends"] === "string") {
            _b = (tryExtendsName(json["extends"]) || [include, exclude, files, baseOptions]), include = _b[0], exclude = _b[1],
files = _b[2], baseOptions = _b[3];
        }
        else {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, "extends", "string
"));
        }
        if (include &amp;&amp; !json["include"]) {
            json["include"] = include;
        }
        if (exclude &amp;&amp; !json["exclude"]) {
            json["exclude"] = exclude;
        }
        if (files &amp;&amp; !json["files"]) {
            json["files"] = files;
        }
        options = ts.assign({}, baseOptions, options);
    }
    options = ts.extend(existingOptions, options);
    options.configFilePath = configFileName;
    var _c = getFileNames(errors), fileNames = _c.fileNames, wildcardDirectories = _c.wildcardDirectories;
    var compileOnSave = convertCompileOnSaveOptionFromJson(json, basePath, errors);
    return {
        options: options,
        fileNames: fileNames,
        typeAcquisition: typeAcquisition,
        raw: json,
        errors: errors,
        wildcardDirectories: wildcardDirectories,
        compileOnSave: compileOnSave
    };
    function tryExtendsName(extendedConfig) {
        // If the path isn't a rooted or relative path, don't try to resolve it (we reserve the right to special case module-id
like paths in the future)
        if (!(ts.isRootedDiskPath(extendedConfig) || ts.startsWith(ts.normalizeSlashes(extendedConfig), "./") || ts.startsWith(ts
.normalizeSlashes(extendedConfig), "../"))) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not
, extendedConfig));
            return;
        }
        var extendedConfigPath = ts.toPath(extendedConfig, basePath, getCanonicalFileName);
        if (!host.fileExists(extendedConfigPath) &amp;&amp; !ts.endsWith(extendedConfigPath, ".json")) {
            extendedConfigPath = extendedConfigPath + ".json";
            if (!host.fileExists(extendedConfigPath)) {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.File_0_does_not_exist, extendedConfig));
                return;
            }
        }
        var extendedResult = readConfigFile(extendedConfigPath, function (path) { return host.readFile(path); });
        if (extendedResult.error) {
            errors.push(extendedResult.error); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.parseListTypeOption" id="apidoc.element.typescript.parseListTypeOption">
        function <span class="apidocSignatureSpan">typescript.</span>parseListTypeOption
        <span class="apidocSignatureSpan">(opt, value, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseListTypeOption(opt, value, errors) {
    if (value === void 0) { value = ""; }
    value = trimString(value);
    if (ts.startsWith(value, "-")) {
        return undefined;
    }
    if (value === "") {
        return [];
    }
    var values = value.split(",");
    switch (opt.element.type) {
        case "number":
            return ts.map(values, parseInt);
        case "string":
            return ts.map(values, function (v) { return v || ""; });
        default:
            return ts.filter(ts.map(values, function (v) { return parseCustomTypeOption(opt.element, v, errors); }), function (v
) { return !!v; });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.pathEndsWithDirectorySeparator" id="apidoc.element.typescript.pathEndsWithDirectorySeparator">
        function <span class="apidocSignatureSpan">typescript.</span>pathEndsWithDirectorySeparator
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pathEndsWithDirectorySeparator(path) {
    return path.charCodeAt(path.length - 1) === directorySeparatorCharCode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.patternText" id="apidoc.element.typescript.patternText">
        function <span class="apidocSignatureSpan">typescript.</span>patternText
        <span class="apidocSignatureSpan">(_a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function patternText(_a) {
    var prefix = _a.prefix, suffix = _a.suffix;
    return prefix + "*" + suffix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.positionBelongsToNode" id="apidoc.element.typescript.positionBelongsToNode">
        function <span class="apidocSignatureSpan">typescript.</span>positionBelongsToNode
        <span class="apidocSignatureSpan">(candidate, position, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function positionBelongsToNode(candidate, position, sourceFile) {
    return candidate.end &gt; position || !isCompletedNode(candidate, sourceFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.positionIsSynthesized" id="apidoc.element.typescript.positionIsSynthesized">
        function <span class="apidocSignatureSpan">typescript.</span>positionIsSynthesized
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function positionIsSynthesized(pos) {
    // This is a fast way of testing the following conditions:
    //  pos === undefined || pos === null || isNaN(pos) || pos &lt; 0;
    return !(pos &gt;= 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.positionsAreOnSameLine" id="apidoc.element.typescript.positionsAreOnSameLine">
        function <span class="apidocSignatureSpan">typescript.</span>positionsAreOnSameLine
        <span class="apidocSignatureSpan">(pos1, pos2, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function positionsAreOnSameLine(pos1, pos2, sourceFile) {
    return pos1 === pos2 ||
        getLineOfLocalPosition(sourceFile, pos1) === getLineOfLocalPosition(sourceFile, pos2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.preProcessFile" id="apidoc.element.typescript.preProcessFile">
        function <span class="apidocSignatureSpan">typescript.</span>preProcessFile
        <span class="apidocSignatureSpan">(sourceText, readImportFiles, detectJavaScriptImports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preProcessFile(sourceText, readImportFiles, detectJavaScriptImports) {
    if (readImportFiles === void 0) { readImportFiles = true; }
    if (detectJavaScriptImports === void 0) { detectJavaScriptImports = false; }
    var referencedFiles = [];
    var typeReferenceDirectives = [];
    var importedFiles = [];
    var ambientExternalModules;
    var isNoDefaultLib = false;
    var braceNesting = 0;
    // assume that text represent an external module if it contains at least one top level import/export
    // ambient modules that are found inside external modules are interpreted as module augmentations
    var externalModule = false;
    function nextToken() {
        var token = ts.scanner.scan();
        if (token === 16<span class="apidocCodeCommentSpan"> /* OpenBraceToken */) {
            braceNesting++;
        }
        else if (token === 17 /* CloseBraceToken */) {
            braceNesting--;
        }
        return token;
    }
    function processTripleSlashDirectives() {
        var commentRanges = ts.getLeadingCommentRanges(sourceText, 0);
        ts.forEach(commentRanges, function (commentRange) {
            var comment = sourceText.substring(commentRange.pos, commentRange.end);
            var referencePathMatchResult = ts.getFileReferenceFromReferencePath(comment, commentRange);
            if (referencePathMatchResult) {
                isNoDefaultLib = referencePathMatchResult.isNoDefaultLib;
                var fileReference = referencePathMatchResult.fileReference;
                if (fileReference) {
                    var collection = referencePathMatchResult.isTypeReferenceDirective
                        ? typeReferenceDirectives
                        : referencedFiles;
                    collection.push(fileReference);
                }
            }
        });
    }
    function getFileReference() {
        var file = ts.scanner.getTokenValue();
        var pos = ts.scanner.getTokenPos();
        return {
            fileName: file,
            pos: pos,
            end: pos + file.length
        };
    }
    function recordAmbientExternalModule() {
        if (!ambientExternalModules) {
            ambientExternalModules = [];
        }
        ambientExternalModules.push({ ref: getFileReference(), depth: braceNesting });
    }
    function recordModuleName() {
        importedFiles.push(getFileReference());
        markAsExternalModuleIfTopLevel();
    }
    function markAsExternalModuleIfTopLevel() {
        if (braceNesting === 0) {
            externalModule = true;
        }
    }
    /**
     * Returns true if at least one token was consumed from the stream
     */
</span>    function tryConsumeDeclare() {
        var token = ts.scanner.getToken();
        if (token === 123 /* DeclareKeyword */) {
            // declare module "mod"
            token = nextToken();
            if (token === 127 /* ModuleKeyword */) {
                token = nextToken();
                if (token === 9 /* StringLiteral */) {
                    recordAmbientExternalModule();
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Returns true if at least one token was consumed from the stream
     */
    function tryConsumeImport() {
        var token = ts.scanner.getToken();
        if (token === 90 /* ImportKeyword */) {
            token = nextToken();
            if (token === 9 /* StringLiteral */) {
                // import "mod";
                recordModuleName();
                return true;
            }
            else {
                if (token === 70 /* Identifier */ || ts.isKeyword(token)) {
                    token = nextToken();
                    if (token === 139 /* FromKeyword */) {
                        token = nextToken();
                        if (token === 9 /* StringLiteral */) {
                            // import d from "mod";
                            recordModuleName();
                            return true;
                        }
                    }
                    else if (token === 57 /* EqualsToken */) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.punctuationPart" id="apidoc.element.typescript.punctuationPart">
        function <span class="apidocSignatureSpan">typescript.</span>punctuationPart
        <span class="apidocSignatureSpan">(kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function punctuationPart(kind) {
    return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.punctuation);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.rangeContainsRange" id="apidoc.element.typescript.rangeContainsRange">
        function <span class="apidocSignatureSpan">typescript.</span>rangeContainsRange
        <span class="apidocSignatureSpan">(r1, r2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rangeContainsRange(r1, r2) {
    return startEndContainsRange(r1.pos, r1.end, r2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.rangeContainsStartEnd" id="apidoc.element.typescript.rangeContainsStartEnd">
        function <span class="apidocSignatureSpan">typescript.</span>rangeContainsStartEnd
        <span class="apidocSignatureSpan">(range, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rangeContainsStartEnd(range, start, end) {
    return range.pos &lt;= start &amp;&amp; range.end &gt;= end;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.rangeEndIsOnSameLineAsRangeStart" id="apidoc.element.typescript.rangeEndIsOnSameLineAsRangeStart">
        function <span class="apidocSignatureSpan">typescript.</span>rangeEndIsOnSameLineAsRangeStart
        <span class="apidocSignatureSpan">(range1, range2, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rangeEndIsOnSameLineAsRangeStart(range1, range2, sourceFile) {
    return positionsAreOnSameLine(range1.end, getStartPositionOfRange(range2, sourceFile), sourceFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.rangeEndPositionsAreOnSameLine" id="apidoc.element.typescript.rangeEndPositionsAreOnSameLine">
        function <span class="apidocSignatureSpan">typescript.</span>rangeEndPositionsAreOnSameLine
        <span class="apidocSignatureSpan">(range1, range2, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rangeEndPositionsAreOnSameLine(range1, range2, sourceFile) {
    return positionsAreOnSameLine(range1.end, range2.end, sourceFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.rangeEquals" id="apidoc.element.typescript.rangeEquals">
        function <span class="apidocSignatureSpan">typescript.</span>rangeEquals
        <span class="apidocSignatureSpan">(array1, array2, pos, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rangeEquals(array1, array2, pos, end) {
    while (pos &lt; end) {
        if (array1[pos] !== array2[pos]) {
            return false;
        }
        pos++;
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.rangeIsOnSingleLine" id="apidoc.element.typescript.rangeIsOnSingleLine">
        function <span class="apidocSignatureSpan">typescript.</span>rangeIsOnSingleLine
        <span class="apidocSignatureSpan">(range, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rangeIsOnSingleLine(range, sourceFile) {
    return rangeStartIsOnSameLineAsRangeEnd(range, range, sourceFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.rangeOverlapsWithStartEnd" id="apidoc.element.typescript.rangeOverlapsWithStartEnd">
        function <span class="apidocSignatureSpan">typescript.</span>rangeOverlapsWithStartEnd
        <span class="apidocSignatureSpan">(r1, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rangeOverlapsWithStartEnd(r1, start, end) {
    return startEndOverlapsWithStartEnd(r1.pos, r1.end, start, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.rangeStartIsOnSameLineAsRangeEnd" id="apidoc.element.typescript.rangeStartIsOnSameLineAsRangeEnd">
        function <span class="apidocSignatureSpan">typescript.</span>rangeStartIsOnSameLineAsRangeEnd
        <span class="apidocSignatureSpan">(range1, range2, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rangeStartIsOnSameLineAsRangeEnd(range1, range2, sourceFile) {
    return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile), range2.end, sourceFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.rangeStartPositionsAreOnSameLine" id="apidoc.element.typescript.rangeStartPositionsAreOnSameLine">
        function <span class="apidocSignatureSpan">typescript.</span>rangeStartPositionsAreOnSameLine
        <span class="apidocSignatureSpan">(range1, range2, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rangeStartPositionsAreOnSameLine(range1, range2, sourceFile) {
    return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile), getStartPositionOfRange(range2, sourceFile), sourceFile
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.readConfigFile" id="apidoc.element.typescript.readConfigFile">
        function <span class="apidocSignatureSpan">typescript.</span>readConfigFile
        <span class="apidocSignatureSpan">(fileName, readFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readConfigFile(fileName, readFile) {
    var text = "";
    try {
        text = readFile(fileName);
    }
    catch (e) {
        return { error: ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_read_file_0_Colon_1, fileName, e.message) };
    }
    return parseConfigFileTextToJson(fileName, text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.realizeDiagnostics" id="apidoc.element.typescript.realizeDiagnostics">
        function <span class="apidocSignatureSpan">typescript.</span>realizeDiagnostics
        <span class="apidocSignatureSpan">(diagnostics, newLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function realizeDiagnostics(diagnostics, newLine) {
    return diagnostics.map(function (d) { return realizeDiagnostic(d, newLine); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.reduceEachChild" id="apidoc.element.typescript.reduceEachChild">
        function <span class="apidocSignatureSpan">typescript.</span>reduceEachChild
        <span class="apidocSignatureSpan">(node, initial, cbNode, cbNodeArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceEachChild(node, initial, cbNode, cbNodeArray) {
    if (node === undefined) {
        return initial;
    }
    var reduceNodes = cbNodeArray ? reduceNodeArray : ts.reduceLeft;
    var cbNodes = cbNodeArray || cbNode;
    var kind = node.kind;
    // No need to visit nodes with no children.
    if ((kind &gt; 0 /* FirstToken */ &amp;&amp; kind &lt;= 141 /* LastToken */)) {
        return initial;
    }
    // We do not yet support types.
    if ((kind &gt;= 157 /* TypePredicate */ &amp;&amp; kind &lt;= 172 /* LiteralType */)) {
        return initial;
    }
    var result = initial;
    switch (node.kind) {
        // Leaf nodes
        case 205 /* SemicolonClassElement */:
        case 208 /* EmptyStatement */:
        case 199 /* OmittedExpression */:
        case 224 /* DebuggerStatement */:
        case 296 /* NotEmittedStatement */:
            // No need to visit nodes with no children.
            break;
        // Names
        case 142 /* QualifiedName */:
            result = reduceNode(node.left, cbNode, result);
            result = reduceNode(node.right, cbNode, result);
            break;
        case 143 /* ComputedPropertyName */:
            result = reduceNode(node.expression, cbNode, result);
            break;
        // Signature elements
        case 145 /* Parameter */:
            result = reduceNodes(node.decorators, cbNodes, result);
            result = reduceNodes(node.modifiers, cbNodes, result);
            result = reduceNode(node.name, cbNode, result);
            result = reduceNode(node.type, cbNode, result);
            result = reduceNode(node.initializer, cbNode, result);
            break;
        case 146 /* Decorator */:
            result = reduceNode(node.expression, cbNode, result);
            break;
        // Type member
        case 148 /* PropertyDeclaration */:
            result = reduceNodes(node.decorators, cbNodes, result);
            result = reduceNodes(node.modifiers, cbNodes, result);
            result = reduceNode(node.name, cbNode, result);
            result = reduceNode(node.type, cbNode, result);
            result = reduceNode(node.initializer, cbNode, result);
            break;
        case 150 /* MethodDeclaration */:
            result = reduceNodes(node.decorators, cbNodes, result);
            result = reduceNodes(node.modifiers, cbNodes, result);
            result = reduceNode(node.name, cbNode, result);
            result = reduceNodes(node.typeParameters, cbNodes, result);
            result = reduceNodes(node.parameters, cbNodes, result);
            result = reduceNode(node.type, cbNode, result);
            result = reduceNode(node.body, cbNode, result);
            break;
        case 151 /* Constructor */:
            result = reduceNodes(node.modifiers, cbNodes, result);
            result = reduceNodes(node.parameters, cbNodes, result);
            result = reduceNode(node.body, cbNode, result);
            break;
        case 152 /* GetAccessor */:
            result = reduceNodes(node.decorators, cbNodes, result);
            result = reduceNodes(node.modifiers, cbNodes, result);
            result = reduceNode(node.name, cbNode, result);
            result = reduceNodes(node.parameters, cbNodes, result);
            result = reduceNode(node.type, cbNode, result);
            result = reduceNode(node.body, cbNode, result);
            break;
        case 153 /* SetAccessor */:
            result = reduceNodes(node.decorators, cbNodes, result);
            result = reduceNodes(node.modifiers, cbNodes, result);
            result = reduceNode(node.name, cbNode, result);
            result = reduceNodes(node.parameters, cbNodes, result);
            result = reduceNode(node.body, cbNode, result);
            break;
        // Binding patterns
        case 173 /* ObjectBindingPattern */:
        case 174 /* ArrayBindingPattern */:
            result = reduceNodes(node.elements, cbNodes, result);
            break;
        case 175 /* BindingElement */:
            result = reduceNode(node.propertyName, cbNode, result);
            result = reduceNode(node ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.reduceEachLeadingCommentRange" id="apidoc.element.typescript.reduceEachLeadingCommentRange">
        function <span class="apidocSignatureSpan">typescript.</span>reduceEachLeadingCommentRange
        <span class="apidocSignatureSpan">(text, pos, cb, state, initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceEachLeadingCommentRange(text, pos, cb, state, initial) {
    return iterateCommentRanges(/*reduce*/ true, text, pos, /*trailing*/ false, cb, state, initial);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.reduceEachTrailingCommentRange" id="apidoc.element.typescript.reduceEachTrailingCommentRange">
        function <span class="apidocSignatureSpan">typescript.</span>reduceEachTrailingCommentRange
        <span class="apidocSignatureSpan">(text, pos, cb, state, initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceEachTrailingCommentRange(text, pos, cb, state, initial) {
    return iterateCommentRanges(/*reduce*/ true, text, pos, /*trailing*/ true, cb, state, initial);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.reduceLeft" id="apidoc.element.typescript.reduceLeft">
        function <span class="apidocSignatureSpan">typescript.</span>reduceLeft
        <span class="apidocSignatureSpan">(array, f, initial, start, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceLeft(array, f, initial, start, count) {
    if (array &amp;&amp; array.length &gt; 0) {
        var size = array.length;
        if (size &gt; 0) {
            var pos = start === undefined || start &lt; 0 ? 0 : start;
            var end = count === undefined || pos + count &gt; size - 1 ? size - 1 : pos + count;
            var result = void 0;
            if (arguments.length &lt;= 2) {
                result = array[pos];
                pos++;
            }
            else {
                result = initial;
            }
            while (pos &lt;= end) {
                result = f(result, array[pos], pos);
                pos++;
            }
            return result;
        }
    }
    return initial;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.reduceRight" id="apidoc.element.typescript.reduceRight">
        function <span class="apidocSignatureSpan">typescript.</span>reduceRight
        <span class="apidocSignatureSpan">(array, f, initial, start, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, f, initial, start, count) {
    if (array) {
        var size = array.length;
        if (size &gt; 0) {
            var pos = start === undefined || start &gt; size - 1 ? size - 1 : start;
            var end = count === undefined || pos - count &lt; 0 ? 0 : pos - count;
            var result = void 0;
            if (arguments.length &lt;= 2) {
                result = array[pos];
                pos--;
            }
            else {
                result = initial;
            }
            while (pos &gt;= end) {
                result = f(result, array[pos], pos);
                pos--;
            }
            return result;
        }
    }
    return initial;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.relativeComplement" id="apidoc.element.typescript.relativeComplement">
        function <span class="apidocSignatureSpan">typescript.</span>relativeComplement
        <span class="apidocSignatureSpan">(arrayA, arrayB, comparer, offsetA, offsetB)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function relativeComplement(arrayA, arrayB, comparer, offsetA, offsetB) {
    if (comparer === void 0) { comparer = compareValues; }
    if (offsetA === void 0) { offsetA = 0; }
    if (offsetB === void 0) { offsetB = 0; }
    if (!arrayB || !arrayA || arrayB.length === 0 || arrayA.length === 0)
        return arrayB;
    var result = [];
    outer: for (; offsetB &lt; arrayB.length; offsetB++) {
        inner: for (; offsetA &lt; arrayA.length; offsetA++) {
            switch (comparer(arrayB[offsetB], arrayA[offsetA])) {
                case -1 /* LessThan */: break inner;
                case 0 /* EqualTo */: continue outer;
                case 1 /* GreaterThan */: continue inner;
            }
        }
        result.push(arrayB[offsetB]);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.releaseStringWriter" id="apidoc.element.typescript.releaseStringWriter">
        function <span class="apidocSignatureSpan">typescript.</span>releaseStringWriter
        <span class="apidocSignatureSpan">(writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function releaseStringWriter(writer) {
    writer.clear();
    stringWriters.push(writer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.removeEmitHelper" id="apidoc.element.typescript.removeEmitHelper">
        function <span class="apidocSignatureSpan">typescript.</span>removeEmitHelper
        <span class="apidocSignatureSpan">(node, helper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeEmitHelper(node, helper) {
    var emitNode = node.emitNode;
    if (emitNode) {
        var helpers = emitNode.helpers;
        if (helpers) {
            return ts.orderedRemoveItem(helpers, helper);
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.removeExtension" id="apidoc.element.typescript.removeExtension">
        function <span class="apidocSignatureSpan">typescript.</span>removeExtension
        <span class="apidocSignatureSpan">(path, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeExtension(path, extension) {
    return path.substring(0, path.length - extension.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.removeFileExtension" id="apidoc.element.typescript.removeFileExtension">
        function <span class="apidocSignatureSpan">typescript.</span>removeFileExtension
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeFileExtension(path) {
    for (var _i = 0, extensionsToRemove_1 = extensionsToRemove; _i &lt; extensionsToRemove_1.length; _i++) {
        var ext = extensionsToRemove_1[_i];
        var extensionless = tryRemoveExtension(path, ext);
        if (extensionless !== undefined) {
            return extensionless;
        }
    }
    return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.removeTrailingDirectorySeparator" id="apidoc.element.typescript.removeTrailingDirectorySeparator">
        function <span class="apidocSignatureSpan">typescript.</span>removeTrailingDirectorySeparator
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeTrailingDirectorySeparator(path) {
    if (path.charAt(path.length - 1) === ts.directorySeparator) {
        return path.substr(0, path.length - 1);
    }
    return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.removeWhere" id="apidoc.element.typescript.removeWhere">
        function <span class="apidocSignatureSpan">typescript.</span>removeWhere
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeWhere(array, f) {
    var outIndex = 0;
    for (var _i = 0, array_2 = array; _i &lt; array_2.length; _i++) {
        var item = array_2[_i];
        if (!f(item)) {
            array[outIndex] = item;
            outIndex++;
        }
    }
    if (outIndex !== array.length) {
        array.length = outIndex;
        return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.replaceElement" id="apidoc.element.typescript.replaceElement">
        function <span class="apidocSignatureSpan">typescript.</span>replaceElement
        <span class="apidocSignatureSpan">(array, index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceElement(array, index, value) {
    var result = array.slice(0);
    result[index] = value;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.resolveModuleName" id="apidoc.element.typescript.resolveModuleName">
        function <span class="apidocSignatureSpan">typescript.</span>resolveModuleName
        <span class="apidocSignatureSpan">(moduleName, containingFile, compilerOptions, host, cache)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveModuleName(moduleName, containingFile, compilerOptions, host, cache) {
    var traceEnabled = isTraceEnabled(compilerOptions, host);
    if (traceEnabled) {
        trace(host, ts.Diagnostics.Resolving_module_0_from_1, moduleName, containingFile);
    }
    var containingDirectory = ts.getDirectoryPath(containingFile);
    var perFolderCache = cache &amp;&amp; cache.getOrCreateCacheForDirectory(containingDirectory);
    var result = perFolderCache &amp;&amp; perFolderCache.get(moduleName);
    if (result) {
        if (traceEnabled) {
            trace(host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache, moduleName);
        }
    }
    else {
        var moduleResolution = compilerOptions.moduleResolution;
        if (moduleResolution === undefined) {
            moduleResolution = ts.getEmitModuleKind(compilerOptions) === ts.ModuleKind.CommonJS ? ts.ModuleResolutionKind.NodeJs
 : ts.ModuleResolutionKind.Classic;
            if (traceEnabled) {
                trace(host, ts.Diagnostics.Module_resolution_kind_is_not_specified_using_0, ts.ModuleResolutionKind[moduleResolution
]);
            }
        }
        else {
            if (traceEnabled) {
                trace(host, ts.Diagnostics.Explicitly_specified_module_resolution_kind_Colon_0, ts.ModuleResolutionKind[moduleResolution
]);
            }
        }
        switch (moduleResolution) {
            case ts.ModuleResolutionKind.NodeJs:
                result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache);
                break;
            case ts.ModuleResolutionKind.Classic:
                result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache);
                break;
        }
        if (perFolderCache) {
            perFolderCache.set(moduleName, result);
            // put result in per-module name cache
            var perModuleNameCache = cache.getOrCreateCacheForModuleName(moduleName);
            if (perModuleNameCache) {
                perModuleNameCache.set(containingDirectory, result);
            }
        }
    }
    if (traceEnabled) {
        if (result.resolvedModule) {
            trace(host, ts.Diagnostics.Module_name_0_was_successfully_resolved_to_1, moduleName, result.resolvedModule.resolvedFileName
);
        }
        else {
            trace(host, ts.Diagnostics.Module_name_0_was_not_resolved, moduleName);
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.resolveTripleslashReference" id="apidoc.element.typescript.resolveTripleslashReference">
        function <span class="apidocSignatureSpan">typescript.</span>resolveTripleslashReference
        <span class="apidocSignatureSpan">(moduleName, containingFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveTripleslashReference(moduleName, containingFile) {
    var basePath = ts.getDirectoryPath(containingFile);
    var referencedFileName = ts.isRootedDiskPath(moduleName) ? moduleName : ts.combinePaths(basePath, moduleName);
    return ts.normalizePath(referencedFileName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.resolveTypeReferenceDirective" id="apidoc.element.typescript.resolveTypeReferenceDirective">
        function <span class="apidocSignatureSpan">typescript.</span>resolveTypeReferenceDirective
        <span class="apidocSignatureSpan">(typeReferenceDirectiveName, containingFile, options, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host) {
    var traceEnabled = isTraceEnabled(options, host);
    var moduleResolutionState = {
        compilerOptions: options,
        host: host,
        traceEnabled: traceEnabled
    };
    var typeRoots = getEffectiveTypeRoots(options, host);
    if (traceEnabled) {
        if (containingFile === undefined) {
            if (typeRoots === undefined) {
                trace(host, ts.Diagnostics.Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set,
typeReferenceDirectiveName);
            }
            else {
                trace(host, ts.Diagnostics.Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1, typeReferenceDirectiveName
, typeRoots);
            }
        }
        else {
            if (typeRoots === undefined) {
                trace(host, ts.Diagnostics.Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set, typeReferenceDirectiveName
, containingFile);
            }
            else {
                trace(host, ts.Diagnostics.Resolving_type_reference_directive_0_containing_file_1_root_directory_2, typeReferenceDirectiveName
, containingFile, typeRoots);
            }
        }
    }
    var failedLookupLocations = [];
    var resolved = primaryLookup();
    var primary = true;
    if (!resolved) {
        resolved = secondaryLookup();
        primary = false;
    }
    var resolvedTypeReferenceDirective;
    if (resolved) {
        resolved = realpath(resolved, host, traceEnabled);
        if (traceEnabled) {
            trace(host, ts.Diagnostics.Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2, typeReferenceDirectiveName
, resolved, primary);
        }
        resolvedTypeReferenceDirective = { primary: primary, resolvedFileName: resolved };
    }
    return { resolvedTypeReferenceDirective: resolvedTypeReferenceDirective, failedLookupLocations: failedLookupLocations };
    function primaryLookup() {
        // Check primary library paths
        if (typeRoots &amp;&amp; typeRoots.length) {
            if (traceEnabled) {
                trace(host, ts.Diagnostics.Resolving_with_primary_search_path_0, typeRoots.join(", "));
            }
            return ts.forEach(typeRoots, function (typeRoot) {
                var candidate = ts.combinePaths(typeRoot, typeReferenceDirectiveName);
                var candidateDirectory = ts.getDirectoryPath(candidate);
                var directoryExists = directoryProbablyExists(candidateDirectory, host);
                if (!directoryExists &amp;&amp; traceEnabled) {
                    trace(host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);
                }
                return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, failedLookupLocations, !
directoryExists, moduleResolutionState));
            });
        }
        else {
            if (traceEnabled) {
                trace(host, ts.Diagnostics.Root_directory_cannot_be_determined_skipping_primary_search_paths);
            }
        }
    }
    function secondaryLookup() {
        var resolvedFile;
        var initialLocationForSecondaryLookup = containingFile &amp;&amp; ts.getDirectoryPath(containingFile);
        if (initialLocationForSecondaryLookup !== undefined) {
            // check secondary locations
            if (traceEnabled) {
                trace(host, ts.Diagnostics.Looking_up_in_node_modules_folder_initial_location_0, initialLocationForSecondaryLookup
);
            }
            var result = loadModuleFromNodeModules(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup
, failedLookupLocations, moduleResolutionState, /*cache*/ undefined);
            resolvedFile = resolvedTypeScriptOnly(result &amp;&amp; result.value);
            if (!resolvedFile &amp;&amp; traceEnabled) {
                trace(host, ts.Diagnostics.Type_reference_directive_0_was_not_resolved, typeReferenceDirectiveName);
            } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.restoreEnclosingLabel" id="apidoc.element.typescript.restoreEnclosingLabel">
        function <span class="apidocSignatureSpan">typescript.</span>restoreEnclosingLabel
        <span class="apidocSignatureSpan">(node, outermostLabeledStatement, afterRestoreLabelCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restoreEnclosingLabel(node, outermostLabeledStatement, afterRestoreLabelCallback) {
    if (!outermostLabeledStatement) {
        return node;
    }
    var updated = ts.updateLabel(outermostLabeledStatement, outermostLabeledStatement.label, outermostLabeledStatement.statement
.kind === 221<span class="apidocCodeCommentSpan"> /* LabeledStatement */
</span>        ? restoreEnclosingLabel(node, outermostLabeledStatement.statement)
        : node);
    if (afterRestoreLabelCallback) {
        afterRestoreLabelCallback(outermostLabeledStatement);
    }
    return updated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sameMap" id="apidoc.element.typescript.sameMap">
        function <span class="apidocSignatureSpan">typescript.</span>sameMap
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sameMap(array, f) {
    var result;
    if (array) {
        for (var i = 0; i &lt; array.length; i++) {
            if (result) {
                result.push(f(array[i], i));
            }
            else {
                var item = array[i];
                var mapped = f(item, i);
                if (item !== mapped) {
                    result = array.slice(0, i);
                    result.push(mapped);
                }
            }
        }
    }
    return result || array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sanitizeConfigFile" id="apidoc.element.typescript.sanitizeConfigFile">
        function <span class="apidocSignatureSpan">typescript.</span>sanitizeConfigFile
        <span class="apidocSignatureSpan">(configFileName, content)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sanitizeConfigFile(configFileName, content) {
    var options = {
        fileName: "config.js",
        compilerOptions: {
            target: 2 /* ES2015 */,
            removeComments: true
        },
        reportDiagnostics: true
    };
    var _a = ts.transpileModule("(" + content + ")", options), outputText = _a.outputText, diagnostics = _a.diagnostics;
    // Becasue the content was wrapped in "()", the start position of diagnostics needs to be subtract by 1
    // also, the emitted result will have "(" in the beginning and ");" in the end. We need to strip these
    // as well
    var trimmedOutput = outputText.trim();
    for (var _i = 0, diagnostics_2 = diagnostics; _i &lt; diagnostics_2.length; _i++) {
        var diagnostic = diagnostics_2[_i];
        diagnostic.start = diagnostic.start - 1;
    }
    var _b = ts.parseConfigFileTextToJson(configFileName, trimmedOutput.substring(1, trimmedOutput.length - 2), /*stripComments*/
false), config = _b.config, error = _b.error;
    return {
        configJsonObject: config || {},
        diagnostics: error ? ts.concatenate(diagnostics, [error]) : diagnostics
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scriptKindIs" id="apidoc.element.typescript.scriptKindIs">
        function <span class="apidocSignatureSpan">typescript.</span>scriptKindIs
        <span class="apidocSignatureSpan">(fileName, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scriptKindIs(fileName, host) {
    var scriptKinds = [];
    for (var _i = 2; _i &lt; arguments.length; _i++) {
        scriptKinds[_i - 2] = arguments[_i];
    }
    var scriptKind = getScriptKind(fileName, host);
    return ts.forEach(scriptKinds, function (k) { return k === scriptKind; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.setCommentRange" id="apidoc.element.typescript.setCommentRange">
        function <span class="apidocSignatureSpan">typescript.</span>setCommentRange
        <span class="apidocSignatureSpan">(node, range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setCommentRange(node, range) {
    getOrCreateEmitNode(node).commentRange = range;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.setConstantValue" id="apidoc.element.typescript.setConstantValue">
        function <span class="apidocSignatureSpan">typescript.</span>setConstantValue
        <span class="apidocSignatureSpan">(node, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setConstantValue(node, value) {
    var emitNode = getOrCreateEmitNode(node);
    emitNode.constantValue = value;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.setEmitFlags" id="apidoc.element.typescript.setEmitFlags">
        function <span class="apidocSignatureSpan">typescript.</span>setEmitFlags
        <span class="apidocSignatureSpan">(node, emitFlags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setEmitFlags(node, emitFlags) {
    getOrCreateEmitNode(node).flags = emitFlags;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.setOriginalNode" id="apidoc.element.typescript.setOriginalNode">
        function <span class="apidocSignatureSpan">typescript.</span>setOriginalNode
        <span class="apidocSignatureSpan">(node, original)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOriginalNode(node, original) {
    node.original = original;
    if (original) {
        var emitNode = original.emitNode;
        if (emitNode)
            node.emitNode = mergeEmitNode(emitNode, node.emitNode);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.setResolvedModule" id="apidoc.element.typescript.setResolvedModule">
        function <span class="apidocSignatureSpan">typescript.</span>setResolvedModule
        <span class="apidocSignatureSpan">(sourceFile, moduleNameText, resolvedModule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setResolvedModule(sourceFile, moduleNameText, resolvedModule) {
    if (!sourceFile.resolvedModules) {
        sourceFile.resolvedModules = ts.createMap();
    }
    sourceFile.resolvedModules.set(moduleNameText, resolvedModule);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.setResolvedTypeReferenceDirective" id="apidoc.element.typescript.setResolvedTypeReferenceDirective">
        function <span class="apidocSignatureSpan">typescript.</span>setResolvedTypeReferenceDirective
        <span class="apidocSignatureSpan">(sourceFile, typeReferenceDirectiveName, resolvedTypeReferenceDirective)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setResolvedTypeReferenceDirective(sourceFile, typeReferenceDirectiveName, resolvedTypeReferenceDirective) {
    if (!sourceFile.resolvedTypeReferenceDirectiveNames) {
        sourceFile.resolvedTypeReferenceDirectiveNames = ts.createMap();
    }
    sourceFile.resolvedTypeReferenceDirectiveNames.set(typeReferenceDirectiveName, resolvedTypeReferenceDirective);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.setSourceMapRange" id="apidoc.element.typescript.setSourceMapRange">
        function <span class="apidocSignatureSpan">typescript.</span>setSourceMapRange
        <span class="apidocSignatureSpan">(node, range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setSourceMapRange(node, range) {
    getOrCreateEmitNode(node).sourceMapRange = range;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.setTextRange" id="apidoc.element.typescript.setTextRange">
        function <span class="apidocSignatureSpan">typescript.</span>setTextRange
        <span class="apidocSignatureSpan">(range, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTextRange(range, location) {
    if (location) {
        range.pos = location.pos;
        range.end = location.end;
    }
    return range;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.setTokenSourceMapRange" id="apidoc.element.typescript.setTokenSourceMapRange">
        function <span class="apidocSignatureSpan">typescript.</span>setTokenSourceMapRange
        <span class="apidocSignatureSpan">(node, token, range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTokenSourceMapRange(node, token, range) {
    var emitNode = getOrCreateEmitNode(node);
    var tokenSourceMapRanges = emitNode.tokenSourceMapRanges || (emitNode.tokenSourceMapRanges = []);
    tokenSourceMapRanges[token] = range;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.signatureToDisplayParts" id="apidoc.element.typescript.signatureToDisplayParts">
        function <span class="apidocSignatureSpan">typescript.</span>signatureToDisplayParts
        <span class="apidocSignatureSpan">(typechecker, signature, enclosingDeclaration, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function signatureToDisplayParts(typechecker, signature, enclosingDeclaration, flags) {
    return mapToDisplayParts(function (writer) {
        typechecker.getSymbolDisplayBuilder().buildSignatureDisplay(signature, writer, enclosingDeclaration, flags);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.singleOrMany" id="apidoc.element.typescript.singleOrMany">
        function <span class="apidocSignatureSpan">typescript.</span>singleOrMany
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function singleOrMany(array) {
    return array &amp;&amp; array.length === 1
        ? array[0]
        : array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.singleOrUndefined" id="apidoc.element.typescript.singleOrUndefined">
        function <span class="apidocSignatureSpan">typescript.</span>singleOrUndefined
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function singleOrUndefined(array) {
    return array &amp;&amp; array.length === 1
        ? array[0]
        : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.skipAssertions" id="apidoc.element.typescript.skipAssertions">
        function <span class="apidocSignatureSpan">typescript.</span>skipAssertions
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipAssertions(node) {
    while (ts.isAssertionExpression(node)) {
        node = node.expression;
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.skipOuterExpressions" id="apidoc.element.typescript.skipOuterExpressions">
        function <span class="apidocSignatureSpan">typescript.</span>skipOuterExpressions
        <span class="apidocSignatureSpan">(node, kinds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipOuterExpressions(node, kinds) {
    if (kinds === void 0) { kinds = 7 /* All */; }
    var previousNode;
    do {
        previousNode = node;
        if (kinds &amp; 1 /* Parentheses */) {
            node = skipParentheses(node);
        }
        if (kinds &amp; 2 /* Assertions */) {
            node = skipAssertions(node);
        }
        if (kinds &amp; 4 /* PartiallyEmittedExpressions */) {
            node = skipPartiallyEmittedExpressions(node);
        }
    } while (previousNode !== node);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.skipParentheses" id="apidoc.element.typescript.skipParentheses">
        function <span class="apidocSignatureSpan">typescript.</span>skipParentheses
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipParentheses(node) {
    while (node.kind === 184 /* ParenthesizedExpression */) {
        node = node.expression;
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.skipPartiallyEmittedExpressions" id="apidoc.element.typescript.skipPartiallyEmittedExpressions">
        function <span class="apidocSignatureSpan">typescript.</span>skipPartiallyEmittedExpressions
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipPartiallyEmittedExpressions(node) {
    while (node.kind === 297 /* PartiallyEmittedExpression */) {
        node = node.expression;
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.skipTrivia" id="apidoc.element.typescript.skipTrivia">
        function <span class="apidocSignatureSpan">typescript.</span>skipTrivia
        <span class="apidocSignatureSpan">(text, pos, stopAfterLineBreak, stopAtComments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipTrivia(text, pos, stopAfterLineBreak, stopAtComments) {
    if (stopAtComments === void 0) { stopAtComments = false; }
    if (ts.positionIsSynthesized(pos)) {
        return pos;
    }
    // Keep in sync with couldStartTrivia
    while (true) {
        var ch = text.charCodeAt(pos);
        switch (ch) {
            case 13 /* carriageReturn */:
                if (text.charCodeAt(pos + 1) === 10 /* lineFeed */) {
                    pos++;
                }
            case 10 /* lineFeed */:
                pos++;
                if (stopAfterLineBreak) {
                    return pos;
                }
                continue;
            case 9 /* tab */:
            case 11 /* verticalTab */:
            case 12 /* formFeed */:
            case 32 /* space */:
                pos++;
                continue;
            case 47 /* slash */:
                if (stopAtComments) {
                    break;
                }
                if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                    pos += 2;
                    while (pos &lt; text.length) {
                        if (isLineBreak(text.charCodeAt(pos))) {
                            break;
                        }
                        pos++;
                    }
                    continue;
                }
                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                    pos += 2;
                    while (pos &lt; text.length) {
                        if (text.charCodeAt(pos) === 42 /* asterisk */ &amp;&amp; text.charCodeAt(pos + 1) === 47 /* slash */) {
                            pos += 2;
                            break;
                        }
                        pos++;
                    }
                    continue;
                }
                break;
            case 60 /* lessThan */:
            case 61 /* equals */:
            case 62 /* greaterThan */:
                if (isConflictMarkerTrivia(text, pos)) {
                    pos = scanConflictMarkerTrivia(text, pos);
                    continue;
                }
                break;
            case 35 /* hash */:
                if (pos === 0 &amp;&amp; isShebangTrivia(text, pos)) {
                    pos = scanShebangTrivia(text, pos);
                    continue;
                }
                break;
            default:
                if (ch &gt; 127 /* maxAsciiCharacter */ &amp;&amp; (isWhiteSpace(ch))) {
                    pos++;
                    continue;
                }
                break;
        }
        return pos;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.some" id="apidoc.element.typescript.some">
        function <span class="apidocSignatureSpan">typescript.</span>some
        <span class="apidocSignatureSpan">(array, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some(array, predicate) {
    if (array) {
        if (predicate) {
            for (var _i = 0, array_5 = array; _i &lt; array_5.length; _i++) {
                var v = array_5[_i];
                if (predicate(v)) {
                    return true;
                }
            }
        }
        else {
            return array.length &gt; 0;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sortAndDeduplicateDiagnostics" id="apidoc.element.typescript.sortAndDeduplicateDiagnostics">
        function <span class="apidocSignatureSpan">typescript.</span>sortAndDeduplicateDiagnostics
        <span class="apidocSignatureSpan">(diagnostics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortAndDeduplicateDiagnostics(diagnostics) {
    return deduplicateSortedDiagnostics(diagnostics.sort(compareDiagnostics));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sourceFileMayBeEmitted" id="apidoc.element.typescript.sourceFileMayBeEmitted">
        function <span class="apidocSignatureSpan">typescript.</span>sourceFileMayBeEmitted
        <span class="apidocSignatureSpan">(sourceFile, options, isSourceFileFromExternalLibrary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sourceFileMayBeEmitted(sourceFile, options, isSourceFileFromExternalLibrary) {
    return !(options.noEmitForJsFiles &amp;&amp; isSourceFileJavaScript(sourceFile)) &amp;&amp; !isDeclarationFile(sourceFile) &amp;&amp; !isSourceFileFromExternalLibrary
(sourceFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.spacePart" id="apidoc.element.typescript.spacePart">
        function <span class="apidocSignatureSpan">typescript.</span>spacePart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spacePart() {
    return displayPart(" ", ts.SymbolDisplayPartKind.space);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.span" id="apidoc.element.typescript.span">
        function <span class="apidocSignatureSpan">typescript.</span>span
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function span(array, f) {
    if (array) {
        for (var i = 0; i &lt; array.length; i++) {
            if (!f(array[i], i)) {
                return [array.slice(0, i), array.slice(i)];
            }
        }
        return [array.slice(0), []];
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.spanMap" id="apidoc.element.typescript.spanMap">
        function <span class="apidocSignatureSpan">typescript.</span>spanMap
        <span class="apidocSignatureSpan">(array, keyfn, mapfn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spanMap(array, keyfn, mapfn) {
    var result;
    if (array) {
        result = [];
        var len = array.length;
        var previousKey = void 0;
        var key = void 0;
        var start = 0;
        var pos = 0;
        while (start &lt; len) {
            while (pos &lt; len) {
                var value = array[pos];
                key = keyfn(value, pos);
                if (pos === 0) {
                    previousKey = key;
                }
                else if (key !== previousKey) {
                    break;
                }
                pos++;
            }
            if (start &lt; pos) {
                var v = mapfn(array.slice(start, pos), previousKey, start, pos);
                if (v) {
                    result.push(v);
                }
                start = pos;
            }
            previousKey = key;
            pos++;
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.stableSort" id="apidoc.element.typescript.stableSort">
        function <span class="apidocSignatureSpan">typescript.</span>stableSort
        <span class="apidocSignatureSpan">(array, comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stableSort(array, comparer) {
    if (comparer === void 0) { comparer = compareValues; }
    return array
        .map(function (_, i) { return i; }) // create array of indices
        .sort(function (x, y) { return comparer(array[x], array[y]) || compareValues(x, y); }) // sort indices by value then position
        .map(function (i) { return array[i]; }); // get sorted array
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.startEndContainsRange" id="apidoc.element.typescript.startEndContainsRange">
        function <span class="apidocSignatureSpan">typescript.</span>startEndContainsRange
        <span class="apidocSignatureSpan">(start, end, range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startEndContainsRange(start, end, range) {
    return start &lt;= range.pos &amp;&amp; end &gt;= range.end;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.startEndOverlapsWithStartEnd" id="apidoc.element.typescript.startEndOverlapsWithStartEnd">
        function <span class="apidocSignatureSpan">typescript.</span>startEndOverlapsWithStartEnd
        <span class="apidocSignatureSpan">(start1, end1, start2, end2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startEndOverlapsWithStartEnd(start1, end1, start2, end2) {
    var start = Math.max(start1, start2);
    var end = Math.min(end1, end2);
    return start &lt; end;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.startOnNewLine" id="apidoc.element.typescript.startOnNewLine">
        function <span class="apidocSignatureSpan">typescript.</span>startOnNewLine
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startOnNewLine(node) {
    node.startsOnNewLine = true;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.startsWith" id="apidoc.element.typescript.startsWith">
        function <span class="apidocSignatureSpan">typescript.</span>startsWith
        <span class="apidocSignatureSpan">(str, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startsWith(str, prefix) {
    return str.lastIndexOf(prefix, 0) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.startsWithUseStrict" id="apidoc.element.typescript.startsWithUseStrict">
        function <span class="apidocSignatureSpan">typescript.</span>startsWithUseStrict
        <span class="apidocSignatureSpan">(statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startsWithUseStrict(statements) {
    var firstStatement = ts.firstOrUndefined(statements);
    return firstStatement !== undefined
        &amp;&amp; ts.isPrologueDirective(firstStatement)
        &amp;&amp; isUseStrictPrologue(firstStatement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.stringToToken" id="apidoc.element.typescript.stringToToken">
        function <span class="apidocSignatureSpan">typescript.</span>stringToToken
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringToToken(s) {
    return textToToken.get(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.stripQuotes" id="apidoc.element.typescript.stripQuotes">
        function <span class="apidocSignatureSpan">typescript.</span>stripQuotes
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stripQuotes(name) {
    var length = name.length;
    if (length &gt;= 2 &amp;&amp;
        name.charCodeAt(0) === name.charCodeAt(length - 1) &amp;&amp;
        (name.charCodeAt(0) === 34 /* doubleQuote */ || name.charCodeAt(0) === 39 /* singleQuote */)) {
        return name.substring(1, length - 1);
    }
    ;
    return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sum" id="apidoc.element.typescript.sum">
        function <span class="apidocSignatureSpan">typescript.</span>sum
        <span class="apidocSignatureSpan">(array, prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sum(array, prop) {
    var result = 0;
    for (var _i = 0, array_7 = array; _i &lt; array_7.length; _i++) {
        var v = array_7[_i];
        result += v[prop];
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.symbolPart" id="apidoc.element.typescript.symbolPart">
        function <span class="apidocSignatureSpan">typescript.</span>symbolPart
        <span class="apidocSignatureSpan">(text, symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function symbolPart(text, symbol) {
    return displayPart(text, displayPartKind(symbol));
    function displayPartKind(symbol) {
        var flags = symbol.flags;
        if (flags &amp; 3 /* Variable */) {
            return isFirstDeclarationOfSymbolParameter(symbol) ? ts.SymbolDisplayPartKind.parameterName : ts.SymbolDisplayPartKind
.localName;
        }
        else if (flags &amp; 4 /* Property */) {
            return ts.SymbolDisplayPartKind.propertyName;
        }
        else if (flags &amp; 32768 /* GetAccessor */) {
            return ts.SymbolDisplayPartKind.propertyName;
        }
        else if (flags &amp; 65536 /* SetAccessor */) {
            return ts.SymbolDisplayPartKind.propertyName;
        }
        else if (flags &amp; 8 /* EnumMember */) {
            return ts.SymbolDisplayPartKind.enumMemberName;
        }
        else if (flags &amp; 16 /* Function */) {
            return ts.SymbolDisplayPartKind.functionName;
        }
        else if (flags &amp; 32 /* Class */) {
            return ts.SymbolDisplayPartKind.className;
        }
        else if (flags &amp; 64 /* Interface */) {
            return ts.SymbolDisplayPartKind.interfaceName;
        }
        else if (flags &amp; 384 /* Enum */) {
            return ts.SymbolDisplayPartKind.enumName;
        }
        else if (flags &amp; 1536 /* Module */) {
            return ts.SymbolDisplayPartKind.moduleName;
        }
        else if (flags &amp; 8192 /* Method */) {
            return ts.SymbolDisplayPartKind.methodName;
        }
        else if (flags &amp; 262144 /* TypeParameter */) {
            return ts.SymbolDisplayPartKind.typeParameterName;
        }
        else if (flags &amp; 524288 /* TypeAlias */) {
            return ts.SymbolDisplayPartKind.aliasName;
        }
        else if (flags &amp; 8388608 /* Alias */) {
            return ts.SymbolDisplayPartKind.aliasName;
        }
        return ts.SymbolDisplayPartKind.text;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.symbolToDisplayParts" id="apidoc.element.typescript.symbolToDisplayParts">
        function <span class="apidocSignatureSpan">typescript.</span>symbolToDisplayParts
        <span class="apidocSignatureSpan">(typeChecker, symbol, enclosingDeclaration, meaning, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function symbolToDisplayParts(typeChecker, symbol, enclosingDeclaration, meaning, flags) {
    return mapToDisplayParts(function (writer) {
        typeChecker.getSymbolDisplayBuilder().buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning, flags);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textChangeRangeIsUnchanged" id="apidoc.element.typescript.textChangeRangeIsUnchanged">
        function <span class="apidocSignatureSpan">typescript.</span>textChangeRangeIsUnchanged
        <span class="apidocSignatureSpan">(range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textChangeRangeIsUnchanged(range) {
    return textSpanIsEmpty(range.span) &amp;&amp; range.newLength === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textChangeRangeNewSpan" id="apidoc.element.typescript.textChangeRangeNewSpan">
        function <span class="apidocSignatureSpan">typescript.</span>textChangeRangeNewSpan
        <span class="apidocSignatureSpan">(range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textChangeRangeNewSpan(range) {
    return createTextSpan(range.span.start, range.newLength);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textOrKeywordPart" id="apidoc.element.typescript.textOrKeywordPart">
        function <span class="apidocSignatureSpan">typescript.</span>textOrKeywordPart
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textOrKeywordPart(text) {
    var kind = ts.stringToToken(text);
    return kind === undefined
        ? textPart(text)
        : keywordPart(kind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textPart" id="apidoc.element.typescript.textPart">
        function <span class="apidocSignatureSpan">typescript.</span>textPart
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textPart(text) {
    return displayPart(text, ts.SymbolDisplayPartKind.text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanContainsPosition" id="apidoc.element.typescript.textSpanContainsPosition">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanContainsPosition
        <span class="apidocSignatureSpan">(span, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanContainsPosition(span, position) {
    return position &gt;= span.start &amp;&amp; position &lt; textSpanEnd(span);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanContainsTextSpan" id="apidoc.element.typescript.textSpanContainsTextSpan">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanContainsTextSpan
        <span class="apidocSignatureSpan">(span, other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanContainsTextSpan(span, other) {
    return other.start &gt;= span.start &amp;&amp; textSpanEnd(other) &lt;= textSpanEnd(span);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanEnd" id="apidoc.element.typescript.textSpanEnd">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanEnd
        <span class="apidocSignatureSpan">(span)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanEnd(span) {
    return span.start + span.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanIntersection" id="apidoc.element.typescript.textSpanIntersection">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanIntersection
        <span class="apidocSignatureSpan">(span1, span2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanIntersection(span1, span2) {
    var intersectStart = Math.max(span1.start, span2.start);
    var intersectEnd = Math.min(textSpanEnd(span1), textSpanEnd(span2));
    if (intersectStart &lt;= intersectEnd) {
        return createTextSpanFromBounds(intersectStart, intersectEnd);
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanIntersectsWith" id="apidoc.element.typescript.textSpanIntersectsWith">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanIntersectsWith
        <span class="apidocSignatureSpan">(span, start, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanIntersectsWith(span, start, length) {
    var end = start + length;
    return start &lt;= textSpanEnd(span) &amp;&amp; end &gt;= span.start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanIntersectsWithPosition" id="apidoc.element.typescript.textSpanIntersectsWithPosition">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanIntersectsWithPosition
        <span class="apidocSignatureSpan">(span, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanIntersectsWithPosition(span, position) {
    return position &lt;= textSpanEnd(span) &amp;&amp; position &gt;= span.start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanIntersectsWithTextSpan" id="apidoc.element.typescript.textSpanIntersectsWithTextSpan">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanIntersectsWithTextSpan
        <span class="apidocSignatureSpan">(span, other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanIntersectsWithTextSpan(span, other) {
    return other.start &lt;= textSpanEnd(span) &amp;&amp; textSpanEnd(other) &gt;= span.start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanIsEmpty" id="apidoc.element.typescript.textSpanIsEmpty">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanIsEmpty
        <span class="apidocSignatureSpan">(span)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanIsEmpty(span) {
    return span.length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanOverlap" id="apidoc.element.typescript.textSpanOverlap">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanOverlap
        <span class="apidocSignatureSpan">(span1, span2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanOverlap(span1, span2) {
    var overlapStart = Math.max(span1.start, span2.start);
    var overlapEnd = Math.min(textSpanEnd(span1), textSpanEnd(span2));
    if (overlapStart &lt; overlapEnd) {
        return createTextSpanFromBounds(overlapStart, overlapEnd);
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.textSpanOverlapsWith" id="apidoc.element.typescript.textSpanOverlapsWith">
        function <span class="apidocSignatureSpan">typescript.</span>textSpanOverlapsWith
        <span class="apidocSignatureSpan">(span, other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function textSpanOverlapsWith(span, other) {
    var overlapStart = Math.max(span.start, other.start);
    var overlapEnd = Math.min(textSpanEnd(span), textSpanEnd(other));
    return overlapStart &lt; overlapEnd;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.timestamp" id="apidoc.element.typescript.timestamp">
        function <span class="apidocSignatureSpan">typescript.</span>timestamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function now() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.toEditorSettings" id="apidoc.element.typescript.toEditorSettings">
        function <span class="apidocSignatureSpan">typescript.</span>toEditorSettings
        <span class="apidocSignatureSpan">(optionsAsMap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toEditorSettings(optionsAsMap) {
    var allPropertiesAreCamelCased = true;
    for (var key in optionsAsMap) {
        if (ts.hasProperty(optionsAsMap, key) &amp;&amp; !isCamelCase(key)) {
            allPropertiesAreCamelCased = false;
            break;
        }
    }
    if (allPropertiesAreCamelCased) {
        return optionsAsMap;
    }
    var settings = {};
    for (var key in optionsAsMap) {
        if (ts.hasProperty(optionsAsMap, key)) {
            var newKey = isCamelCase(key) ? key : key.charAt(0).toLowerCase() + key.substr(1);
            settings[newKey] = optionsAsMap[key];
        }
    }
    return settings;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.toPath" id="apidoc.element.typescript.toPath">
        function <span class="apidocSignatureSpan">typescript.</span>toPath
        <span class="apidocSignatureSpan">(fileName, basePath, getCanonicalFileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toPath(fileName, basePath, getCanonicalFileName) {
    var nonCanonicalizedPath = isRootedDiskPath(fileName)
        ? normalizePath(fileName)
        : getNormalizedAbsolutePath(fileName, basePath);
    return getCanonicalFileName(nonCanonicalizedPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.tokenIsIdentifierOrKeyword" id="apidoc.element.typescript.tokenIsIdentifierOrKeyword">
        function <span class="apidocSignatureSpan">typescript.</span>tokenIsIdentifierOrKeyword
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenIsIdentifierOrKeyword(token) {
    return token &gt;= 70 /* Identifier */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.tokenToString" id="apidoc.element.typescript.tokenToString">
        function <span class="apidocSignatureSpan">typescript.</span>tokenToString
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenToString(t) {
    return tokenStrings[t];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.trace" id="apidoc.element.typescript.trace">
        function <span class="apidocSignatureSpan">typescript.</span>trace
        <span class="apidocSignatureSpan">(host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trace(host) {
    host.trace(ts.formatMessage.apply(undefined, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformES2015" id="apidoc.element.typescript.transformES2015">
        function <span class="apidocSignatureSpan">typescript.</span>transformES2015
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformES2015(context) {
    var startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment,
endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
    var resolver = context.getEmitResolver();
    var previousOnSubstituteNode = context.onSubstituteNode;
    var previousOnEmitNode = context.onEmitNode;
    context.onEmitNode = onEmitNode;
    context.onSubstituteNode = onSubstituteNode;
    var currentSourceFile;
    var currentText;
    var hierarchyFacts;
<span class="apidocCodeCommentSpan">    /**
     * Used to track if we are emitting body of the converted loop
     */
</span>    var convertedLoopState;
    /**
     * Keeps track of whether substitutions have been enabled for specific cases.
     * They are persisted between each SourceFile transformation and should not
     * be reset.
     */
    var enabledSubstitutions;
    return transformSourceFile;
    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)) {
            return node;
        }
        currentSourceFile = node;
        currentText = node.text;
        var visited = visitSourceFile(node);
        ts.addEmitHelpers(visited, context.readEmitHelpers());
        currentSourceFile = undefined;
        currentText = undefined;
        hierarchyFacts = 0 /* None */;
        return visited;
    }
    /**
     * Sets the `HierarchyFacts` for this node prior to visiting this node's subtree, returning the facts set prior to modification
.
     * @param excludeFacts The existing `HierarchyFacts` to reset before visiting the subtree.
     * @param includeFacts The new `HierarchyFacts` to set before visiting the subtree.
     **/
    function enterSubtree(excludeFacts, includeFacts) {
        var ancestorFacts = hierarchyFacts;
        hierarchyFacts = (hierarchyFacts &amp; ~excludeFacts | includeFacts) &amp; 16383 /* AncestorFactsMask */;
        return ancestorFacts;
    }
    /**
     * Restores the `HierarchyFacts` for this node's ancestor after visiting this node's
     * subtree, propagating specific facts from the subtree.
     * @param ancestorFacts The `HierarchyFacts` of the ancestor to restore after visiting the subtree.
     * @param excludeFacts The existing `HierarchyFacts` of the subtree that should not be propagated.
     * @param includeFacts The new `HierarchyFacts` of the subtree that should be propagated.
     **/
    function exitSubtree(ancestorFacts, excludeFacts, includeFacts) {
        hierarchyFacts = (hierarchyFacts &amp; ~excludeFacts | includeFacts) &amp; -16384 /* SubtreeFactsMask */ | ancestorFacts;
    }
    function isReturnVoidStatementInConstructorWithCapturedSuper(node) {
        return hierarchyFacts &amp; 4096 /* ConstructorWithCapturedSuper */
            &amp;&amp; node.kind === 218 /* ReturnStatement */
            &amp;&amp; !node.expression;
    }
    function shouldVisitNode(node) {
        return (node.transformFlags &amp; 128 /* ContainsES2015 */) !== 0
            || convertedLoopState !== undefined
            || (hierarchyFacts &amp; 4096 /* ConstructorWithCapturedSuper */ &amp;&amp; ts.isStatement(node))
            || (ts.isIterationStatement(node, /*lookInLabeledStatements*/ false) &amp;&amp; shouldConvertIterationStatementBody(node));
    }
    function visitor(node) {
        if (shouldVisitNode(node)) {
            return visitJavaScript(node);
        }
        else {
            return node;
        }
    }
    function functionBodyVisitor(node) {
        if (shouldVisitNode(node)) {
            return visitBlock(node, /*isFunctionBody*/ true);
        }
        return node;
    }
    function callExpressionVisitor(node) {
        if (node.kind === 96 /* SuperKeyword */) {
            return visitSuperKeyword(/*isExpressionOfCall*/ true);
        }
        return visitor(node);
    }
    function visitJavaScript(node) {
        switch (node.kind) {
            case 114 /* StaticKeyword */:
                return undefined; // elide static keyword
            case 228 /* ClassDeclaration */:
                return visitClassDeclaration(node); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformES2015Module" id="apidoc.element.typescript.transformES2015Module">
        function <span class="apidocSignatureSpan">typescript.</span>transformES2015Module
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformES2015Module(context) {
    var compilerOptions = context.getCompilerOptions();
    var previousOnEmitNode = context.onEmitNode;
    var previousOnSubstituteNode = context.onSubstituteNode;
    context.onEmitNode = onEmitNode;
    context.onSubstituteNode = onSubstituteNode;
    context.enableEmitNotification(263<span class="apidocCodeCommentSpan"> /* SourceFile */);
    context.enableSubstitution(70 /* Identifier */);
    var currentSourceFile;
    return transformSourceFile;
    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)) {
            return node;
        }
        if (ts.isExternalModule(node) || compilerOptions.isolatedModules) {
            var externalHelpersModuleName = ts.getOrCreateExternalHelpersModuleNameIfNeeded(node, compilerOptions);
            if (externalHelpersModuleName) {
                var statements = [];
                var statementOffset = ts.addPrologueDirectives(statements, node.statements);
                ts.append(statements, ts.createImportDeclaration(
                /*decorators*/ undefined,
                /*modifiers*/ undefined, ts.createImportClause(/*name*/ undefined, ts.createNamespaceImport(externalHelpersModuleName
)), ts.createLiteral(ts.externalHelpersModuleNameText)));
                ts.addRange(statements, ts.visitNodes(node.statements, visitor, ts.isStatement, statementOffset));
                return ts.updateSourceFileNode(node, ts.setTextRange(ts.createNodeArray(statements), node.statements));
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        return node;
    }
    function visitor(node) {
        switch (node.kind) {
            case 236 /* ImportEqualsDeclaration */:
                // Elide `import=` as it is not legal with --module ES6
                return undefined;
            case 242 /* ExportAssignment */:
                return visitExportAssignment(node);
        }
        return node;
    }
    function visitExportAssignment(node) {
        // Elide `export=` as it is not legal with --module ES6
        return node.isExportEquals ? undefined : node;
    }
    //
    // Emit Notification
    //
    /**
     * Hook for node emit.
     *
     * @param hint A hint as to the intended usage of the node.
     * @param node The node to emit.
     * @param emit A callback used to emit the node in the printer.
     */
</span>    function onEmitNode(hint, node, emitCallback) {
        if (ts.isSourceFile(node)) {
            currentSourceFile = node;
            previousOnEmitNode(hint, node, emitCallback);
            currentSourceFile = undefined;
        }
        else {
            previousOnEmitNode(hint, node, emitCallback);
        }
    }
    //
    // Substitutions
    //
    /**
     * Hooks node substitutions.
     *
     * @param hint A hint as to the intended usage of the node.
     * @param node The node to substitute.
     */
    function onSubstituteNode(hint, node) {
        node = previousOnSubstituteNode(hint, node);
        if (ts.isIdentifier(node) &amp;&amp; hint === 1 /* Expression */) {
            return substituteExpressionIdentifier(node);
        }
        return node;
    }
    function substituteExpressionIdentifier(node) {
        if (ts.getEmitFlags(node) &amp; 4096 /* HelperName */) {
            var externalHelpersModuleName = ts.getExternalHelpersModuleName(currentSourceFile);
            if (externalHelpersModuleName) {
                return ts.createPropertyAccess(externalHelpersModuleName, node);
            }
        }
        return node;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformES2016" id="apidoc.element.typescript.transformES2016">
        function <span class="apidocSignatureSpan">typescript.</span>transformES2016
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformES2016(context) {
    var hoistVariableDeclaration = context.hoistVariableDeclaration;
    return transformSourceFile;
    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)) {
            return node;
        }
        return ts.visitEachChild(node, visitor, context);
    }
    function visitor(node) {
        if ((node.transformFlags &amp; 32 /* ContainsES2016 */) === 0) {
            return node;
        }
        switch (node.kind) {
            case 193 /* BinaryExpression */:
                return visitBinaryExpression(node);
            default:
                return ts.visitEachChild(node, visitor, context);
        }
    }
    function visitBinaryExpression(node) {
        switch (node.operatorToken.kind) {
            case 61 /* AsteriskAsteriskEqualsToken */:
                return visitExponentiationAssignmentExpression(node);
            case 39 /* AsteriskAsteriskToken */:
                return visitExponentiationExpression(node);
            default:
                return ts.visitEachChild(node, visitor, context);
        }
    }
    function visitExponentiationAssignmentExpression(node) {
        var target;
        var value;
        var left = ts.visitNode(node.left, visitor, ts.isExpression);
        var right = ts.visitNode(node.right, visitor, ts.isExpression);
        if (ts.isElementAccessExpression(left)) {
            // Transforms `a[x] **= b` into `(_a = a)[_x = x] = Math.pow(_a[_x], b)`
            var expressionTemp = ts.createTempVariable(hoistVariableDeclaration);
            var argumentExpressionTemp = ts.createTempVariable(hoistVariableDeclaration);
            target = ts.setTextRange(ts.createElementAccess(ts.setTextRange(ts.createAssignment(expressionTemp, left.expression),
left.expression), ts.setTextRange(ts.createAssignment(argumentExpressionTemp, left.argumentExpression), left.argumentExpression)),
left);
            value = ts.setTextRange(ts.createElementAccess(expressionTemp, argumentExpressionTemp), left);
        }
        else if (ts.isPropertyAccessExpression(left)) {
            // Transforms `a.x **= b` into `(_a = a).x = Math.pow(_a.x, b)`
            var expressionTemp = ts.createTempVariable(hoistVariableDeclaration);
            target = ts.setTextRange(ts.createPropertyAccess(ts.setTextRange(ts.createAssignment(expressionTemp, left.expression
), left.expression), left.name), left);
            value = ts.setTextRange(ts.createPropertyAccess(expressionTemp, left.name), left);
        }
        else {
            // Transforms `a **= b` into `a = Math.pow(a, b)`
            target = left;
            value = left;
        }
        return ts.setTextRange(ts.createAssignment(target, ts.createMathPow(value, right, /*location*/ node)), node);
    }
    function visitExponentiationExpression(node) {
        // Transforms `a ** b` into `Math.pow(a, b)`
        var left = ts.visitNode(node.left, visitor, ts.isExpression);
        var right = ts.visitNode(node.right, visitor, ts.isExpression);
        return ts.createMathPow(left, right, /*location*/ node);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformES2017" id="apidoc.element.typescript.transformES2017">
        function <span class="apidocSignatureSpan">typescript.</span>transformES2017
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformES2017(context) {
    var startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment,
endLexicalEnvironment = context.endLexicalEnvironment;
    var resolver = context.getEmitResolver();
    var compilerOptions = context.getCompilerOptions();
    var languageVersion = ts.getEmitScriptTarget(compilerOptions);
    // These variables contain state that changes as we descend into the tree.
    var currentSourceFile;
<span class="apidocCodeCommentSpan">    /**
     * Keeps track of whether expression substitution has been enabled for specific edge cases.
     * They are persisted between each SourceFile transformation and should not be reset.
     */
</span>    var enabledSubstitutions;
    /**
     * This keeps track of containers where `super` is valid, for use with
     * just-in-time substitution for `super` expressions inside of async methods.
     */
    var currentSuperContainer;
    // Save the previous transformation hooks.
    var previousOnEmitNode = context.onEmitNode;
    var previousOnSubstituteNode = context.onSubstituteNode;
    // Set new transformation hooks.
    context.onEmitNode = onEmitNode;
    context.onSubstituteNode = onSubstituteNode;
    return transformSourceFile;
    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)) {
            return node;
        }
        currentSourceFile = node;
        var visited = ts.visitEachChild(node, visitor, context);
        ts.addEmitHelpers(visited, context.readEmitHelpers());
        currentSourceFile = undefined;
        return visited;
    }
    function visitor(node) {
        if ((node.transformFlags &amp; 16 /* ContainsES2017 */) === 0) {
            return node;
        }
        switch (node.kind) {
            case 119 /* AsyncKeyword */:
                // ES2017 async modifier should be elided for targets &lt; ES2017
                return undefined;
            case 190 /* AwaitExpression */:
                // ES2017 'await' expressions must be transformed for targets &lt; ES2017.
                return visitAwaitExpression(node);
            case 150 /* MethodDeclaration */:
                // ES2017 method declarations may be 'async'
                return visitMethodDeclaration(node);
            case 227 /* FunctionDeclaration */:
                // ES2017 function declarations may be 'async'
                return visitFunctionDeclaration(node);
            case 185 /* FunctionExpression */:
                // ES2017 function expressions may be 'async'
                return visitFunctionExpression(node);
            case 186 /* ArrowFunction */:
                // ES2017 arrow functions may be 'async'
                return visitArrowFunction(node);
            default:
                return ts.visitEachChild(node, visitor, context);
        }
    }
    /**
     * Visits an AwaitExpression node.
     *
     * This function will be called any time a ES2017 await expression is encountered.
     *
     * @param node The node to visit.
     */
    function visitAwaitExpression(node) {
        return ts.setOriginalNode(ts.setTextRange(ts.createYield(
        /*asteriskToken*/ undefined, ts.visitNode(node.expression, visitor, ts.isExpression)), node), node);
    }
    /**
     * Visits a MethodDeclaration node.
     *
     * This function will be called when one of the following conditions are met:
     * - The node is marked as async
     *
     * @param node The node to visit.
     */
    function visitMethodDeclaration(node) {
        return ts.updateMethod(node,
        /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.name,
        /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context),
        /*type*/ undefined, ts.isAsyncFunctionLike(node)
            ? transformAsyncFunctionBody(node)
            : ts.visitFunctionBody(node.body, visitor, context));
    }
    /**
     * Visits a FunctionDeclaration node.
     *
     * This function will be called when one of the following conditions are met:
     * - The node is marke ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformES5" id="apidoc.element.typescript.transformES5">
        function <span class="apidocSignatureSpan">typescript.</span>transformES5
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformES5(context) {
    var compilerOptions = context.getCompilerOptions();
    // enable emit notification only if using --jsx preserve or react-native
    var previousOnEmitNode;
    var noSubstitution;
    if (compilerOptions.jsx === 1<span class="apidocCodeCommentSpan"> /* Preserve */ || compilerOptions.jsx === 3 /* ReactNative */) {
        previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        context.enableEmitNotification(250 /* JsxOpeningElement */);
        context.enableEmitNotification(251 /* JsxClosingElement */);
        context.enableEmitNotification(249 /* JsxSelfClosingElement */);
        noSubstitution = [];
    }
    var previousOnSubstituteNode = context.onSubstituteNode;
    context.onSubstituteNode = onSubstituteNode;
    context.enableSubstitution(178 /* PropertyAccessExpression */);
    context.enableSubstitution(259 /* PropertyAssignment */);
    return transformSourceFile;
    /**
     * Transforms an ES5 source file to ES3.
     *
     * @param node A SourceFile
     */
</span>    function transformSourceFile(node) {
        return node;
    }
    /**
     * Called by the printer just before a node is printed.
     *
     * @param hint A hint as to the intended usage of the node.
     * @param node The node to emit.
     * @param emitCallback A callback used to emit the node.
     */
    function onEmitNode(hint, node, emitCallback) {
        switch (node.kind) {
            case 250 /* JsxOpeningElement */:
            case 251 /* JsxClosingElement */:
            case 249 /* JsxSelfClosingElement */:
                var tagName = node.tagName;
                noSubstitution[ts.getOriginalNodeId(tagName)] = true;
                break;
        }
        previousOnEmitNode(hint, node, emitCallback);
    }
    /**
     * Hooks node substitutions.
     *
     * @param hint A hint as to the intended usage of the node.
     * @param node The node to substitute.
     */
    function onSubstituteNode(hint, node) {
        if (node.id &amp;&amp; noSubstitution &amp;&amp; noSubstitution[node.id]) {
            return previousOnSubstituteNode(hint, node);
        }
        node = previousOnSubstituteNode(hint, node);
        if (ts.isPropertyAccessExpression(node)) {
            return substitutePropertyAccessExpression(node);
        }
        else if (ts.isPropertyAssignment(node)) {
            return substitutePropertyAssignment(node);
        }
        return node;
    }
    /**
     * Substitutes a PropertyAccessExpression whose name is a reserved word.
     *
     * @param node A PropertyAccessExpression
     */
    function substitutePropertyAccessExpression(node) {
        var literalName = trySubstituteReservedName(node.name);
        if (literalName) {
            return ts.setTextRange(ts.createElementAccess(node.expression, literalName), node);
        }
        return node;
    }
    /**
     * Substitutes a PropertyAssignment whose name is a reserved word.
     *
     * @param node A PropertyAssignment
     */
    function substitutePropertyAssignment(node) {
        var literalName = ts.isIdentifier(node.name) &amp;&amp; trySubstituteReservedName(node.name);
        if (literalName) {
            return ts.updatePropertyAssignment(node, literalName, node.initializer);
        }
        return node;
    }
    /**
     * If an identifier name is a reserved word, returns a string literal for the name.
     *
     * @param name An Identifier
     */
    function trySubstituteReservedName(name) {
        var token = name.originalKeywordKind || (ts.nodeIsSynthesized(name) ? ts.stringToToken(name.text) : undefined);
        if (token &gt;= 71 /* FirstReservedWord */ &amp;&amp; token &lt;= 106 /* LastReservedWord */) {
            return ts.setTextRange(ts.createLiteral(name), name);
        }
        return undefined;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformESNext" id="apidoc.element.typescript.transformESNext">
        function <span class="apidocSignatureSpan">typescript.</span>transformESNext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformESNext(context) {
    var resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment;
    return transformSourceFile;
    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)) {
            return node;
        }
        var visited = ts.visitEachChild(node, visitor, context);
        ts.addEmitHelpers(visited, context.readEmitHelpers());
        return visited;
    }
    function visitor(node) {
        return visitorWorker(node, /*noDestructuringValue*/ false);
    }
    function visitorNoDestructuringValue(node) {
        return visitorWorker(node, /*noDestructuringValue*/ true);
    }
    function visitorWorker(node, noDestructuringValue) {
        if ((node.transformFlags &amp; 8 /* ContainsESNext */) === 0) {
            return node;
        }
        switch (node.kind) {
            case 177 /* ObjectLiteralExpression */:
                return visitObjectLiteralExpression(node);
            case 193 /* BinaryExpression */:
                return visitBinaryExpression(node, noDestructuringValue);
            case 225 /* VariableDeclaration */:
                return visitVariableDeclaration(node);
            case 215 /* ForOfStatement */:
                return visitForOfStatement(node);
            case 213 /* ForStatement */:
                return visitForStatement(node);
            case 189 /* VoidExpression */:
                return visitVoidExpression(node);
            case 151 /* Constructor */:
                return visitConstructorDeclaration(node);
            case 150 /* MethodDeclaration */:
                return visitMethodDeclaration(node);
            case 152 /* GetAccessor */:
                return visitGetAccessorDeclaration(node);
            case 153 /* SetAccessor */:
                return visitSetAccessorDeclaration(node);
            case 227 /* FunctionDeclaration */:
                return visitFunctionDeclaration(node);
            case 185 /* FunctionExpression */:
                return visitFunctionExpression(node);
            case 186 /* ArrowFunction */:
                return visitArrowFunction(node);
            case 145 /* Parameter */:
                return visitParameter(node);
            case 209 /* ExpressionStatement */:
                return visitExpressionStatement(node);
            case 184 /* ParenthesizedExpression */:
                return visitParenthesizedExpression(node, noDestructuringValue);
            default:
                return ts.visitEachChild(node, visitor, context);
        }
    }
    function chunkObjectLiteralElements(elements) {
        var chunkObject;
        var objects = [];
        for (var _i = 0, elements_4 = elements; _i &lt; elements_4.length; _i++) {
            var e = elements_4[_i];
            if (e.kind === 261 /* SpreadAssignment */) {
                if (chunkObject) {
                    objects.push(ts.createObjectLiteral(chunkObject));
                    chunkObject = undefined;
                }
                var target = e.expression;
                objects.push(ts.visitNode(target, visitor, ts.isExpression));
            }
            else {
                if (!chunkObject) {
                    chunkObject = [];
                }
                if (e.kind === 259 /* PropertyAssignment */) {
                    var p = e;
                    chunkObject.push(ts.createPropertyAssignment(p.name, ts.visitNode(p.initializer, visitor, ts.isExpression)));
                }
                else {
                    chunkObject.push(e);
                }
            }
        }
        if (chunkObject) {
            objects.push(ts.createObjectLiteral(chunkObject));
        }
        return objects;
    }
    function visitObjectLiteralExpression(node) {
        if (node.transformFlags &amp; 1048576 /* ContainsObjectSpread */) {
            // spread elements emit like so:
            // non-spread elements are chunked together into object literals, and then all are passed to __assign:
            //     { a, ...o, b } =&gt; __assign ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformFiles" id="apidoc.element.typescript.transformFiles">
        function <span class="apidocSignatureSpan">typescript.</span>transformFiles
        <span class="apidocSignatureSpan">(resolver, host, sourceFiles, transformers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformFiles(resolver, host, sourceFiles, transformers) {
    var enabledSyntaxKindFeatures = new Array(300<span class="apidocCodeCommentSpan"> /* Count */);
    var lexicalEnvironmentDisabled = false;
    var lexicalEnvironmentVariableDeclarations;
    var lexicalEnvironmentFunctionDeclarations;
    var lexicalEnvironmentVariableDeclarationsStack = [];
    var lexicalEnvironmentFunctionDeclarationsStack = [];
    var lexicalEnvironmentStackOffset = 0;
    var lexicalEnvironmentSuspended = false;
    var emitHelpers;
    // The transformation context is provided to each transformer as part of transformer
    // initialization.
    var context = {
        getCompilerOptions: function () { return host.getCompilerOptions(); },
        getEmitResolver: function () { return resolver; },
        getEmitHost: function () { return host; },
        startLexicalEnvironment: startLexicalEnvironment,
        suspendLexicalEnvironment: suspendLexicalEnvironment,
        resumeLexicalEnvironment: resumeLexicalEnvironment,
        endLexicalEnvironment: endLexicalEnvironment,
        hoistVariableDeclaration: hoistVariableDeclaration,
        hoistFunctionDeclaration: hoistFunctionDeclaration,
        requestEmitHelper: requestEmitHelper,
        readEmitHelpers: readEmitHelpers,
        onSubstituteNode: function (_, node) { return node; },
        enableSubstitution: enableSubstitution,
        isSubstitutionEnabled: isSubstitutionEnabled,
        onEmitNode: function (hint, node, callback) { return callback(hint, node); },
        enableEmitNotification: enableEmitNotification,
        isEmitNotificationEnabled: isEmitNotificationEnabled
    };
    ts.performance.mark("beforeTransform");
    // Chain together and initialize each transformer.
    var transformation = ts.chain.apply(void 0, transformers)(context);
    // Transform each source file.
    var transformed = ts.map(sourceFiles, transformSourceFile);
    // Disable modification of the lexical environment.
    lexicalEnvironmentDisabled = true;
    ts.performance.mark("afterTransform");
    ts.performance.measure("transformTime", "beforeTransform", "afterTransform");
    return {
        transformed: transformed,
        emitNodeWithSubstitution: emitNodeWithSubstitution,
        emitNodeWithNotification: emitNodeWithNotification
    };
    /**
     * Transforms a source file.
     *
     * @param sourceFile The source file to transform.
     */
</span>    function transformSourceFile(sourceFile) {
        if (ts.isDeclarationFile(sourceFile)) {
            return sourceFile;
        }
        return transformation(sourceFile);
    }
    /**
     * Enables expression substitutions in the pretty printer for the provided SyntaxKind.
     */
    function enableSubstitution(kind) {
        enabledSyntaxKindFeatures[kind] |= 1 /* Substitution */;
    }
    /**
     * Determines whether expression substitutions are enabled for the provided node.
     */
    function isSubstitutionEnabled(node) {
        return (enabledSyntaxKindFeatures[node.kind] &amp; 1 /* Substitution */) !== 0
            &amp;&amp; (ts.getEmitFlags(node) &amp; 4 /* NoSubstitution */) === 0;
    }
    /**
     * Emits a node with possible substitution.
     *
     * @param hint A hint as to the intended usage of the node.
     * @param node The node to emit.
     * @param emitCallback The callback used to emit the node or its substitute.
     */
    function emitNodeWithSubstitution(hint, node, emitCallback) {
        if (node) {
            if (isSubstitutionEnabled(node)) {
                node = context.onSubstituteNode(hint, node) || node;
            }
            emitCallback(hint, node);
        }
    }
    /**
     * Enables before/after emit notifications in the pretty printer for the provided SyntaxKind.
     */
    function enableEmitNotification(kind) {
        enabledSyntaxKindFeatures[kind] |= 2 /* EmitNotifications */;
    }
    /**
     * Determines whether before/after emit notifications should be raised in the pretty
     * printer when it emits a node.
     */
    function isEmitNotificationEnabled(node) {
        return (enabledSyntaxKin ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformGenerators" id="apidoc.element.typescript.transformGenerators">
        function <span class="apidocSignatureSpan">typescript.</span>transformGenerators
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformGenerators(context) {
    var resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistFunctionDeclaration
 = context.hoistFunctionDeclaration, hoistVariableDeclaration = context.hoistVariableDeclaration;
    var compilerOptions = context.getCompilerOptions();
    var languageVersion = ts.getEmitScriptTarget(compilerOptions);
    var resolver = context.getEmitResolver();
    var previousOnSubstituteNode = context.onSubstituteNode;
    context.onSubstituteNode = onSubstituteNode;
    var currentSourceFile;
    var renamedCatchVariables;
    var renamedCatchVariableDeclarations;
    var inGeneratorFunctionBody;
    var inStatementContainingYield;
    // The following three arrays store information about generated code blocks.
    // All three arrays are correlated by their index. This approach is used over allocating
    // objects to store the same information to avoid GC overhead.
    //
    var blocks; // Information about the code block
    var blockOffsets; // The operation offset at which a code block begins or ends
    var blockActions; // Whether the code block is opened or closed
    var blockStack; // A stack of currently open code blocks
    // Labels are used to mark locations in the code that can be the target of a Break (jump)
    // operation. These are translated into case clauses in a switch statement.
    // The following two arrays are correlated by their index. This approach is used over
    // allocating objects to store the same information to avoid GC overhead.
    //
    var labelOffsets; // The operation offset at which the label is defined.
    var labelExpressions; // The NumericLiteral nodes bound to each label.
    var nextLabelId = 1; // The next label id to use.
    // Operations store information about generated code for the function body. This
    // Includes things like statements, assignments, breaks (jumps), and yields.
    // The following three arrays are correlated by their index. This approach is used over
    // allocating objects to store the same information to avoid GC overhead.
    //
    var operations; // The operation to perform.
    var operationArguments; // The arguments to the operation.
    var operationLocations; // The source map location for the operation.
    var state; // The name of the state object used by the generator at runtime.
    // The following variables store information used by the `build` function:
    //
    var blockIndex = 0; // The index of the current block.
    var labelNumber = 0; // The current label number.
    var labelNumbers;
    var lastOperationWasAbrupt; // Indicates whether the last operation was abrupt (break/continue).
    var lastOperationWasCompletion; // Indicates whether the last operation was a completion (return/throw).
    var clauses; // The case clauses generated for labels.
    var statements; // The statements for the current label.
    var exceptionBlockStack; // A stack of containing exception blocks.
    var currentExceptionBlock; // The current exception block.
    var withBlockStack; // A stack containing `with` blocks.
    return transformSourceFile;
    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)
            || (node.transformFlags &amp; 512<span class="apidocCodeCommentSpan"> /* ContainsGenerator */) === 0) {
            return node;
        }
        currentSourceFile = node;
        var visited = ts.visitEachChild(node, visitor, context);
        ts.addEmitHelpers(visited, context.readEmitHelpers());
        currentSourceFile = undefined;
        return visited;
    }
    /**
     * Visits a node.
     *
     * @param node The node to visit.
     */
</span>    function visitor(node) {
        var transformFlags = node.transformFlags;
        if (inStatementContainingYield) {
            return visitJavaScriptInStatementContainingYield(node);
        }
        else if (inGeneratorFunctionBody) {
            return visitJavaScriptInGeneratorFunctionBody(node);
        }
        else if (transformFlags &amp; 256 /* Generator */) {
            return visitG ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformJsx" id="apidoc.element.typescript.transformJsx">
        function <span class="apidocSignatureSpan">typescript.</span>transformJsx
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformJsx(context) {
    var compilerOptions = context.getCompilerOptions();
    var currentSourceFile;
    return transformSourceFile;
<span class="apidocCodeCommentSpan">    /**
     * Transform JSX-specific syntax in a SourceFile.
     *
     * @param node A SourceFile node.
     */
</span>    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)) {
            return node;
        }
        currentSourceFile = node;
        var visited = ts.visitEachChild(node, visitor, context);
        ts.addEmitHelpers(visited, context.readEmitHelpers());
        currentSourceFile = undefined;
        return visited;
    }
    function visitor(node) {
        if (node.transformFlags &amp; 4 /* ContainsJsx */) {
            return visitorWorker(node);
        }
        else {
            return node;
        }
    }
    function visitorWorker(node) {
        switch (node.kind) {
            case 248 /* JsxElement */:
                return visitJsxElement(node, /*isChild*/ false);
            case 249 /* JsxSelfClosingElement */:
                return visitJsxSelfClosingElement(node, /*isChild*/ false);
            case 254 /* JsxExpression */:
                return visitJsxExpression(node);
            default:
                return ts.visitEachChild(node, visitor, context);
        }
    }
    function transformJsxChildToExpression(node) {
        switch (node.kind) {
            case 10 /* JsxText */:
                return visitJsxText(node);
            case 254 /* JsxExpression */:
                return visitJsxExpression(node);
            case 248 /* JsxElement */:
                return visitJsxElement(node, /*isChild*/ true);
            case 249 /* JsxSelfClosingElement */:
                return visitJsxSelfClosingElement(node, /*isChild*/ true);
            default:
                ts.Debug.failBadSyntaxKind(node);
                return undefined;
        }
    }
    function visitJsxElement(node, isChild) {
        return visitJsxOpeningLikeElement(node.openingElement, node.children, isChild, /*location*/ node);
    }
    function visitJsxSelfClosingElement(node, isChild) {
        return visitJsxOpeningLikeElement(node, /*children*/ undefined, isChild, /*location*/ node);
    }
    function visitJsxOpeningLikeElement(node, children, isChild, location) {
        var tagName = getTagName(node);
        var objectProperties;
        var attrs = node.attributes;
        if (attrs.length === 0) {
            // When there are no attributes, React wants "null"
            objectProperties = ts.createNull();
        }
        else {
            // Map spans of JsxAttribute nodes into object literals and spans
            // of JsxSpreadAttribute nodes into expressions.
            var segments = ts.flatten(ts.spanMap(attrs, ts.isJsxSpreadAttribute, function (attrs, isSpread) { return isSpread
                ? ts.map(attrs, transformJsxSpreadAttributeToExpression)
                : ts.createObjectLiteral(ts.map(attrs, transformJsxAttributeToObjectLiteralElement)); }));
            if (ts.isJsxSpreadAttribute(attrs[0])) {
                // We must always emit at least one object literal before a spread
                // argument.
                segments.unshift(ts.createObjectLiteral());
            }
            // Either emit one big object literal (no spread attribs), or
            // a call to the __assign helper.
            objectProperties = ts.singleOrUndefined(segments);
            if (!objectProperties) {
                objectProperties = ts.createAssignHelper(context, segments);
            }
        }
        var element = ts.createExpressionForJsxElement(context.getEmitResolver().getJsxFactoryEntity(), compilerOptions.reactNamespace
, tagName, objectProperties, ts.filter(ts.map(children, transformJsxChildToExpression), ts.isDefined), node, location);
        if (isChild) {
            ts.startOnNewLine(element);
        }
        return element;
    }
    function transformJsxSpreadAttributeToExpression(node) {
        return ts.visitNode(node.expression, visitor, ts.isExpression);
    }
    function transformJsxA ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformModule" id="apidoc.element.typescript.transformModule">
        function <span class="apidocSignatureSpan">typescript.</span>transformModule
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformModule(context) {
    function getTransformModuleDelegate(moduleKind) {
        switch (moduleKind) {
            case ts.ModuleKind.AMD: return transformAMDModule;
            case ts.ModuleKind.UMD: return transformUMDModule;
            default: return transformCommonJSModule;
        }
    }
    var startLexicalEnvironment = context.startLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment;
    var compilerOptions = context.getCompilerOptions();
    var resolver = context.getEmitResolver();
    var host = context.getEmitHost();
    var languageVersion = ts.getEmitScriptTarget(compilerOptions);
    var moduleKind = ts.getEmitModuleKind(compilerOptions);
    var previousOnSubstituteNode = context.onSubstituteNode;
    var previousOnEmitNode = context.onEmitNode;
    context.onSubstituteNode = onSubstituteNode;
    context.onEmitNode = onEmitNode;
    context.enableSubstitution(70<span class="apidocCodeCommentSpan"> /* Identifier */); // Substitutes expression identifiers with imported/exported symbols.
    context.enableSubstitution(193 /* BinaryExpression */); // Substitutes assignments to exported symbols.
    context.enableSubstitution(191 /* PrefixUnaryExpression */); // Substitutes updates to exported symbols.
    context.enableSubstitution(192 /* PostfixUnaryExpression */); // Substitutes updates to exported symbols.
    context.enableSubstitution(260 /* ShorthandPropertyAssignment */); // Substitutes shorthand property assignments for imported
/exported symbols.
    context.enableEmitNotification(263 /* SourceFile */); // Restore state when substituting nodes in a file.
    var moduleInfoMap = []; // The ExternalModuleInfo for each file.
    var deferredExports = []; // Exports to defer until an EndOfDeclarationMarker is found.
    var currentSourceFile; // The current file.
    var currentModuleInfo; // The ExternalModuleInfo for the current file.
    var noSubstitution; // Set of nodes for which substitution rules should be ignored.
    return transformSourceFile;
    /**
     * Transforms the module aspects of a SourceFile.
     *
     * @param node The SourceFile node.
     */
</span>    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)
            || !(ts.isExternalModule(node)
                || compilerOptions.isolatedModules)) {
            return node;
        }
        currentSourceFile = node;
        currentModuleInfo = ts.collectExternalModuleInfo(node, resolver, compilerOptions);
        moduleInfoMap[ts.getOriginalNodeId(node)] = currentModuleInfo;
        // Perform the transformation.
        var transformModule = getTransformModuleDelegate(moduleKind);
        var updated = transformModule(node);
        currentSourceFile = undefined;
        currentModuleInfo = undefined;
        return ts.aggregateTransformFlags(updated);
    }
    /**
     * Transforms a SourceFile into a CommonJS module.
     *
     * @param node The SourceFile node.
     */
    function transformCommonJSModule(node) {
        startLexicalEnvironment();
        var statements = [];
        var statementOffset = ts.addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict
, sourceElementVisitor);
        if (!currentModuleInfo.exportEquals) {
            ts.append(statements, createUnderscoreUnderscoreESModule());
        }
        ts.append(statements, ts.visitNode(currentModuleInfo.externalHelpersImportDeclaration, sourceElementVisitor, ts.isStatement
, /*optional*/ true));
        ts.addRange(statements, ts.visitNodes(node.statements, sourceElementVisitor, ts.isStatement, statementOffset));
        ts.addRange(statements, endLexicalEnvironment());
        addExportEqualsIfNeeded(statements, /*emitAsReturn*/ false);
        var updated = ts.updateSourceFileNode(node, ts.setTextRange(ts.createNodeArray(statements), node.statements));
        if (currentModuleInfo.hasExportStarsToExportValues) {
            ts.addEmitHelper(updated, exportStarHelper);
        }
        return updated;
    }
    /**
     * Transforms a SourceFile into an AMD module. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformSystemModule" id="apidoc.element.typescript.transformSystemModule">
        function <span class="apidocSignatureSpan">typescript.</span>transformSystemModule
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformSystemModule(context) {
    var startLexicalEnvironment = context.startLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration
 = context.hoistVariableDeclaration;
    var compilerOptions = context.getCompilerOptions();
    var resolver = context.getEmitResolver();
    var host = context.getEmitHost();
    var previousOnSubstituteNode = context.onSubstituteNode;
    var previousOnEmitNode = context.onEmitNode;
    context.onSubstituteNode = onSubstituteNode;
    context.onEmitNode = onEmitNode;
    context.enableSubstitution(70<span class="apidocCodeCommentSpan"> /* Identifier */); // Substitutes expression identifiers for imported symbols.
    context.enableSubstitution(193 /* BinaryExpression */); // Substitutes assignments to exported symbols.
    context.enableSubstitution(191 /* PrefixUnaryExpression */); // Substitutes updates to exported symbols.
    context.enableSubstitution(192 /* PostfixUnaryExpression */); // Substitutes updates to exported symbols.
    context.enableEmitNotification(263 /* SourceFile */); // Restore state when substituting nodes in a file.
    var moduleInfoMap = []; // The ExternalModuleInfo for each file.
    var deferredExports = []; // Exports to defer until an EndOfDeclarationMarker is found.
    var exportFunctionsMap = []; // The export function associated with a source file.
    var noSubstitutionMap = []; // Set of nodes for which substitution rules should be ignored for each file.
    var currentSourceFile; // The current file.
    var moduleInfo; // ExternalModuleInfo for the current file.
    var exportFunction; // The export function for the current file.
    var contextObject; // The context object for the current file.
    var hoistedStatements;
    var enclosingBlockScopedContainer;
    var noSubstitution; // Set of nodes for which substitution rules should be ignored.
    return transformSourceFile;
    /**
     * Transforms the module aspects of a SourceFile.
     *
     * @param node The SourceFile node.
     */
</span>    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)
            || !(ts.isExternalModule(node)
                || compilerOptions.isolatedModules)) {
            return node;
        }
        var id = ts.getOriginalNodeId(node);
        currentSourceFile = node;
        enclosingBlockScopedContainer = node;
        // System modules have the following shape:
        //
        //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})
        //
        // The parameter 'exports' here is a callback '&lt;T&gt;(name: string, value: T) =&gt; T' that
        // is used to publish exported values. 'exports' returns its 'value' argument so in
        // most cases expressions that mutate exported values can be rewritten as:
        //
        //     expr -&gt; exports('name', expr)
        //
        // The only exception in this rule is postfix unary operators,
        // see comment to 'substitutePostfixUnaryExpression' for more details
        // Collect information about the external module and dependency groups.
        moduleInfo = moduleInfoMap[id] = ts.collectExternalModuleInfo(node, resolver, compilerOptions);
        // Make sure that the name of the 'exports' function does not conflict with
        // existing identifiers.
        exportFunction = ts.createUniqueName("exports");
        exportFunctionsMap[id] = exportFunction;
        contextObject = ts.createUniqueName("context");
        // Add the body of the module.
        var dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);
        var moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);
        var moduleBodyFunction = ts.createFunctionExpression(
        /*modifiers*/ undefined,
        /*asteriskToken*/ undefined,
        /*name*/ undefined,
        /*typeParameters*/ undefined, [
            ts.createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, exportFunction),
            ts.createParameter(/*decorators*/ undefined, /*modifiers*/ undefine ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transformTypeScript" id="apidoc.element.typescript.transformTypeScript">
        function <span class="apidocSignatureSpan">typescript.</span>transformTypeScript
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformTypeScript(context) {
    var startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment,
endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
    var resolver = context.getEmitResolver();
    var compilerOptions = context.getCompilerOptions();
    var languageVersion = ts.getEmitScriptTarget(compilerOptions);
    var moduleKind = ts.getEmitModuleKind(compilerOptions);
    // Save the previous transformation hooks.
    var previousOnEmitNode = context.onEmitNode;
    var previousOnSubstituteNode = context.onSubstituteNode;
    // Set new transformation hooks.
    context.onEmitNode = onEmitNode;
    context.onSubstituteNode = onSubstituteNode;
    // Enable substitution for property/element access to emit const enum values.
    context.enableSubstitution(178<span class="apidocCodeCommentSpan"> /* PropertyAccessExpression */);
    context.enableSubstitution(179 /* ElementAccessExpression */);
    // These variables contain state that changes as we descend into the tree.
    var currentSourceFile;
    var currentNamespace;
    var currentNamespaceContainerName;
    var currentScope;
    var currentScopeFirstDeclarationsOfName;
    /**
     * Keeps track of whether expression substitution has been enabled for specific edge cases.
     * They are persisted between each SourceFile transformation and should not be reset.
     */
</span>    var enabledSubstitutions;
    /**
     * A map that keeps track of aliases created for classes with decorators to avoid issues
     * with the double-binding behavior of classes.
     */
    var classAliases;
    /**
     * Keeps track of whether  we are within any containing namespaces when performing
     * just-in-time substitution while printing an expression identifier.
     */
    var applicableSubstitutions;
    return transformSourceFile;
    /**
     * Transform TypeScript-specific syntax in a SourceFile.
     *
     * @param node A SourceFile node.
     */
    function transformSourceFile(node) {
        if (ts.isDeclarationFile(node)) {
            return node;
        }
        currentSourceFile = node;
        var visited = saveStateAndInvoke(node, visitSourceFile);
        ts.addEmitHelpers(visited, context.readEmitHelpers());
        currentSourceFile = undefined;
        return visited;
    }
    /**
     * Visits a node, saving and restoring state variables on the stack.
     *
     * @param node The node to visit.
     */
    function saveStateAndInvoke(node, f) {
        // Save state
        var savedCurrentScope = currentScope;
        var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
        // Handle state changes before visiting a node.
        onBeforeVisitNode(node);
        var visited = f(node);
        // Restore state
        if (currentScope !== savedCurrentScope) {
            currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
        }
        currentScope = savedCurrentScope;
        return visited;
    }
    /**
     * Performs actions that should always occur immediately before visiting a node.
     *
     * @param node The node to visit.
     */
    function onBeforeVisitNode(node) {
        switch (node.kind) {
            case 263 /* SourceFile */:
            case 234 /* CaseBlock */:
            case 233 /* ModuleBlock */:
            case 206 /* Block */:
                currentScope = node;
                currentScopeFirstDeclarationsOfName = undefined;
                break;
            case 228 /* ClassDeclaration */:
            case 227 /* FunctionDeclaration */:
                if (ts.hasModifier(node, 2 /* Ambient */)) {
                    break;
                }
                recordEmittedDeclarationInScope(node);
                break;
        }
    }
    /**
     * General-purpose node visitor.
     *
     * @param node The node to visit.
     */
    function visitor(node) {
        return saveStateAndInvoke(node, visitorWorker);
    }
    /**
     * Visits and possibly transf ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transpile" id="apidoc.element.typescript.transpile">
        function <span class="apidocSignatureSpan">typescript.</span>transpile
        <span class="apidocSignatureSpan">(input, compilerOptions, fileName, diagnostics, moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transpile(input, compilerOptions, fileName, diagnostics, moduleName) {
    var output = transpileModule(input, { compilerOptions: compilerOptions, fileName: fileName, reportDiagnostics: !!diagnostics
, moduleName: moduleName });
    // addRange correctly handles cases when wither 'from' or 'to' argument is missing
    ts.addRange(diagnostics, output.diagnostics);
    return output.outputText;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.transpileModule" id="apidoc.element.typescript.transpileModule">
        function <span class="apidocSignatureSpan">typescript.</span>transpileModule
        <span class="apidocSignatureSpan">(input, transpileOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transpileModule(input, transpileOptions) {
    var diagnostics = [];
    var options = transpileOptions.compilerOptions ? fixupCompilerOptions(transpileOptions.compilerOptions, diagnostics) : ts.getDefaultCompilerOptions
();
    options.isolatedModules = true;
    // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and
 output paths.
    options.suppressOutputPathCheck = true;
    // Filename can be non-ts file.
    options.allowNonTsExtensions = true;
    // We are not returning a sourceFile for lib file when asked by the program,
    // so pass --noLib to avoid reporting a file not found error.
    options.noLib = true;
    // Clear out other settings that would not be used in transpiling this module
    options.lib = undefined;
    options.types = undefined;
    options.noEmit = undefined;
    options.noEmitOnError = undefined;
    options.paths = undefined;
    options.rootDirs = undefined;
    options.declaration = undefined;
    options.declarationDir = undefined;
    options.out = undefined;
    options.outFile = undefined;
    // We are not doing a full typecheck, we are not resolving the whole context,
    // so pass --noResolve to avoid reporting missing file errors.
    options.noResolve = true;
    // if jsx is specified then treat file as .tsx
    var inputFileName = transpileOptions.fileName || (options.jsx ? "module.tsx" : "module.ts");
    var sourceFile = ts.createSourceFile(inputFileName, input, options.target);
    if (transpileOptions.moduleName) {
        sourceFile.moduleName = transpileOptions.moduleName;
    }
    if (transpileOptions.renamedDependencies) {
        sourceFile.renamedDependencies = ts.createMapFromTemplate(transpileOptions.renamedDependencies);
    }
    var newLine = ts.getNewLineCharacter(options);
    // Output
    var outputText;
    var sourceMapText;
    // Create a compilerHost object to allow the compiler to read and write files
    var compilerHost = {
        getSourceFile: function (fileName) { return fileName === ts.normalizePath(inputFileName) ? sourceFile : undefined; },
        writeFile: function (name, text) {
            if (ts.fileExtensionIs(name, ".map")) {
                ts.Debug.assert(sourceMapText === undefined, "Unexpected multiple source map outputs for the file '" + name + "'");
                sourceMapText = text;
            }
            else {
                ts.Debug.assert(outputText === undefined, "Unexpected multiple outputs for the file: '" + name + "'");
                outputText = text;
            }
        },
        getDefaultLibFileName: function () { return "lib.d.ts"; },
        useCaseSensitiveFileNames: function () { return false; },
        getCanonicalFileName: function (fileName) { return fileName; },
        getCurrentDirectory: function () { return ""; },
        getNewLine: function () { return newLine; },
        fileExists: function (fileName) { return fileName === inputFileName; },
        readFile: function () { return ""; },
        directoryExists: function () { return true; },
        getDirectories: function () { return []; }
    };
    var program = ts.createProgram([inputFileName], options, compilerHost);
    if (transpileOptions.reportDiagnostics) {
        ts.addRange(/*to*/ diagnostics, /*from*/ program.getSyntacticDiagnostics(sourceFile));
        ts.addRange(/*to*/ diagnostics, /*from*/ program.getOptionsDiagnostics());
    }
    // Emit
    program.emit();
    ts.Debug.assert(outputText !== undefined, "Output generation failed");
    return { outputText: outputText, diagnostics: diagnostics, sourceMapText: sourceMapText };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.tryExtractTypeScriptExtension" id="apidoc.element.typescript.tryExtractTypeScriptExtension">
        function <span class="apidocSignatureSpan">typescript.</span>tryExtractTypeScriptExtension
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryExtractTypeScriptExtension(fileName) {
    return ts.find(ts.supportedTypescriptExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName
, extension); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.tryGetClassExtendingExpressionWithTypeArguments" id="apidoc.element.typescript.tryGetClassExtendingExpressionWithTypeArguments">
        function <span class="apidocSignatureSpan">typescript.</span>tryGetClassExtendingExpressionWithTypeArguments
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryGetClassExtendingExpressionWithTypeArguments(node) {
    if (node.kind === 200 /* ExpressionWithTypeArguments */ &amp;&amp;
        node.parent.token === 84 /* ExtendsKeyword */ &amp;&amp;
        isClassLike(node.parent.parent)) {
        return node.parent.parent;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.tryGetExtensionFromPath" id="apidoc.element.typescript.tryGetExtensionFromPath">
        function <span class="apidocSignatureSpan">typescript.</span>tryGetExtensionFromPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryGetExtensionFromPath(path) {
    if (fileExtensionIs(path, ".d.ts")) {
        return ts.Extension.Dts;
    }
    if (fileExtensionIs(path, ".ts")) {
        return ts.Extension.Ts;
    }
    if (fileExtensionIs(path, ".tsx")) {
        return ts.Extension.Tsx;
    }
    if (fileExtensionIs(path, ".js")) {
        return ts.Extension.Js;
    }
    if (fileExtensionIs(path, ".jsx")) {
        return ts.Extension.Jsx;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.tryGetModuleNameFromFile" id="apidoc.element.typescript.tryGetModuleNameFromFile">
        function <span class="apidocSignatureSpan">typescript.</span>tryGetModuleNameFromFile
        <span class="apidocSignatureSpan">(file, host, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryGetModuleNameFromFile(file, host, options) {
    if (!file) {
        return undefined;
    }
    if (file.moduleName) {
        return ts.createLiteral(file.moduleName);
    }
    if (!ts.isDeclarationFile(file) &amp;&amp; (options.out || options.outFile)) {
        return ts.createLiteral(ts.getExternalModuleNameFromPath(host, file.fileName));
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.tryParsePattern" id="apidoc.element.typescript.tryParsePattern">
        function <span class="apidocSignatureSpan">typescript.</span>tryParsePattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryParsePattern(pattern) {
    // This should be verified outside of here and a proper error thrown.
    Debug.assert(hasZeroOrOneAsteriskCharacter(pattern));
    var indexOfStar = pattern.indexOf("*");
    return indexOfStar === -1 ? undefined : {
        prefix: pattern.substr(0, indexOfStar),
        suffix: pattern.substr(indexOfStar + 1)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.tryRemoveExtension" id="apidoc.element.typescript.tryRemoveExtension">
        function <span class="apidocSignatureSpan">typescript.</span>tryRemoveExtension
        <span class="apidocSignatureSpan">(path, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryRemoveExtension(path, extension) {
    return fileExtensionIs(path, extension) ? removeExtension(path, extension) : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.tryResolveScriptReference" id="apidoc.element.typescript.tryResolveScriptReference">
        function <span class="apidocSignatureSpan">typescript.</span>tryResolveScriptReference
        <span class="apidocSignatureSpan">(host, sourceFile, reference)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryResolveScriptReference(host, sourceFile, reference) {
    if (!host.getCompilerOptions().noResolve) {
        var referenceFileName = ts.isRootedDiskPath(reference.fileName) ? reference.fileName : ts.combinePaths(ts.getDirectoryPath
(sourceFile.fileName), reference.fileName);
        return host.getSourceFile(referenceFileName);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.typeDirectiveIsEqualTo" id="apidoc.element.typescript.typeDirectiveIsEqualTo">
        function <span class="apidocSignatureSpan">typescript.</span>typeDirectiveIsEqualTo
        <span class="apidocSignatureSpan">(oldResolution, newResolution)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function typeDirectiveIsEqualTo(oldResolution, newResolution) {
    return oldResolution.resolvedFileName === newResolution.resolvedFileName &amp;&amp; oldResolution.primary === newResolution.primary;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.typeToDisplayParts" id="apidoc.element.typescript.typeToDisplayParts">
        function <span class="apidocSignatureSpan">typescript.</span>typeToDisplayParts
        <span class="apidocSignatureSpan">(typechecker, type, enclosingDeclaration, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function typeToDisplayParts(typechecker, type, enclosingDeclaration, flags) {
    return mapToDisplayParts(function (writer) {
        typechecker.getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.unescapeIdentifier" id="apidoc.element.typescript.unescapeIdentifier">
        function <span class="apidocSignatureSpan">typescript.</span>unescapeIdentifier
        <span class="apidocSignatureSpan">(identifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unescapeIdentifier(identifier) {
    return identifier.length &gt;= 3 &amp;&amp; identifier.charCodeAt(0) === 95 /* _ */ &amp;&amp; identifier.charCodeAt(1) === 95 /* _ */ &amp;&amp; identifier
.charCodeAt(2) === 95 /* _ */ ? identifier.substr(1) : identifier;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.unorderedRemoveItem" id="apidoc.element.typescript.unorderedRemoveItem">
        function <span class="apidocSignatureSpan">typescript.</span>unorderedRemoveItem
        <span class="apidocSignatureSpan">(array, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unorderedRemoveItem(array, item) {
    unorderedRemoveFirstItemWhere(array, function (element) { return element === item; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.unorderedRemoveItemAt" id="apidoc.element.typescript.unorderedRemoveItemAt">
        function <span class="apidocSignatureSpan">typescript.</span>unorderedRemoveItemAt
        <span class="apidocSignatureSpan">(array, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unorderedRemoveItemAt(array, index) {
    // Fill in the "hole" left at `index`.
    array[index] = array[array.length - 1];
    array.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.unwrapInnermostStatmentOfLabel" id="apidoc.element.typescript.unwrapInnermostStatmentOfLabel">
        function <span class="apidocSignatureSpan">typescript.</span>unwrapInnermostStatmentOfLabel
        <span class="apidocSignatureSpan">(node, beforeUnwrapLabelCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unwrapInnermostStatmentOfLabel(node, beforeUnwrapLabelCallback) {
    while (true) {
        if (beforeUnwrapLabelCallback) {
            beforeUnwrapLabelCallback(node);
        }
        if (node.statement.kind !== 221 /* LabeledStatement */) {
            return node.statement;
        }
        node = node.statement;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateArrayBindingPattern" id="apidoc.element.typescript.updateArrayBindingPattern">
        function <span class="apidocSignatureSpan">typescript.</span>updateArrayBindingPattern
        <span class="apidocSignatureSpan">(node, elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateArrayBindingPattern(node, elements) {
    return node.elements !== elements
        ? updateNode(createArrayBindingPattern(elements), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateArrayLiteral" id="apidoc.element.typescript.updateArrayLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>updateArrayLiteral
        <span class="apidocSignatureSpan">(node, elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateArrayLiteral(node, elements) {
    return node.elements !== elements
        ? updateNode(createArrayLiteral(elements, node.multiLine), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateArrowFunction" id="apidoc.element.typescript.updateArrowFunction">
        function <span class="apidocSignatureSpan">typescript.</span>updateArrowFunction
        <span class="apidocSignatureSpan">(node, modifiers, typeParameters, parameters, type, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateArrowFunction(node, modifiers, typeParameters, parameters, type, body) {
    return node.modifiers !== modifiers
        || node.typeParameters !== typeParameters
        || node.parameters !== parameters
        || node.type !== type
        || node.body !== body
        ? updateNode(createArrowFunction(modifiers, typeParameters, parameters, type, node.equalsGreaterThanToken, body), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateAsExpression" id="apidoc.element.typescript.updateAsExpression">
        function <span class="apidocSignatureSpan">typescript.</span>updateAsExpression
        <span class="apidocSignatureSpan">(node, expression, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAsExpression(node, expression, type) {
    return node.expression !== expression
        || node.type !== type
        ? updateNode(createAsExpression(expression, type), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateAwait" id="apidoc.element.typescript.updateAwait">
        function <span class="apidocSignatureSpan">typescript.</span>updateAwait
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAwait(node, expression) {
    return node.expression !== expression
        ? updateNode(createAwait(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateBinary" id="apidoc.element.typescript.updateBinary">
        function <span class="apidocSignatureSpan">typescript.</span>updateBinary
        <span class="apidocSignatureSpan">(node, left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateBinary(node, left, right) {
    return node.left !== left
        || node.right !== right
        ? updateNode(createBinary(left, node.operatorToken, right), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateBindingElement" id="apidoc.element.typescript.updateBindingElement">
        function <span class="apidocSignatureSpan">typescript.</span>updateBindingElement
        <span class="apidocSignatureSpan">(node, dotDotDotToken, propertyName, name, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateBindingElement(node, dotDotDotToken, propertyName, name, initializer) {
    return node.propertyName !== propertyName
        || node.dotDotDotToken !== dotDotDotToken
        || node.name !== name
        || node.initializer !== initializer
        ? updateNode(createBindingElement(propertyName, dotDotDotToken, name, initializer), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateBlock" id="apidoc.element.typescript.updateBlock">
        function <span class="apidocSignatureSpan">typescript.</span>updateBlock
        <span class="apidocSignatureSpan">(node, statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateBlock(node, statements) {
    return statements !== node.statements
        ? updateNode(createBlock(statements, node.multiLine), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateBreak" id="apidoc.element.typescript.updateBreak">
        function <span class="apidocSignatureSpan">typescript.</span>updateBreak
        <span class="apidocSignatureSpan">(node, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateBreak(node, label) {
    return node.label !== label
        ? updateNode(createBreak(label), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateBundle" id="apidoc.element.typescript.updateBundle">
        function <span class="apidocSignatureSpan">typescript.</span>updateBundle
        <span class="apidocSignatureSpan">(node, sourceFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateBundle(node, sourceFiles) {
    if (node.sourceFiles !== sourceFiles) {
        return createBundle(sourceFiles);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateCall" id="apidoc.element.typescript.updateCall">
        function <span class="apidocSignatureSpan">typescript.</span>updateCall
        <span class="apidocSignatureSpan">(node, expression, typeArguments, argumentsArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateCall(node, expression, typeArguments, argumentsArray) {
    return expression !== node.expression
        || typeArguments !== node.typeArguments
        || argumentsArray !== node.arguments
        ? updateNode(createCall(expression, typeArguments, argumentsArray), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateCaseBlock" id="apidoc.element.typescript.updateCaseBlock">
        function <span class="apidocSignatureSpan">typescript.</span>updateCaseBlock
        <span class="apidocSignatureSpan">(node, clauses)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateCaseBlock(node, clauses) {
    return node.clauses !== clauses
        ? updateNode(createCaseBlock(clauses), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateCaseClause" id="apidoc.element.typescript.updateCaseClause">
        function <span class="apidocSignatureSpan">typescript.</span>updateCaseClause
        <span class="apidocSignatureSpan">(node, expression, statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateCaseClause(node, expression, statements) {
    if (node.expression !== expression || node.statements !== statements) {
        return updateNode(createCaseClause(expression, statements), node);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateCatchClause" id="apidoc.element.typescript.updateCatchClause">
        function <span class="apidocSignatureSpan">typescript.</span>updateCatchClause
        <span class="apidocSignatureSpan">(node, variableDeclaration, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateCatchClause(node, variableDeclaration, block) {
    if (node.variableDeclaration !== variableDeclaration || node.block !== block) {
        return updateNode(createCatchClause(variableDeclaration, block), node);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateClassDeclaration" id="apidoc.element.typescript.updateClassDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>updateClassDeclaration
        <span class="apidocSignatureSpan">(node, decorators, modifiers, name, typeParameters, heritageClauses, members)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateClassDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.name !== name
        || node.typeParameters !== typeParameters
        || node.heritageClauses !== heritageClauses
        || node.members !== members
        ? updateNode(createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateClassExpression" id="apidoc.element.typescript.updateClassExpression">
        function <span class="apidocSignatureSpan">typescript.</span>updateClassExpression
        <span class="apidocSignatureSpan">(node, modifiers, name, typeParameters, heritageClauses, members)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateClassExpression(node, modifiers, name, typeParameters, heritageClauses, members) {
    return node.modifiers !== modifiers
        || node.name !== name
        || node.typeParameters !== typeParameters
        || node.heritageClauses !== heritageClauses
        || node.members !== members
        ? updateNode(createClassExpression(modifiers, name, typeParameters, heritageClauses, members), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateComputedPropertyName" id="apidoc.element.typescript.updateComputedPropertyName">
        function <span class="apidocSignatureSpan">typescript.</span>updateComputedPropertyName
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateComputedPropertyName(node, expression) {
    return node.expression !== expression
        ? updateNode(createComputedPropertyName(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateConditional" id="apidoc.element.typescript.updateConditional">
        function <span class="apidocSignatureSpan">typescript.</span>updateConditional
        <span class="apidocSignatureSpan">(node, condition, whenTrue, whenFalse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateConditional(node, condition, whenTrue, whenFalse) {
    return node.condition !== condition
        || node.whenTrue !== whenTrue
        || node.whenFalse !== whenFalse
        ? updateNode(createConditional(condition, node.questionToken, whenTrue, node.colonToken, whenFalse), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateConstructor" id="apidoc.element.typescript.updateConstructor">
        function <span class="apidocSignatureSpan">typescript.</span>updateConstructor
        <span class="apidocSignatureSpan">(node, decorators, modifiers, parameters, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateConstructor(node, decorators, modifiers, parameters, body) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.parameters !== parameters
        || node.body !== body
        ? updateNode(createConstructor(decorators, modifiers, parameters, body), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateContinue" id="apidoc.element.typescript.updateContinue">
        function <span class="apidocSignatureSpan">typescript.</span>updateContinue
        <span class="apidocSignatureSpan">(node, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateContinue(node, label) {
    return node.label !== label
        ? updateNode(createContinue(label), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateDecorator" id="apidoc.element.typescript.updateDecorator">
        function <span class="apidocSignatureSpan">typescript.</span>updateDecorator
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateDecorator(node, expression) {
    return node.expression !== expression
        ? updateNode(createDecorator(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateDefaultClause" id="apidoc.element.typescript.updateDefaultClause">
        function <span class="apidocSignatureSpan">typescript.</span>updateDefaultClause
        <span class="apidocSignatureSpan">(node, statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateDefaultClause(node, statements) {
    if (node.statements !== statements) {
        return updateNode(createDefaultClause(statements), node);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateDelete" id="apidoc.element.typescript.updateDelete">
        function <span class="apidocSignatureSpan">typescript.</span>updateDelete
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateDelete(node, expression) {
    return node.expression !== expression
        ? updateNode(createDelete(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateDo" id="apidoc.element.typescript.updateDo">
        function <span class="apidocSignatureSpan">typescript.</span>updateDo
        <span class="apidocSignatureSpan">(node, statement, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateDo(node, statement, expression) {
    return node.statement !== statement
        || node.expression !== expression
        ? updateNode(createDo(statement, expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateElementAccess" id="apidoc.element.typescript.updateElementAccess">
        function <span class="apidocSignatureSpan">typescript.</span>updateElementAccess
        <span class="apidocSignatureSpan">(node, expression, argumentExpression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateElementAccess(node, expression, argumentExpression) {
    return node.expression !== expression
        || node.argumentExpression !== argumentExpression
        ? updateNode(createElementAccess(expression, argumentExpression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateEnumDeclaration" id="apidoc.element.typescript.updateEnumDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>updateEnumDeclaration
        <span class="apidocSignatureSpan">(node, decorators, modifiers, name, members)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateEnumDeclaration(node, decorators, modifiers, name, members) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.name !== name
        || node.members !== members
        ? updateNode(createEnumDeclaration(decorators, modifiers, name, members), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateEnumMember" id="apidoc.element.typescript.updateEnumMember">
        function <span class="apidocSignatureSpan">typescript.</span>updateEnumMember
        <span class="apidocSignatureSpan">(node, name, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateEnumMember(node, name, initializer) {
    return node.name !== name
        || node.initializer !== initializer
        ? updateNode(createEnumMember(name, initializer), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateExportAssignment" id="apidoc.element.typescript.updateExportAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>updateExportAssignment
        <span class="apidocSignatureSpan">(node, decorators, modifiers, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateExportAssignment(node, decorators, modifiers, expression) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.expression !== expression
        ? updateNode(createExportAssignment(decorators, modifiers, node.isExportEquals, expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateExportDeclaration" id="apidoc.element.typescript.updateExportDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>updateExportDeclaration
        <span class="apidocSignatureSpan">(node, decorators, modifiers, exportClause, moduleSpecifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateExportDeclaration(node, decorators, modifiers, exportClause, moduleSpecifier) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.exportClause !== exportClause
        || node.moduleSpecifier !== moduleSpecifier
        ? updateNode(createExportDeclaration(decorators, modifiers, exportClause, moduleSpecifier), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateExportSpecifier" id="apidoc.element.typescript.updateExportSpecifier">
        function <span class="apidocSignatureSpan">typescript.</span>updateExportSpecifier
        <span class="apidocSignatureSpan">(node, name, propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateExportSpecifier(node, name, propertyName) {
    return node.name !== name || node.propertyName !== propertyName
        ? updateNode(createExportSpecifier(name, propertyName), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateExpressionWithTypeArguments" id="apidoc.element.typescript.updateExpressionWithTypeArguments">
        function <span class="apidocSignatureSpan">typescript.</span>updateExpressionWithTypeArguments
        <span class="apidocSignatureSpan">(node, typeArguments, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateExpressionWithTypeArguments(node, typeArguments, expression) {
    return node.typeArguments !== typeArguments
        || node.expression !== expression
        ? updateNode(createExpressionWithTypeArguments(typeArguments, expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateExternalModuleReference" id="apidoc.element.typescript.updateExternalModuleReference">
        function <span class="apidocSignatureSpan">typescript.</span>updateExternalModuleReference
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateExternalModuleReference(node, expression) {
    return node.expression !== expression
        ? updateNode(createExternalModuleReference(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateFor" id="apidoc.element.typescript.updateFor">
        function <span class="apidocSignatureSpan">typescript.</span>updateFor
        <span class="apidocSignatureSpan">(node, initializer, condition, incrementor, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateFor(node, initializer, condition, incrementor, statement) {
    return node.initializer !== initializer
        || node.condition !== condition
        || node.incrementor !== incrementor
        || node.statement !== statement
        ? updateNode(createFor(initializer, condition, incrementor, statement), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateForIn" id="apidoc.element.typescript.updateForIn">
        function <span class="apidocSignatureSpan">typescript.</span>updateForIn
        <span class="apidocSignatureSpan">(node, initializer, expression, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateForIn(node, initializer, expression, statement) {
    return node.initializer !== initializer
        || node.expression !== expression
        || node.statement !== statement
        ? updateNode(createForIn(initializer, expression, statement), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateForOf" id="apidoc.element.typescript.updateForOf">
        function <span class="apidocSignatureSpan">typescript.</span>updateForOf
        <span class="apidocSignatureSpan">(node, initializer, expression, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateForOf(node, initializer, expression, statement) {
    return node.initializer !== initializer
        || node.expression !== expression
        || node.statement !== statement
        ? updateNode(createForOf(initializer, expression, statement), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateFunctionDeclaration" id="apidoc.element.typescript.updateFunctionDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>updateFunctionDeclaration
        <span class="apidocSignatureSpan">(node, decorators, modifiers, name, typeParameters, parameters, type, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateFunctionDeclaration(node, decorators, modifiers, name, typeParameters, parameters, type, body) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.name !== name
        || node.typeParameters !== typeParameters
        || node.parameters !== parameters
        || node.type !== type
        || node.body !== body
        ? updateNode(createFunctionDeclaration(decorators, modifiers, node.asteriskToken, name, typeParameters, parameters, type
, body), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateFunctionExpression" id="apidoc.element.typescript.updateFunctionExpression">
        function <span class="apidocSignatureSpan">typescript.</span>updateFunctionExpression
        <span class="apidocSignatureSpan">(node, modifiers, name, typeParameters, parameters, type, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateFunctionExpression(node, modifiers, name, typeParameters, parameters, type, body) {
    return node.name !== name
        || node.modifiers !== modifiers
        || node.typeParameters !== typeParameters
        || node.parameters !== parameters
        || node.type !== type
        || node.body !== body
        ? updateNode(createFunctionExpression(modifiers, node.asteriskToken, name, typeParameters, parameters, type, body), node
)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateGetAccessor" id="apidoc.element.typescript.updateGetAccessor">
        function <span class="apidocSignatureSpan">typescript.</span>updateGetAccessor
        <span class="apidocSignatureSpan">(node, decorators, modifiers, name, parameters, type, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateGetAccessor(node, decorators, modifiers, name, parameters, type, body) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.name !== name
        || node.parameters !== parameters
        || node.type !== type
        || node.body !== body
        ? updateNode(createGetAccessor(decorators, modifiers, name, parameters, type, body), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateHeritageClause" id="apidoc.element.typescript.updateHeritageClause">
        function <span class="apidocSignatureSpan">typescript.</span>updateHeritageClause
        <span class="apidocSignatureSpan">(node, types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateHeritageClause(node, types) {
    if (node.types !== types) {
        return updateNode(createHeritageClause(node.token, types), node);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateIf" id="apidoc.element.typescript.updateIf">
        function <span class="apidocSignatureSpan">typescript.</span>updateIf
        <span class="apidocSignatureSpan">(node, expression, thenStatement, elseStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateIf(node, expression, thenStatement, elseStatement) {
    return node.expression !== expression
        || node.thenStatement !== thenStatement
        || node.elseStatement !== elseStatement
        ? updateNode(createIf(expression, thenStatement, elseStatement), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateImportClause" id="apidoc.element.typescript.updateImportClause">
        function <span class="apidocSignatureSpan">typescript.</span>updateImportClause
        <span class="apidocSignatureSpan">(node, name, namedBindings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateImportClause(node, name, namedBindings) {
    return node.name !== name
        || node.namedBindings !== namedBindings
        ? updateNode(createImportClause(name, namedBindings), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateImportDeclaration" id="apidoc.element.typescript.updateImportDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>updateImportDeclaration
        <span class="apidocSignatureSpan">(node, decorators, modifiers, importClause, moduleSpecifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateImportDeclaration(node, decorators, modifiers, importClause, moduleSpecifier) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.importClause !== importClause || node.moduleSpecifier !== moduleSpecifier
        ? updateNode(createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateImportEqualsDeclaration" id="apidoc.element.typescript.updateImportEqualsDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>updateImportEqualsDeclaration
        <span class="apidocSignatureSpan">(node, decorators, modifiers, name, moduleReference)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateImportEqualsDeclaration(node, decorators, modifiers, name, moduleReference) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.name !== name
        || node.moduleReference !== moduleReference
        ? updateNode(createImportEqualsDeclaration(decorators, modifiers, name, moduleReference), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateImportSpecifier" id="apidoc.element.typescript.updateImportSpecifier">
        function <span class="apidocSignatureSpan">typescript.</span>updateImportSpecifier
        <span class="apidocSignatureSpan">(node, propertyName, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateImportSpecifier(node, propertyName, name) {
    return node.propertyName !== propertyName
        || node.name !== name
        ? updateNode(createImportSpecifier(propertyName, name), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateJsxAttribute" id="apidoc.element.typescript.updateJsxAttribute">
        function <span class="apidocSignatureSpan">typescript.</span>updateJsxAttribute
        <span class="apidocSignatureSpan">(node, name, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateJsxAttribute(node, name, initializer) {
    return node.name !== name
        || node.initializer !== initializer
        ? updateNode(createJsxAttribute(name, initializer), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateJsxClosingElement" id="apidoc.element.typescript.updateJsxClosingElement">
        function <span class="apidocSignatureSpan">typescript.</span>updateJsxClosingElement
        <span class="apidocSignatureSpan">(node, tagName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateJsxClosingElement(node, tagName) {
    return node.tagName !== tagName
        ? updateNode(createJsxClosingElement(tagName), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateJsxElement" id="apidoc.element.typescript.updateJsxElement">
        function <span class="apidocSignatureSpan">typescript.</span>updateJsxElement
        <span class="apidocSignatureSpan">(node, openingElement, children, closingElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateJsxElement(node, openingElement, children, closingElement) {
    return node.openingElement !== openingElement
        || node.children !== children
        || node.closingElement !== closingElement
        ? updateNode(createJsxElement(openingElement, children, closingElement), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateJsxExpression" id="apidoc.element.typescript.updateJsxExpression">
        function <span class="apidocSignatureSpan">typescript.</span>updateJsxExpression
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateJsxExpression(node, expression) {
    return node.expression !== expression
        ? updateNode(createJsxExpression(expression, node.dotDotDotToken), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateJsxOpeningElement" id="apidoc.element.typescript.updateJsxOpeningElement">
        function <span class="apidocSignatureSpan">typescript.</span>updateJsxOpeningElement
        <span class="apidocSignatureSpan">(node, tagName, attributes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateJsxOpeningElement(node, tagName, attributes) {
    return node.tagName !== tagName
        || node.attributes !== attributes
        ? updateNode(createJsxOpeningElement(tagName, attributes), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateJsxSelfClosingElement" id="apidoc.element.typescript.updateJsxSelfClosingElement">
        function <span class="apidocSignatureSpan">typescript.</span>updateJsxSelfClosingElement
        <span class="apidocSignatureSpan">(node, tagName, attributes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateJsxSelfClosingElement(node, tagName, attributes) {
    return node.tagName !== tagName
        || node.attributes !== attributes
        ? updateNode(createJsxSelfClosingElement(tagName, attributes), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateJsxSpreadAttribute" id="apidoc.element.typescript.updateJsxSpreadAttribute">
        function <span class="apidocSignatureSpan">typescript.</span>updateJsxSpreadAttribute
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateJsxSpreadAttribute(node, expression) {
    return node.expression !== expression
        ? updateNode(createJsxSpreadAttribute(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateLabel" id="apidoc.element.typescript.updateLabel">
        function <span class="apidocSignatureSpan">typescript.</span>updateLabel
        <span class="apidocSignatureSpan">(node, label, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateLabel(node, label, statement) {
    return node.label !== label
        || node.statement !== statement
        ? updateNode(createLabel(label, statement), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateLanguageServiceSourceFile" id="apidoc.element.typescript.updateLanguageServiceSourceFile">
        function <span class="apidocSignatureSpan">typescript.</span>updateLanguageServiceSourceFile
        <span class="apidocSignatureSpan">(sourceFile, scriptSnapshot, version, textChangeRange, aggressiveChecks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateLanguageServiceSourceFile(sourceFile, scriptSnapshot, version, textChangeRange, aggressiveChecks) {
    // If we were given a text change range, and our version or open-ness changed, then
    // incrementally parse this file.
    if (textChangeRange) {
        if (version !== sourceFile.version) {
            // Once incremental parsing is ready, then just call into this function.
            if (!ts.disableIncrementalParsing) {
                var newText = void 0;
                // grab the fragment from the beginning of the original text to the beginning of the span
                var prefix = textChangeRange.span.start !== 0
                    ? sourceFile.text.substr(0, textChangeRange.span.start)
                    : "";
                // grab the fragment from the end of the span till the end of the original text
                var suffix = ts.textSpanEnd(textChangeRange.span) !== sourceFile.text.length
                    ? sourceFile.text.substr(ts.textSpanEnd(textChangeRange.span))
                    : "";
                if (textChangeRange.newLength === 0) {
                    // edit was a deletion - just combine prefix and suffix
                    newText = prefix &amp;&amp; suffix ? prefix + suffix : prefix || suffix;
                }
                else {
                    // it was actual edit, fetch the fragment of new text that correspond to new span
                    var changedText = scriptSnapshot.getText(textChangeRange.span.start, textChangeRange.span.start + textChangeRange
.newLength);
                    // combine prefix, changed text and suffix
                    newText = prefix &amp;&amp; suffix
                        ? prefix + changedText + suffix
                        : prefix
                            ? (prefix + changedText)
                            : (changedText + suffix);
                }
                var newSourceFile = ts.updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks);
                setSourceFileFields(newSourceFile, scriptSnapshot, version);
                // after incremental parsing nameTable might not be up-to-date
                // drop it so it can be lazily recreated later
                newSourceFile.nameTable = undefined;
                // dispose all resources held by old script snapshot
                if (sourceFile !== newSourceFile &amp;&amp; sourceFile.scriptSnapshot) {
                    if (sourceFile.scriptSnapshot.dispose) {
                        sourceFile.scriptSnapshot.dispose();
                    }
                    sourceFile.scriptSnapshot = undefined;
                }
                return newSourceFile;
            }
        }
    }
    // Otherwise, just create a new source file.
    return createLanguageServiceSourceFile(sourceFile.fileName, scriptSnapshot, sourceFile.languageVersion, version, /*setNodeParents
*/ true, sourceFile.scriptKind);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateMethod" id="apidoc.element.typescript.updateMethod">
        function <span class="apidocSignatureSpan">typescript.</span>updateMethod
        <span class="apidocSignatureSpan">(node, decorators, modifiers, name, typeParameters, parameters, type, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateMethod(node, decorators, modifiers, name, typeParameters, parameters, type, body) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.name !== name
        || node.typeParameters !== typeParameters
        || node.parameters !== parameters
        || node.type !== type
        || node.body !== body
        ? updateNode(createMethod(decorators, modifiers, node.asteriskToken, name, typeParameters, parameters, type, body), node
)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateModuleBlock" id="apidoc.element.typescript.updateModuleBlock">
        function <span class="apidocSignatureSpan">typescript.</span>updateModuleBlock
        <span class="apidocSignatureSpan">(node, statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateModuleBlock(node, statements) {
    return node.statements !== statements
        ? updateNode(createModuleBlock(statements), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateModuleDeclaration" id="apidoc.element.typescript.updateModuleDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>updateModuleDeclaration
        <span class="apidocSignatureSpan">(node, decorators, modifiers, name, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateModuleDeclaration(node, decorators, modifiers, name, body) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.name !== name
        || node.body !== body
        ? updateNode(createModuleDeclaration(decorators, modifiers, name, body, node.flags), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateNamedExports" id="apidoc.element.typescript.updateNamedExports">
        function <span class="apidocSignatureSpan">typescript.</span>updateNamedExports
        <span class="apidocSignatureSpan">(node, elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateNamedExports(node, elements) {
    return node.elements !== elements
        ? updateNode(createNamedExports(elements), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateNamedImports" id="apidoc.element.typescript.updateNamedImports">
        function <span class="apidocSignatureSpan">typescript.</span>updateNamedImports
        <span class="apidocSignatureSpan">(node, elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateNamedImports(node, elements) {
    return node.elements !== elements
        ? updateNode(createNamedImports(elements), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateNamespaceImport" id="apidoc.element.typescript.updateNamespaceImport">
        function <span class="apidocSignatureSpan">typescript.</span>updateNamespaceImport
        <span class="apidocSignatureSpan">(node, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateNamespaceImport(node, name) {
    return node.name !== name
        ? updateNode(createNamespaceImport(name), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateNew" id="apidoc.element.typescript.updateNew">
        function <span class="apidocSignatureSpan">typescript.</span>updateNew
        <span class="apidocSignatureSpan">(node, expression, typeArguments, argumentsArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateNew(node, expression, typeArguments, argumentsArray) {
    return node.expression !== expression
        || node.typeArguments !== typeArguments
        || node.arguments !== argumentsArray
        ? updateNode(createNew(expression, typeArguments, argumentsArray), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateNode" id="apidoc.element.typescript.updateNode">
        function <span class="apidocSignatureSpan">typescript.</span>updateNode
        <span class="apidocSignatureSpan">(updated, original)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateNode(updated, original) {
    if (updated !== original) {
        setOriginalNode(updated, original);
        setTextRange(updated, original);
        if (original.startsOnNewLine) {
            updated.startsOnNewLine = true;
        }
        ts.aggregateTransformFlags(updated);
    }
    return updated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateNonNullExpression" id="apidoc.element.typescript.updateNonNullExpression">
        function <span class="apidocSignatureSpan">typescript.</span>updateNonNullExpression
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateNonNullExpression(node, expression) {
    return node.expression !== expression
        ? updateNode(createNonNullExpression(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateObjectBindingPattern" id="apidoc.element.typescript.updateObjectBindingPattern">
        function <span class="apidocSignatureSpan">typescript.</span>updateObjectBindingPattern
        <span class="apidocSignatureSpan">(node, elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateObjectBindingPattern(node, elements) {
    return node.elements !== elements
        ? updateNode(createObjectBindingPattern(elements), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateObjectLiteral" id="apidoc.element.typescript.updateObjectLiteral">
        function <span class="apidocSignatureSpan">typescript.</span>updateObjectLiteral
        <span class="apidocSignatureSpan">(node, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateObjectLiteral(node, properties) {
    return node.properties !== properties
        ? updateNode(createObjectLiteral(properties, node.multiLine), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateParameter" id="apidoc.element.typescript.updateParameter">
        function <span class="apidocSignatureSpan">typescript.</span>updateParameter
        <span class="apidocSignatureSpan">(node, decorators, modifiers, dotDotDotToken, name, type, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateParameter(node, decorators, modifiers, dotDotDotToken, name, type, initializer) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.dotDotDotToken !== dotDotDotToken
        || node.name !== name
        || node.type !== type
        || node.initializer !== initializer
        ? updateNode(createParameter(decorators, modifiers, dotDotDotToken, name, node.questionToken, type, initializer), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateParen" id="apidoc.element.typescript.updateParen">
        function <span class="apidocSignatureSpan">typescript.</span>updateParen
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateParen(node, expression) {
    return node.expression !== expression
        ? updateNode(createParen(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updatePartiallyEmittedExpression" id="apidoc.element.typescript.updatePartiallyEmittedExpression">
        function <span class="apidocSignatureSpan">typescript.</span>updatePartiallyEmittedExpression
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updatePartiallyEmittedExpression(node, expression) {
    if (node.expression !== expression) {
        return updateNode(createPartiallyEmittedExpression(expression, node.original), node);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updatePostfix" id="apidoc.element.typescript.updatePostfix">
        function <span class="apidocSignatureSpan">typescript.</span>updatePostfix
        <span class="apidocSignatureSpan">(node, operand)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updatePostfix(node, operand) {
    return node.operand !== operand
        ? updateNode(createPostfix(operand, node.operator), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updatePrefix" id="apidoc.element.typescript.updatePrefix">
        function <span class="apidocSignatureSpan">typescript.</span>updatePrefix
        <span class="apidocSignatureSpan">(node, operand)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updatePrefix(node, operand) {
    return node.operand !== operand
        ? updateNode(createPrefix(node.operator, operand), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateProperty" id="apidoc.element.typescript.updateProperty">
        function <span class="apidocSignatureSpan">typescript.</span>updateProperty
        <span class="apidocSignatureSpan">(node, decorators, modifiers, name, type, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateProperty(node, decorators, modifiers, name, type, initializer) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.name !== name
        || node.type !== type
        || node.initializer !== initializer
        ? updateNode(createProperty(decorators, modifiers, name, node.questionToken, type, initializer), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updatePropertyAccess" id="apidoc.element.typescript.updatePropertyAccess">
        function <span class="apidocSignatureSpan">typescript.</span>updatePropertyAccess
        <span class="apidocSignatureSpan">(node, expression, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updatePropertyAccess(node, expression, name) {
    // Because we are updating existed propertyAccess we want to inherit its emitFlags
    // instead of using the default from createPropertyAccess
    return node.expression !== expression
        || node.name !== name
        ? updateNode(setEmitFlags(createPropertyAccess(expression, name), getEmitFlags(node)), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updatePropertyAssignment" id="apidoc.element.typescript.updatePropertyAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>updatePropertyAssignment
        <span class="apidocSignatureSpan">(node, name, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updatePropertyAssignment(node, name, initializer) {
    if (node.name !== name || node.initializer !== initializer) {
        return updateNode(createPropertyAssignment(name, initializer), node);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateQualifiedName" id="apidoc.element.typescript.updateQualifiedName">
        function <span class="apidocSignatureSpan">typescript.</span>updateQualifiedName
        <span class="apidocSignatureSpan">(node, left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateQualifiedName(node, left, right) {
    return node.left !== left
        || node.right !== right
        ? updateNode(createQualifiedName(left, right), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateReturn" id="apidoc.element.typescript.updateReturn">
        function <span class="apidocSignatureSpan">typescript.</span>updateReturn
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateReturn(node, expression) {
    return node.expression !== expression
        ? updateNode(createReturn(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateSetAccessor" id="apidoc.element.typescript.updateSetAccessor">
        function <span class="apidocSignatureSpan">typescript.</span>updateSetAccessor
        <span class="apidocSignatureSpan">(node, decorators, modifiers, name, parameters, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateSetAccessor(node, decorators, modifiers, name, parameters, body) {
    return node.decorators !== decorators
        || node.modifiers !== modifiers
        || node.name !== name
        || node.parameters !== parameters
        || node.body !== body
        ? updateNode(createSetAccessor(decorators, modifiers, name, parameters, body), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateShorthandPropertyAssignment" id="apidoc.element.typescript.updateShorthandPropertyAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>updateShorthandPropertyAssignment
        <span class="apidocSignatureSpan">(node, name, objectAssignmentInitializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateShorthandPropertyAssignment(node, name, objectAssignmentInitializer) {
    if (node.name !== name || node.objectAssignmentInitializer !== objectAssignmentInitializer) {
        return updateNode(createShorthandPropertyAssignment(name, objectAssignmentInitializer), node);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateSourceFile" id="apidoc.element.typescript.updateSourceFile">
        function <span class="apidocSignatureSpan">typescript.</span>updateSourceFile
        <span class="apidocSignatureSpan">(sourceFile, newText, textChangeRange, aggressiveChecks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks) {
    return IncrementalParser.updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateSourceFileNode" id="apidoc.element.typescript.updateSourceFileNode">
        function <span class="apidocSignatureSpan">typescript.</span>updateSourceFileNode
        <span class="apidocSignatureSpan">(node, statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateSourceFileNode(node, statements) {
    if (node.statements !== statements) {
        var updated = createSynthesizedNode(263 /* SourceFile */);
        updated.flags |= node.flags;
        updated.statements = createNodeArray(statements);
        updated.endOfFileToken = node.endOfFileToken;
        updated.fileName = node.fileName;
        updated.path = node.path;
        updated.text = node.text;
        if (node.amdDependencies !== undefined)
            updated.amdDependencies = node.amdDependencies;
        if (node.moduleName !== undefined)
            updated.moduleName = node.moduleName;
        if (node.referencedFiles !== undefined)
            updated.referencedFiles = node.referencedFiles;
        if (node.typeReferenceDirectives !== undefined)
            updated.typeReferenceDirectives = node.typeReferenceDirectives;
        if (node.languageVariant !== undefined)
            updated.languageVariant = node.languageVariant;
        if (node.isDeclarationFile !== undefined)
            updated.isDeclarationFile = node.isDeclarationFile;
        if (node.renamedDependencies !== undefined)
            updated.renamedDependencies = node.renamedDependencies;
        if (node.hasNoDefaultLib !== undefined)
            updated.hasNoDefaultLib = node.hasNoDefaultLib;
        if (node.languageVersion !== undefined)
            updated.languageVersion = node.languageVersion;
        if (node.scriptKind !== undefined)
            updated.scriptKind = node.scriptKind;
        if (node.externalModuleIndicator !== undefined)
            updated.externalModuleIndicator = node.externalModuleIndicator;
        if (node.commonJsModuleIndicator !== undefined)
            updated.commonJsModuleIndicator = node.commonJsModuleIndicator;
        if (node.identifiers !== undefined)
            updated.identifiers = node.identifiers;
        if (node.nodeCount !== undefined)
            updated.nodeCount = node.nodeCount;
        if (node.identifierCount !== undefined)
            updated.identifierCount = node.identifierCount;
        if (node.symbolCount !== undefined)
            updated.symbolCount = node.symbolCount;
        if (node.parseDiagnostics !== undefined)
            updated.parseDiagnostics = node.parseDiagnostics;
        if (node.bindDiagnostics !== undefined)
            updated.bindDiagnostics = node.bindDiagnostics;
        if (node.lineMap !== undefined)
            updated.lineMap = node.lineMap;
        if (node.classifiableNames !== undefined)
            updated.classifiableNames = node.classifiableNames;
        if (node.resolvedModules !== undefined)
            updated.resolvedModules = node.resolvedModules;
        if (node.resolvedTypeReferenceDirectiveNames !== undefined)
            updated.resolvedTypeReferenceDirectiveNames = node.resolvedTypeReferenceDirectiveNames;
        if (node.imports !== undefined)
            updated.imports = node.imports;
        if (node.moduleAugmentations !== undefined)
            updated.moduleAugmentations = node.moduleAugmentations;
        return updateNode(updated, node);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateSpread" id="apidoc.element.typescript.updateSpread">
        function <span class="apidocSignatureSpan">typescript.</span>updateSpread
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateSpread(node, expression) {
    return node.expression !== expression
        ? updateNode(createSpread(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateSpreadAssignment" id="apidoc.element.typescript.updateSpreadAssignment">
        function <span class="apidocSignatureSpan">typescript.</span>updateSpreadAssignment
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateSpreadAssignment(node, expression) {
    if (node.expression !== expression) {
        return updateNode(createSpreadAssignment(expression), node);
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateStatement" id="apidoc.element.typescript.updateStatement">
        function <span class="apidocSignatureSpan">typescript.</span>updateStatement
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateStatement(node, expression) {
    return node.expression !== expression
        ? updateNode(createStatement(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateSwitch" id="apidoc.element.typescript.updateSwitch">
        function <span class="apidocSignatureSpan">typescript.</span>updateSwitch
        <span class="apidocSignatureSpan">(node, expression, caseBlock)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateSwitch(node, expression, caseBlock) {
    return node.expression !== expression
        || node.caseBlock !== caseBlock
        ? updateNode(createSwitch(expression, caseBlock), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateTaggedTemplate" id="apidoc.element.typescript.updateTaggedTemplate">
        function <span class="apidocSignatureSpan">typescript.</span>updateTaggedTemplate
        <span class="apidocSignatureSpan">(node, tag, template)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateTaggedTemplate(node, tag, template) {
    return node.tag !== tag
        || node.template !== template
        ? updateNode(createTaggedTemplate(tag, template), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateTemplateExpression" id="apidoc.element.typescript.updateTemplateExpression">
        function <span class="apidocSignatureSpan">typescript.</span>updateTemplateExpression
        <span class="apidocSignatureSpan">(node, head, templateSpans)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateTemplateExpression(node, head, templateSpans) {
    return node.head !== head
        || node.templateSpans !== templateSpans
        ? updateNode(createTemplateExpression(head, templateSpans), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateTemplateSpan" id="apidoc.element.typescript.updateTemplateSpan">
        function <span class="apidocSignatureSpan">typescript.</span>updateTemplateSpan
        <span class="apidocSignatureSpan">(node, expression, literal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateTemplateSpan(node, expression, literal) {
    return node.expression !== expression
        || node.literal !== literal
        ? updateNode(createTemplateSpan(expression, literal), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateThrow" id="apidoc.element.typescript.updateThrow">
        function <span class="apidocSignatureSpan">typescript.</span>updateThrow
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateThrow(node, expression) {
    return node.expression !== expression
        ? updateNode(createThrow(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateTry" id="apidoc.element.typescript.updateTry">
        function <span class="apidocSignatureSpan">typescript.</span>updateTry
        <span class="apidocSignatureSpan">(node, tryBlock, catchClause, finallyBlock)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateTry(node, tryBlock, catchClause, finallyBlock) {
    return node.tryBlock !== tryBlock
        || node.catchClause !== catchClause
        || node.finallyBlock !== finallyBlock
        ? updateNode(createTry(tryBlock, catchClause, finallyBlock), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateTypeAssertion" id="apidoc.element.typescript.updateTypeAssertion">
        function <span class="apidocSignatureSpan">typescript.</span>updateTypeAssertion
        <span class="apidocSignatureSpan">(node, type, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateTypeAssertion(node, type, expression) {
    return node.type !== type
        || node.expression !== expression
        ? updateNode(createTypeAssertion(type, expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateTypeOf" id="apidoc.element.typescript.updateTypeOf">
        function <span class="apidocSignatureSpan">typescript.</span>updateTypeOf
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateTypeOf(node, expression) {
    return node.expression !== expression
        ? updateNode(createTypeOf(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateVariableDeclaration" id="apidoc.element.typescript.updateVariableDeclaration">
        function <span class="apidocSignatureSpan">typescript.</span>updateVariableDeclaration
        <span class="apidocSignatureSpan">(node, name, type, initializer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateVariableDeclaration(node, name, type, initializer) {
    return node.name !== name
        || node.type !== type
        || node.initializer !== initializer
        ? updateNode(createVariableDeclaration(name, type, initializer), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateVariableDeclarationList" id="apidoc.element.typescript.updateVariableDeclarationList">
        function <span class="apidocSignatureSpan">typescript.</span>updateVariableDeclarationList
        <span class="apidocSignatureSpan">(node, declarations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateVariableDeclarationList(node, declarations) {
    return node.declarations !== declarations
        ? updateNode(createVariableDeclarationList(declarations, node.flags), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateVariableStatement" id="apidoc.element.typescript.updateVariableStatement">
        function <span class="apidocSignatureSpan">typescript.</span>updateVariableStatement
        <span class="apidocSignatureSpan">(node, modifiers, declarationList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateVariableStatement(node, modifiers, declarationList) {
    return node.modifiers !== modifiers
        || node.declarationList !== declarationList
        ? updateNode(createVariableStatement(modifiers, declarationList), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateVoid" id="apidoc.element.typescript.updateVoid">
        function <span class="apidocSignatureSpan">typescript.</span>updateVoid
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateVoid(node, expression) {
    return node.expression !== expression
        ? updateNode(createVoid(expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateWhile" id="apidoc.element.typescript.updateWhile">
        function <span class="apidocSignatureSpan">typescript.</span>updateWhile
        <span class="apidocSignatureSpan">(node, expression, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateWhile(node, expression, statement) {
    return node.expression !== expression
        || node.statement !== statement
        ? updateNode(createWhile(expression, statement), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateWith" id="apidoc.element.typescript.updateWith">
        function <span class="apidocSignatureSpan">typescript.</span>updateWith
        <span class="apidocSignatureSpan">(node, expression, statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateWith(node, expression, statement) {
    return node.expression !== expression
        || node.statement !== statement
        ? updateNode(createWith(expression, statement), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.updateYield" id="apidoc.element.typescript.updateYield">
        function <span class="apidocSignatureSpan">typescript.</span>updateYield
        <span class="apidocSignatureSpan">(node, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateYield(node, expression) {
    return node.expression !== expression
        ? updateNode(createYield(node.asteriskToken, expression), node)
        : node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.validateLocaleAndSetLanguage" id="apidoc.element.typescript.validateLocaleAndSetLanguage">
        function <span class="apidocSignatureSpan">typescript.</span>validateLocaleAndSetLanguage
        <span class="apidocSignatureSpan">(locale, sys, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateLocaleAndSetLanguage(locale, sys, errors) {
    var matchResult = /^([a-z]+)([_\-]([a-z]+))?$/.exec(locale.toLowerCase());
    if (!matchResult) {
        if (errors) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1
, "en", "ja-jp"));
        }
        return;
    }
    var language = matchResult[1];
    var territory = matchResult[3];
    // First try the entire locale, then fall back to just language if that's all we have.
    // Either ways do not fail, and fallback to the English diagnostic strings.
    if (!trySetLanguageAndTerritory(language, territory, errors)) {
        trySetLanguageAndTerritory(language, /*territory*/ undefined, errors);
    }
    function trySetLanguageAndTerritory(language, territory, errors) {
        var compilerFilePath = ts.normalizePath(sys.getExecutingFilePath());
        var containingDirectoryPath = ts.getDirectoryPath(compilerFilePath);
        var filePath = ts.combinePaths(containingDirectoryPath, language);
        if (territory) {
            filePath = filePath + "-" + territory;
        }
        filePath = sys.resolvePath(ts.combinePaths(filePath, "diagnosticMessages.generated.json"));
        if (!sys.fileExists(filePath)) {
            return false;
        }
        // TODO: Add codePage support for readFile?
        var fileContents = "";
        try {
            fileContents = sys.readFile(filePath);
        }
        catch (e) {
            if (errors) {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unable_to_open_file_0, filePath));
            }
            return false;
        }
        try {
            ts.localizedDiagnosticMessages = JSON.parse(fileContents);
        }
        catch (e) {
            if (errors) {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Corrupted_locale_file_0, filePath));
            }
            return false;
        }
        return true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.visitEachChild" id="apidoc.element.typescript.visitEachChild">
        function <span class="apidocSignatureSpan">typescript.</span>visitEachChild
        <span class="apidocSignatureSpan">(node, visitor, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visitEachChild(node, visitor, context) {
    if (node === undefined) {
        return undefined;
    }
    var kind = node.kind;
    // No need to visit nodes with no children.
    if ((kind &gt; 0 /* FirstToken */ &amp;&amp; kind &lt;= 141 /* LastToken */)) {
        return node;
    }
    // We do not yet support types.
    if ((kind &gt;= 157 /* TypePredicate */ &amp;&amp; kind &lt;= 172 /* LiteralType */)) {
        return node;
    }
    switch (node.kind) {
        case 205 /* SemicolonClassElement */:
        case 208 /* EmptyStatement */:
        case 199 /* OmittedExpression */:
        case 224 /* DebuggerStatement */:
            // No need to visit nodes with no children.
            return node;
        // Names
        case 142 /* QualifiedName */:
            return ts.updateQualifiedName(node, visitNode(node.left, visitor, ts.isEntityName), visitNode(node.right, visitor, ts
.isIdentifier));
        case 143 /* ComputedPropertyName */:
            return ts.updateComputedPropertyName(node, visitNode(node.expression, visitor, ts.isExpression));
        // Signature elements
        case 145 /* Parameter */:
            return ts.updateParameter(node, visitNodes(node.decorators, visitor, ts.isDecorator), visitNodes(node.modifiers, visitor
, ts.isModifier), node.dotDotDotToken, visitNode(node.name, visitor, ts.isBindingName), visitNode(node.type, visitor, ts.isTypeNode
, /*optional*/ true), visitNode(node.initializer, visitor, ts.isExpression, /*optional*/ true));
        case 146 /* Decorator */:
            return ts.updateDecorator(node, visitNode(node.expression, visitor, ts.isExpression));
        // Type member
        case 148 /* PropertyDeclaration */:
            return ts.updateProperty(node, visitNodes(node.decorators, visitor, ts.isDecorator), visitNodes(node.modifiers, visitor
, ts.isModifier), visitNode(node.name, visitor, ts.isPropertyName), visitNode(node.type, visitor, ts.isTypeNode, /*optional*/ true
), visitNode(node.initializer, visitor, ts.isExpression, /*optional*/ true));
        case 150 /* MethodDeclaration */:
            return ts.updateMethod(node, visitNodes(node.decorators, visitor, ts.isDecorator), visitNodes(node.modifiers, visitor
, ts.isModifier), visitNode(node.name, visitor, ts.isPropertyName), visitNodes(node.typeParameters, visitor, ts.isTypeParameter),
visitParameterList(node.parameters, visitor, context), visitNode(node.type, visitor, ts.isTypeNode, /*optional*/ true), visitFunctionBody
(node.body, visitor, context));
        case 151 /* Constructor */:
            return ts.updateConstructor(node, visitNodes(node.decorators, visitor, ts.isDecorator), visitNodes(node.modifiers, visitor
, ts.isModifier), visitParameterList(node.parameters, visitor, context), visitFunctionBody(node.body, visitor, context));
        case 152 /* GetAccessor */:
            return ts.updateGetAccessor(node, visitNodes(node.decorators, visitor, ts.isDecorator), visitNodes(node.modifiers, visitor
, ts.isModifier), visitNode(node.name, visitor, ts.isPropertyName), visitParameterList(node.parameters, visitor, context), visitNode
(node.type, visitor, ts.isTypeNode, /*optional*/ true), visitFunctionBody(node.body, visitor, context));
        case 153 /* SetAccessor */:
            return ts.updateSetAccessor(node, visitNodes(node.decorators, visitor, ts.isDecorator), visitNodes(node.modifiers, visitor
, ts.isModifier), visitNode(node.name, visitor, ts.isPropertyName), visitParameterList(node.parameters, visitor, context), visitFunctionBody
(node.body, visitor, context));
        // Binding patterns
        case 173 /* ObjectBindingPattern */:
            return ts.updateObjectBindingPattern(node, visitNodes(node.elements, visitor, ts.isBindingElement));
        case 174 /* ArrayBindingPattern */:
            return ts.updateArrayBindingPattern(node, visitNodes(node.elements, visitor, ts.isArrayBindingElement));
        case 175 /* BindingElement */:
            return ts.updateBindingElement(node, node.dotDotDotToken, visitNode(node.propertyName, visitor, ts.isPropertyName, /*
optional*/ true), visitNode(node.name, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.visitFunctionBody" id="apidoc.element.typescript.visitFunctionBody">
        function <span class="apidocSignatureSpan">typescript.</span>visitFunctionBody
        <span class="apidocSignatureSpan">(node, visitor, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visitFunctionBody(node, visitor, context) {
    context.resumeLexicalEnvironment();
    var updated = visitNode(node, visitor, ts.isConciseBody);
    var declarations = context.endLexicalEnvironment();
    if (ts.some(declarations)) {
        var block = ts.convertToFunctionBody(updated);
        var statements = mergeLexicalEnvironment(block.statements, declarations);
        return ts.updateBlock(block, statements);
    }
    return updated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.visitLexicalEnvironment" id="apidoc.element.typescript.visitLexicalEnvironment">
        function <span class="apidocSignatureSpan">typescript.</span>visitLexicalEnvironment
        <span class="apidocSignatureSpan">(statements, visitor, context, start, ensureUseStrict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visitLexicalEnvironment(statements, visitor, context, start, ensureUseStrict) {
    context.startLexicalEnvironment();
    statements = visitNodes(statements, visitor, ts.isStatement, start);
    if (ensureUseStrict &amp;&amp; !ts.startsWithUseStrict(statements)) {
        statements = ts.setTextRange(ts.createNodeArray([ts.createStatement(ts.createLiteral("use strict"))].concat(statements)),
statements);
    }
    var declarations = context.endLexicalEnvironment();
    return ts.setTextRange(ts.createNodeArray(ts.concatenate(statements, declarations)), statements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.visitNode" id="apidoc.element.typescript.visitNode">
        function <span class="apidocSignatureSpan">typescript.</span>visitNode
        <span class="apidocSignatureSpan">(node, visitor, test, optional, lift)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visitNode(node, visitor, test, optional, lift) {
    if (node === undefined || visitor === undefined) {
        return node;
    }
    aggregateTransformFlags(node);
    var visited = visitor(node);
    if (visited === node) {
        return node;
    }
    var visitedNode;
    if (visited === undefined) {
        if (!optional) {
            Debug.failNotOptional();
        }
        return undefined;
    }
    else if (ts.isArray(visited)) {
        visitedNode = (lift || extractSingleNode)(visited);
    }
    else {
        visitedNode = visited;
    }
    Debug.assertNode(visitedNode, test);
    aggregateTransformFlags(visitedNode);
    return visitedNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.visitNodes" id="apidoc.element.typescript.visitNodes">
        function <span class="apidocSignatureSpan">typescript.</span>visitNodes
        <span class="apidocSignatureSpan">(nodes, visitor, test, start, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visitNodes(nodes, visitor, test, start, count) {
    if (nodes === undefined) {
        return undefined;
    }
    var updated;
    // Ensure start and count have valid values
    var length = nodes.length;
    if (start === undefined || start &lt; 0) {
        start = 0;
    }
    if (count === undefined || count &gt; length - start) {
        count = length - start;
    }
    if (start &gt; 0 || count &lt; length) {
        // If we are not visiting all of the original nodes, we must always create a new array.
        // Since this is a fragment of a node array, we do not copy over the previous location
        // and will only copy over `hasTrailingComma` if we are including the last element.
        updated = ts.createNodeArray([], /*hasTrailingComma*/ nodes.hasTrailingComma &amp;&amp; start + count === length);
    }
    // Visit each original node.
    for (var i = 0; i &lt; count; i++) {
        var node = nodes[i + start];
        aggregateTransformFlags(node);
        var visited = node !== undefined ? visitor(node) : undefined;
        if (updated !== undefined || visited === undefined || visited !== node) {
            if (updated === undefined) {
                // Ensure we have a copy of `nodes`, up to the current index.
                updated = ts.createNodeArray(nodes.slice(0, i), nodes.hasTrailingComma);
                ts.setTextRange(updated, nodes);
            }
            if (visited) {
                if (ts.isArray(visited)) {
                    for (var _i = 0, visited_1 = visited; _i &lt; visited_1.length; _i++) {
                        var visitedNode = visited_1[_i];
                        Debug.assertNode(visitedNode, test);
                        aggregateTransformFlags(visitedNode);
                        updated.push(visitedNode);
                    }
                }
                else {
                    Debug.assertNode(visited, test);
                    aggregateTransformFlags(visited);
                    updated.push(visited);
                }
            }
        }
    }
    return updated || nodes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.visitParameterList" id="apidoc.element.typescript.visitParameterList">
        function <span class="apidocSignatureSpan">typescript.</span>visitParameterList
        <span class="apidocSignatureSpan">(nodes, visitor, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visitParameterList(nodes, visitor, context) {
    context.startLexicalEnvironment();
    var updated = visitNodes(nodes, visitor, ts.isParameterDeclaration);
    context.suspendLexicalEnvironment();
    return updated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.writeCommentRange" id="apidoc.element.typescript.writeCommentRange">
        function <span class="apidocSignatureSpan">typescript.</span>writeCommentRange
        <span class="apidocSignatureSpan">(text, lineMap, writer, commentPos, commentEnd, newLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeCommentRange(text, lineMap, writer, commentPos, commentEnd, newLine) {
    if (text.charCodeAt(commentPos + 1) === 42 /* asterisk */) {
        var firstCommentLineAndCharacter = ts.computeLineAndCharacterOfPosition(lineMap, commentPos);
        var lineCount = lineMap.length;
        var firstCommentLineIndent = void 0;
        for (var pos = commentPos, currentLine = firstCommentLineAndCharacter.line; pos &lt; commentEnd; currentLine++) {
            var nextLineStart = (currentLine + 1) === lineCount
                ? text.length + 1
                : lineMap[currentLine + 1];
            if (pos !== commentPos) {
                // If we are not emitting first line, we need to write the spaces to adjust the alignment
                if (firstCommentLineIndent === undefined) {
                    firstCommentLineIndent = calculateIndent(text, lineMap[firstCommentLineAndCharacter.line], commentPos);
                }
                // These are number of spaces writer is going to write at current indent
                var currentWriterIndentSpacing = writer.getIndent() * getIndentSize();
                // Number of spaces we want to be writing
                // eg: Assume writer indent
                // module m {
                //         /* starts at character 9 this is line 1
                //    * starts at character pos 4 line                        --1  = 8 - 8 + 3
                //   More left indented comment */                            --2  = 8 - 8 + 2
                //     class c { }
                // }
                // module m {
                //     /* this is line 1 -- Assume current writer indent 8
                //      * line                                                --3 = 8 - 4 + 5
                //            More right indented comment */                  --4 = 8 - 4 + 11
                //     class c { }
                // }
                var spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(text, pos, nextLineStart
);
                if (spacesToEmit &gt; 0) {
                    var numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();
                    var indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());
                    // Write indent size string ( in eg 1: = "", 2: "" , 3: string with 8 spaces 4: string with 12 spaces
                    writer.rawWrite(indentSizeSpaceString);
                    // Emit the single spaces (in eg: 1: 3 spaces, 2: 2 spaces, 3: 1 space, 4: 3 spaces)
                    while (numberOfSingleSpacesToEmit) {
                        writer.rawWrite(" ");
                        numberOfSingleSpacesToEmit--;
                    }
                }
                else {
                    // No spaces to emit write empty string
                    writer.rawWrite("");
                }
            }
            // Write the comment line text
            writeTrimmedCurrentLine(text, commentEnd, writer, newLine, pos, nextLineStart);
            pos = nextLineStart;
        }
    }
    else {
        // Single line comment of style //....
        writer.write(text.substring(commentPos, commentEnd));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.writeDeclarationFile" id="apidoc.element.typescript.writeDeclarationFile">
        function <span class="apidocSignatureSpan">typescript.</span>writeDeclarationFile
        <span class="apidocSignatureSpan">(declarationFilePath, sourceFileOrBundle, host, resolver, emitterDiagnostics, emitOnlyDtsFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeDeclarationFile(declarationFilePath, sourceFileOrBundle, host, resolver, emitterDiagnostics, emitOnlyDtsFiles) {
    var emitDeclarationResult = emitDeclarations(host, resolver, emitterDiagnostics, declarationFilePath, sourceFileOrBundle, emitOnlyDtsFiles
);
    var emitSkipped = emitDeclarationResult.reportedDeclarationError || host.isEmitBlocked(declarationFilePath) || host.getCompilerOptions
().noEmit;
    if (!emitSkipped) {
        var sourceFiles = sourceFileOrBundle.kind === 264 /* Bundle */ ? sourceFileOrBundle.sourceFiles : [sourceFileOrBundle];
        var declarationOutput = emitDeclarationResult.referencesOutput
            + getDeclarationOutput(emitDeclarationResult.synchronousDeclarationOutput, emitDeclarationResult.moduleElementDeclarationEmitInfo
);
        ts.writeFile(host, emitterDiagnostics, declarationFilePath, declarationOutput, host.getCompilerOptions().emitBOM, sourceFiles
);
    }
    return emitSkipped;
    function getDeclarationOutput(synchronousDeclarationOutput, moduleElementDeclarationEmitInfo) {
        var appliedSyncOutputPos = 0;
        var declarationOutput = "";
        // apply asynchronous additions to the synchronous output
        ts.forEach(moduleElementDeclarationEmitInfo, function (aliasEmitInfo) {
            if (aliasEmitInfo.asynchronousOutput) {
                declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos, aliasEmitInfo.outputPos);
                declarationOutput += getDeclarationOutput(aliasEmitInfo.asynchronousOutput, aliasEmitInfo.subModuleElementDeclarationEmitInfo
);
                appliedSyncOutputPos = aliasEmitInfo.outputPos;
            }
        });
        declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos);
        return declarationOutput;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.writeFile" id="apidoc.element.typescript.writeFile">
        function <span class="apidocSignatureSpan">typescript.</span>writeFile
        <span class="apidocSignatureSpan">(host, diagnostics, fileName, data, writeByteOrderMark, sourceFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFile(host, diagnostics, fileName, data, writeByteOrderMark, sourceFiles) {
    host.writeFile(fileName, data, writeByteOrderMark, function (hostErrorMessage) {
        diagnostics.add(ts.createCompilerDiagnostic(ts.Diagnostics.Could_not_write_file_0_Colon_1, fileName, hostErrorMessage));
    }, sourceFiles);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.zipWith" id="apidoc.element.typescript.zipWith">
        function <span class="apidocSignatureSpan">typescript.</span>zipWith
        <span class="apidocSignatureSpan">(arrayA, arrayB, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zipWith(arrayA, arrayB, callback) {
    Debug.assert(arrayA.length === arrayB.length);
    for (var i = 0; i &lt; arrayA.length; i++) {
        callback(arrayA[i], arrayB[i], i);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















































































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.BreakpointResolver" id="apidoc.module.typescript.BreakpointResolver">module typescript.BreakpointResolver</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.BreakpointResolver.spanInSourceFileAtLocation" id="apidoc.element.typescript.BreakpointResolver.spanInSourceFileAtLocation">
        function <span class="apidocSignatureSpan">typescript.BreakpointResolver.</span>spanInSourceFileAtLocation
        <span class="apidocSignatureSpan">(sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spanInSourceFileAtLocation(sourceFile, position) {
    // Cannot set breakpoint in dts file
    if (sourceFile.isDeclarationFile) {
        return undefined;
    }
    var tokenAtLocation = ts.getTokenAtPosition(sourceFile, position);
    var lineOfPosition = sourceFile.getLineAndCharacterOfPosition(position).line;
    if (sourceFile.getLineAndCharacterOfPosition(tokenAtLocation.getStart(sourceFile)).line &gt; lineOfPosition) {
        // Get previous token if the token is returned starts on new line
        // eg: let x =10; |--- cursor is here
        //     let y = 10;
        // token at position will return let keyword on second line as the token but we would like to use
        // token on same line if trailing trivia (comments or white spaces on same line) part of the last token on that line
        tokenAtLocation = ts.findPrecedingToken(tokenAtLocation.pos, sourceFile);
        // It's a blank line
        if (!tokenAtLocation || sourceFile.getLineAndCharacterOfPosition(tokenAtLocation.getEnd()).line !== lineOfPosition) {
            return undefined;
        }
    }
    // Cannot set breakpoint in ambient declarations
    if (ts.isInAmbientContext(tokenAtLocation)) {
        return undefined;
    }
    // Get the span in the node based on its syntax
    return spanInNode(tokenAtLocation);
    function textSpan(startNode, endNode) {
        var start = startNode.decorators ?
            ts.skipTrivia(sourceFile.text, startNode.decorators.end) :
            startNode.getStart(sourceFile);
        return ts.createTextSpanFromBounds(start, (endNode || startNode).getEnd());
    }
    function textSpanEndingAtNextToken(startNode, previousTokenToFindNextEndToken) {
        return textSpan(startNode, ts.findNextToken(previousTokenToFindNextEndToken, previousTokenToFindNextEndToken.parent));
    }
    function spanInNodeIfStartsOnSameLine(node, otherwiseOnNode) {
        if (node &amp;&amp; lineOfPosition === sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile)).line) {
            return spanInNode(node);
        }
        return spanInNode(otherwiseOnNode);
    }
    function spanInNodeArray(nodeArray) {
        return ts.createTextSpanFromBounds(ts.skipTrivia(sourceFile.text, nodeArray.pos), nodeArray.end);
    }
    function spanInPreviousNode(node) {
        return spanInNode(ts.findPrecedingToken(node.pos, sourceFile));
    }
    function spanInNextNode(node) {
        return spanInNode(ts.findNextToken(node, node.parent));
    }
    function spanInNode(node) {
        if (node) {
            switch (node.kind) {
                case 207 /* VariableStatement */:
                    // Span on first variable declaration
                    return spanInVariableDeclaration(node.declarationList.declarations[0]);
                case 225 /* VariableDeclaration */:
                case 148 /* PropertyDeclaration */:
                case 147 /* PropertySignature */:
                    return spanInVariableDeclaration(node);
                case 145 /* Parameter */:
                    return spanInParameterDeclaration(node);
                case 227 /* FunctionDeclaration */:
                case 150 /* MethodDeclaration */:
                case 149 /* MethodSignature */:
                case 152 /* GetAccessor */:
                case 153 /* SetAccessor */:
                case 151 /* Constructor */:
                case 185 /* FunctionExpression */:
                case 186 /* ArrowFunction */:
                    return spanInFunctionDeclaration(node);
                case 206 /* Block */:
                    if (ts.isFunctionBlock(node)) {
                        return spanInFunctionBlock(node);
                    }
                // Fall through
                case 233 /* ModuleBlock */:
                    return spanInBlock(node);
                case 258 /* CatchClause */:
                    return spanInBlock(node.block);
                case 209 /* ExpressionStatement */:
                    // span on the expression
                    return textSpan(node.expression);
                case 2 ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.Completions" id="apidoc.module.typescript.Completions">module typescript.Completions</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.Completions.getCompletionEntryDetails" id="apidoc.element.typescript.Completions.getCompletionEntryDetails">
        function <span class="apidocSignatureSpan">typescript.Completions.</span>getCompletionEntryDetails
        <span class="apidocSignatureSpan">(typeChecker, log, compilerOptions, sourceFile, position, entryName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCompletionEntryDetails(typeChecker, log, compilerOptions, sourceFile, position, entryName) {
    // Compute all the completion symbols again.
    var completionData = getCompletionData(typeChecker, log, sourceFile, position);
    if (completionData) {
        var symbols = completionData.symbols, location_1 = completionData.location;
        // Find the symbol with the matching entry name.
        // We don't need to perform character checks here because we're only comparing the
        // name against 'entryName' (which is known to be good), not building a new
        // completion entry.
        var symbol = ts.forEach(symbols, function (s) { return getCompletionEntryDisplayNameForSymbol(typeChecker, s, compilerOptions
.target, /*performCharacterChecks*/ false, location_1) === entryName ? s : undefined; });
        if (symbol) {
            var _a = ts.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(typeChecker, symbol, sourceFile, location_1
, location_1, 7 /* All */), displayParts = _a.displayParts, documentation = _a.documentation, symbolKind = _a.symbolKind;
            return {
                name: entryName,
                kindModifiers: ts.SymbolDisplay.getSymbolModifiers(symbol),
                kind: symbolKind,
                displayParts: displayParts,
                documentation: documentation
            };
        }
    }
    // Didn't find a symbol with this name.  See if we can find a keyword instead.
    var keywordCompletion = ts.forEach(keywordCompletions, function (c) { return c.name === entryName; });
    if (keywordCompletion) {
        return {
            name: entryName,
            kind: ts.ScriptElementKind.keyword,
            kindModifiers: ts.ScriptElementKindModifier.none,
            displayParts: [ts.displayPart(entryName, ts.SymbolDisplayPartKind.keyword)],
            documentation: undefined
        };
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Completions.getCompletionEntrySymbol" id="apidoc.element.typescript.Completions.getCompletionEntrySymbol">
        function <span class="apidocSignatureSpan">typescript.Completions.</span>getCompletionEntrySymbol
        <span class="apidocSignatureSpan">(typeChecker, log, compilerOptions, sourceFile, position, entryName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCompletionEntrySymbol(typeChecker, log, compilerOptions, sourceFile, position, entryName) {
    // Compute all the completion symbols again.
    var completionData = getCompletionData(typeChecker, log, sourceFile, position);
    if (completionData) {
        var symbols = completionData.symbols, location_2 = completionData.location;
        // Find the symbol with the matching entry name.
        // We don't need to perform character checks here because we're only comparing the
        // name against 'entryName' (which is known to be good), not building a new
        // completion entry.
        return ts.forEach(symbols, function (s) { return getCompletionEntryDisplayNameForSymbol(typeChecker, s, compilerOptions.
target, /*performCharacterChecks*/ false, location_2) === entryName ? s : undefined; });
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Completions.getCompletionsAtPosition" id="apidoc.element.typescript.Completions.getCompletionsAtPosition">
        function <span class="apidocSignatureSpan">typescript.Completions.</span>getCompletionsAtPosition
        <span class="apidocSignatureSpan">(host, typeChecker, log, compilerOptions, sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCompletionsAtPosition(host, typeChecker, log, compilerOptions, sourceFile, position) {
    if (ts.isInReferenceComment(sourceFile, position)) {
        return getTripleSlashReferenceCompletion(sourceFile, position, compilerOptions, host);
    }
    if (ts.isInString(sourceFile, position)) {
        return getStringLiteralCompletionEntries(sourceFile, position, typeChecker, compilerOptions, host, log);
    }
    var completionData = getCompletionData(typeChecker, log, sourceFile, position);
    if (!completionData) {
        return undefined;
    }
    var symbols = completionData.symbols, isGlobalCompletion = completionData.isGlobalCompletion, isMemberCompletion = completionData
.isMemberCompletion, isNewIdentifierLocation = completionData.isNewIdentifierLocation, location = completionData.location, isJsDocTagName
 = completionData.isJsDocTagName;
    if (isJsDocTagName) {
        // If the current position is a jsDoc tag name, only tag names should be provided for completion
        return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: false, entries: ts.JsDoc.getAllJsDocCompletionEntries
() };
    }
    var entries = [];
    if (ts.isSourceFileJavaScript(sourceFile)) {
        var uniqueNames = getCompletionEntriesFromSymbols(symbols, entries, location, /*performCharacterChecks*/ true, typeChecker
, compilerOptions.target, log);
        ts.addRange(entries, getJavaScriptCompletionEntries(sourceFile, location.pos, uniqueNames, compilerOptions.target));
    }
    else {
        if (!symbols || symbols.length === 0) {
            if (sourceFile.languageVariant === 1 /* JSX */ &amp;&amp;
                location.parent &amp;&amp; location.parent.kind === 251 /* JsxClosingElement */) {
                // In the TypeScript JSX element, if such element is not defined. When users query for completion at closing tag
,
                // instead of simply giving unknown value, the completion will return the tag-name of an associated opening-element
.
                // For example:
                //     var x = &lt;div&gt; &lt;/ /*1*/&gt;  completion list at "1" will contain "div" with type any
                var tagName = location.parent.parent.openingElement.tagName;
                entries.push({
                    name: tagName.text,
                    kind: undefined,
                    kindModifiers: undefined,
                    sortText: "0",
                });
            }
            else {
                return undefined;
            }
        }
        getCompletionEntriesFromSymbols(symbols, entries, location, /*performCharacterChecks*/ true, typeChecker, compilerOptions
.target, log);
    }
    // Add keywords if this is not a member completion list
    if (!isMemberCompletion &amp;&amp; !isJsDocTagName) {
        ts.addRange(entries, keywordCompletions);
    }
    return { isGlobalCompletion: isGlobalCompletion, isMemberCompletion: isMemberCompletion, isNewIdentifierLocation: isNewIdentifierLocation
, entries: entries };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.CoreServicesShimHostAdapter" id="apidoc.module.typescript.CoreServicesShimHostAdapter">module typescript.CoreServicesShimHostAdapter</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.CoreServicesShimHostAdapter.CoreServicesShimHostAdapter" id="apidoc.element.typescript.CoreServicesShimHostAdapter.CoreServicesShimHostAdapter">
        function <span class="apidocSignatureSpan">typescript.</span>CoreServicesShimHostAdapter
        <span class="apidocSignatureSpan">(shimHost)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CoreServicesShimHostAdapter(shimHost) {
    var _this = this;
    this.shimHost = shimHost;
    this.useCaseSensitiveFileNames = this.shimHost.useCaseSensitiveFileNames ? this.shimHost.useCaseSensitiveFileNames() : false
;
    if ("directoryExists" in this.shimHost) {
        this.directoryExists = function (directoryName) { return _this.shimHost.directoryExists(directoryName); };
    }
    if ("realpath" in this.shimHost) {
        this.realpath = function (path) { return _this.shimHost.realpath(path); };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.CoreServicesShimHostAdapter.prototype" id="apidoc.module.typescript.CoreServicesShimHostAdapter.prototype">module typescript.CoreServicesShimHostAdapter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.fileExists" id="apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.fileExists">
        function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>fileExists
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fileExists = function (fileName) {
    return this.shimHost.fileExists(fileName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.getDirectories" id="apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.getDirectories">
        function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>getDirectories
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDirectories = function (path) {
    return JSON.parse(this.shimHost.getDirectories(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.readDirectory" id="apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.readDirectory">
        function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>readDirectory
        <span class="apidocSignatureSpan">(rootDir, extensions, exclude, include, depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readDirectory = function (rootDir, extensions, exclude, include, depth) {
    // Wrap the API changes for 2.0 release. This try/catch
    // should be removed once TypeScript 2.0 has shipped.
    try {
        var pattern = ts.getFileMatcherPatterns(rootDir, exclude, include, this.shimHost.useCaseSensitiveFileNames(), this.shimHost
.getCurrentDirectory());
        return JSON.parse(this.shimHost.readDirectory(rootDir, JSON.stringify(extensions), JSON.stringify(pattern.basePaths), pattern
.excludePattern, pattern.includeFilePattern, pattern.includeDirectoryPattern, depth));
    }
    catch (e) {
        var results = [];
        for (var _i = 0, extensions_2 = extensions; _i &lt; extensions_2.length; _i++) {
            var extension = extensions_2[_i];
            for (var _a = 0, _b = this.readDirectoryFallback(rootDir, extension, exclude); _a &lt; _b.length; _a++) {
                var file = _b[_a];
                if (!ts.contains(results, file)) {
                    results.push(file);
                }
            }
        }
        return results;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.readDirectoryFallback" id="apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.readDirectoryFallback">
        function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>readDirectoryFallback
        <span class="apidocSignatureSpan">(rootDir, extension, exclude)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readDirectoryFallback = function (rootDir, extension, exclude) {
    return JSON.parse(this.shimHost.readDirectory(rootDir, extension, JSON.stringify(exclude)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.readFile" id="apidoc.element.typescript.CoreServicesShimHostAdapter.prototype.readFile">
        function <span class="apidocSignatureSpan">typescript.CoreServicesShimHostAdapter.prototype.</span>readFile
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFile = function (fileName) {
    return this.shimHost.readFile(fileName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.Debug" id="apidoc.module.typescript.Debug">module typescript.Debug</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.Debug.assert" id="apidoc.element.typescript.Debug.assert">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>assert
        <span class="apidocSignatureSpan">(expression, message, verboseDebugInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assert(expression, message, verboseDebugInfo) {
    if (!expression) {
        var verboseDebugString = "";
        if (verboseDebugInfo) {
            verboseDebugString = "\r\nVerbose Debug Information: " + verboseDebugInfo();
        }
        debugger;
        throw new Error("Debug Failure. False expression: " + (message || "") + verboseDebugString);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Debug.assertEachNode" id="apidoc.element.typescript.Debug.assertEachNode">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>assertEachNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Debug.assertMissingNode" id="apidoc.element.typescript.Debug.assertMissingNode">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>assertMissingNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Debug.assertNode" id="apidoc.element.typescript.Debug.assertNode">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>assertNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Debug.assertOptionalNode" id="apidoc.element.typescript.Debug.assertOptionalNode">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>assertOptionalNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Debug.assertOptionalToken" id="apidoc.element.typescript.Debug.assertOptionalToken">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>assertOptionalToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Debug.fail" id="apidoc.element.typescript.Debug.fail">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>fail
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fail(message) {
    Debug.assert(/*expression*/ false, message);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Debug.failBadSyntaxKind" id="apidoc.element.typescript.Debug.failBadSyntaxKind">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>failBadSyntaxKind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Debug.failNotOptional" id="apidoc.element.typescript.Debug.failNotOptional">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>failNotOptional
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.Debug.shouldAssert" id="apidoc.element.typescript.Debug.shouldAssert">
        function <span class="apidocSignatureSpan">typescript.Debug.</span>shouldAssert
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldAssert(level) {
    return Debug.currentAssertionLevel &gt;= level;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.DocumentHighlights" id="apidoc.module.typescript.DocumentHighlights">module typescript.DocumentHighlights</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.DocumentHighlights.getDocumentHighlights" id="apidoc.element.typescript.DocumentHighlights.getDocumentHighlights">
        function <span class="apidocSignatureSpan">typescript.DocumentHighlights.</span>getDocumentHighlights
        <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFile, position, sourceFilesToSearch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDocumentHighlights(typeChecker, cancellationToken, sourceFile, position, sourceFilesToSearch) {
    var node = ts.getTouchingWord(sourceFile, position);
    return node &amp;&amp; (getSemanticDocumentHighlights(node, typeChecker, cancellationToken, sourceFilesToSearch) || getSyntacticDocumentHighlights
(node, sourceFile));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.FindAllReferences" id="apidoc.module.typescript.FindAllReferences">module typescript.FindAllReferences</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.FindAllReferences.convertReferences" id="apidoc.element.typescript.FindAllReferences.convertReferences">
        function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>convertReferences
        <span class="apidocSignatureSpan">(referenceSymbols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertReferences(referenceSymbols) {
    return referenceSymbols &amp;&amp; ts.flatMap(referenceSymbols, function (r) { return r.references; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.FindAllReferences.findReferencedSymbols" id="apidoc.element.typescript.FindAllReferences.findReferencedSymbols">
        function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>findReferencedSymbols
        <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFiles, sourceFile, position, findInStrings, findInComments, isForRename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findReferencedSymbols(typeChecker, cancellationToken, sourceFiles, sourceFile, position, findInStrings, findInComments, isForRename) {
    var node = ts.getTouchingPropertyName(sourceFile, position, /*includeJsDocComment*/ true);
    return getReferencedSymbolsForNode(typeChecker, cancellationToken, node, sourceFiles, findInStrings, findInComments, isForRename
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.FindAllReferences.getReferenceEntriesForShorthandPropertyAssignment" id="apidoc.element.typescript.FindAllReferences.getReferenceEntriesForShorthandPropertyAssignment">
        function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>getReferenceEntriesForShorthandPropertyAssignment
        <span class="apidocSignatureSpan">(node, typeChecker, result)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getReferenceEntriesForShorthandPropertyAssignment(node, typeChecker, result) {
    var refSymbol = typeChecker.getSymbolAtLocation(node);
    var shorthandSymbol = typeChecker.getShorthandAssignmentValueSymbol(refSymbol.valueDeclaration);
    if (shorthandSymbol) {
        for (var _i = 0, _a = shorthandSymbol.getDeclarations(); _i &lt; _a.length; _i++) {
            var declaration = _a[_i];
            if (ts.getMeaningFromDeclaration(declaration) &amp; 1 /* Value */) {
                result.push(getReferenceEntryFromNode(declaration));
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.FindAllReferences.getReferenceEntryFromNode" id="apidoc.element.typescript.FindAllReferences.getReferenceEntryFromNode">
        function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>getReferenceEntryFromNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getReferenceEntryFromNode(node) {
    var start = node.getStart();
    var end = node.getEnd();
    if (node.kind === 9 /* StringLiteral */) {
        start += 1;
        end -= 1;
    }
    return {
        fileName: node.getSourceFile().fileName,
        textSpan: ts.createTextSpanFromBounds(start, end),
        isWriteAccess: isWriteAccess(node),
        isDefinition: ts.isDeclarationName(node) || ts.isLiteralComputedPropertyDeclarationName(node)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.FindAllReferences.getReferencedSymbolsForNode" id="apidoc.element.typescript.FindAllReferences.getReferencedSymbolsForNode">
        function <span class="apidocSignatureSpan">typescript.FindAllReferences.</span>getReferencedSymbolsForNode
        <span class="apidocSignatureSpan">(typeChecker, cancellationToken, node, sourceFiles, findInStrings, findInComments, isForRename , implementations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getReferencedSymbolsForNode(typeChecker, cancellationToken, node, sourceFiles, findInStrings, findInComments, isForRename , implementations) {
    if (!implementations) {
        var special = getReferencedSymbolsSpecial(node, sourceFiles, typeChecker, cancellationToken);
        if (special) {
            return special;
        }
    }
    // `getSymbolAtLocation` normally returns the symbol of the class when given the constructor keyword,
    // so we have to specify that we want the constructor symbol.
    var symbol = typeChecker.getSymbolAtLocation(node);
    // Could not find a symbol e.g. unknown identifier
    if (!symbol) {
        if (!implementations &amp;&amp; node.kind === 9 /* StringLiteral */) {
            return getReferencesForStringLiteral(node, sourceFiles, typeChecker, cancellationToken);
        }
        // Can't have references to something that we have no symbol for.
        return undefined;
    }
    var declarations = symbol.declarations;
    // The symbol was an internal symbol and does not have a declaration e.g. undefined symbol
    if (!declarations || !declarations.length) {
        return undefined;
    }
    var _a = followAliases(symbol, node, typeChecker, isForRename), aliasedSymbol = _a.symbol, shorthandModuleSymbol = _a.shorthandModuleSymbol
;
    symbol = aliasedSymbol;
    // Build the set of symbols to search for, initially it has only the current symbol
    var searchSymbols = populateSearchSymbolSet(symbol, node, typeChecker, implementations);
    if (shorthandModuleSymbol) {
        searchSymbols.push(shorthandModuleSymbol);
    }
    // Compute the meaning from the location and the symbol it references
    var searchMeaning = getIntersectingMeaningFromDeclarations(ts.getMeaningFromLocation(node), declarations);
    var result = [];
    // Maps from a symbol ID to the ReferencedSymbol entry in 'result'.
    var symbolToIndex = [];
    var inheritsFromCache = ts.createMap();
    // Get the text to search for.
    // Note: if this is an external module symbol, the name doesn't include quotes.
    var declaredName = ts.stripQuotes(ts.getDeclaredName(typeChecker, symbol, node));
    // Try to get the smallest valid scope that we can limit our search to;
    // otherwise we'll need to search globally (i.e. include each file).
    var scope = getSymbolScope(symbol);
    if (scope) {
        getRefs(scope, declaredName);
    }
    else {
        var isDefault = ts.isExportDefaultSymbol(symbol);
        var internedName = isDefault ? symbol.valueDeclaration.localSymbol.name : getInternedName(symbol, node);
        for (var _i = 0, sourceFiles_5 = sourceFiles; _i &lt; sourceFiles_5.length; _i++) {
            var sourceFile = sourceFiles_5[_i];
            cancellationToken.throwIfCancellationRequested();
            var searchName = (isDefault ? getDefaultImportName(symbol, sourceFile, typeChecker) : undefined) ||
                (sourceFileHasName(sourceFile, internedName) ? declaredName : undefined);
            if (searchName !== undefined) {
                getRefs(sourceFile, searchName);
            }
        }
    }
    return result;
    function getRefs(scope, searchName) {
        getReferencesInNode(scope, symbol, searchName, node, searchMeaning, findInStrings, findInComments, result, symbolToIndex
, implementations, typeChecker, cancellationToken, searchSymbols, inheritsFromCache);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.GoToDefinition" id="apidoc.module.typescript.GoToDefinition">module typescript.GoToDefinition</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.GoToDefinition.getDefinitionAtPosition" id="apidoc.element.typescript.GoToDefinition.getDefinitionAtPosition">
        function <span class="apidocSignatureSpan">typescript.GoToDefinition.</span>getDefinitionAtPosition
        <span class="apidocSignatureSpan">(program, sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefinitionAtPosition(program, sourceFile, position) {
    /// Triple slash reference comments
    var comment = findReferenceInPosition(sourceFile.referencedFiles, position);
    if (comment) {
        var referenceFile = ts.tryResolveScriptReference(program, sourceFile, comment);
        if (referenceFile) {
            return [getDefinitionInfoForFileReference(comment.fileName, referenceFile.fileName)];
        }
        return undefined;
    }
    // Type reference directives
    var typeReferenceDirective = findReferenceInPosition(sourceFile.typeReferenceDirectives, position);
    if (typeReferenceDirective) {
        var referenceFile = program.getResolvedTypeReferenceDirectives().get(typeReferenceDirective.fileName);
        return referenceFile &amp;&amp; referenceFile.resolvedFileName &amp;&amp;
            [getDefinitionInfoForFileReference(typeReferenceDirective.fileName, referenceFile.resolvedFileName)];
    }
    var node = ts.getTouchingPropertyName(sourceFile, position);
    if (node === sourceFile) {
        return undefined;
    }
    // Labels
    if (ts.isJumpStatementTarget(node)) {
        var labelName = node.text;
        var label = ts.getTargetLabel(node.parent, node.text);
        return label ? [createDefinitionInfoFromName(label, ts.ScriptElementKind.label, labelName, /*containerName*/ undefined)] :
undefined;
    }
    var typeChecker = program.getTypeChecker();
    var calledDeclaration = tryGetSignatureDeclaration(typeChecker, node);
    if (calledDeclaration) {
        return [createDefinitionFromSignatureDeclaration(typeChecker, calledDeclaration)];
    }
    var symbol = typeChecker.getSymbolAtLocation(node);
    // Could not find a symbol e.g. node is string or number keyword,
    // or the symbol was an internal symbol and does not have a declaration e.g. undefined symbol
    if (!symbol) {
        return undefined;
    }
    // If this is an alias, and the request came at the declaration location
    // get the aliased symbol instead. This allows for goto def on an import e.g.
    //   import {A, B} from "mod";
    // to jump to the implementation directly.
    if (symbol.flags &amp; 8388608 /* Alias */) {
        var declaration = symbol.declarations[0];
        // Go to the original declaration for cases:
        //
        //   (1) when the aliased symbol was declared in the location(parent).
        //   (2) when the aliased symbol is originating from a named import.
        //
        if (node.kind === 70 /* Identifier */ &amp;&amp;
            (node.parent === declaration ||
                (declaration.kind === 241 /* ImportSpecifier */ &amp;&amp; declaration.parent &amp;&amp; declaration.parent.kind === 240 /* NamedImports
 */))) {
            symbol = typeChecker.getAliasedSymbol(symbol);
        }
    }
    // Because name in short-hand property assignment has two different meanings: property name and property value,
    // using go-to-definition at such position should go to the variable declaration of the property value rather than
    // go to the declaration of the property name (in this case stay at the same position). However, if go-to-definition
    // is performed at the location of property access, we would like to go to definition of the property in the short-hand
    // assignment. This case and others are handled by the following code.
    if (node.parent.kind === 260 /* ShorthandPropertyAssignment */) {
        var shorthandSymbol = typeChecker.getShorthandAssignmentValueSymbol(symbol.valueDeclaration);
        if (!shorthandSymbol) {
            return [];
        }
        var shorthandDeclarations = shorthandSymbol.getDeclarations();
        var shorthandSymbolKind_1 = ts.SymbolDisplay.getSymbolKind(typeChecker, shorthandSymbol, node);
        var shorthandSymbolName_1 = typeChecker.symbolToString(shorthandSymbol);
        var shorthandContainerName_1 = typeChecker.symbolToString(symbol.parent, node);
        return ts.map(shorthandDeclarations, function (declaration) { return createDefinitionInfo(declaration, shorthandSymbolKind_1
, shorthandSymbolName_1, shorthandContainerName_1); }); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.GoToDefinition.getTypeDefinitionAtPosition" id="apidoc.element.typescript.GoToDefinition.getTypeDefinitionAtPosition">
        function <span class="apidocSignatureSpan">typescript.GoToDefinition.</span>getTypeDefinitionAtPosition
        <span class="apidocSignatureSpan">(typeChecker, sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTypeDefinitionAtPosition(typeChecker, sourceFile, position) {
    var node = ts.getTouchingPropertyName(sourceFile, position);
    if (node === sourceFile) {
        return undefined;
    }
    var symbol = typeChecker.getSymbolAtLocation(node);
    if (!symbol) {
        return undefined;
    }
    var type = typeChecker.getTypeOfSymbolAtLocation(symbol, node);
    if (!type) {
        return undefined;
    }
    if (type.flags &amp; 65536 /* Union */ &amp;&amp; !(type.flags &amp; 16 /* Enum */)) {
        var result_5 = [];
        ts.forEach(type.types, function (t) {
            if (t.symbol) {
                ts.addRange(/*to*/ result_5, /*from*/ getDefinitionFromSymbol(typeChecker, t.symbol, node));
            }
        });
        return result_5;
    }
    if (!type.symbol) {
        return undefined;
    }
    return getDefinitionFromSymbol(typeChecker, type.symbol, node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.GoToImplementation" id="apidoc.module.typescript.GoToImplementation">module typescript.GoToImplementation</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.GoToImplementation.getImplementationAtPosition" id="apidoc.element.typescript.GoToImplementation.getImplementationAtPosition">
        function <span class="apidocSignatureSpan">typescript.GoToImplementation.</span>getImplementationAtPosition
        <span class="apidocSignatureSpan">(typeChecker, cancellationToken, sourceFiles, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getImplementationAtPosition(typeChecker, cancellationToken, sourceFiles, node) {
    // If invoked directly on a shorthand property assignment, then return
    // the declaration of the symbol being assigned (not the symbol being assigned to).
    if (node.parent.kind === 260 /* ShorthandPropertyAssignment */) {
        var result = [];
        ts.FindAllReferences.getReferenceEntriesForShorthandPropertyAssignment(node, typeChecker, result);
        return result.length &gt; 0 ? result : undefined;
    }
    else if (node.kind === 96 /* SuperKeyword */ || ts.isSuperProperty(node.parent)) {
        // References to and accesses on the super keyword only have one possible implementation, so no
        // need to "Find all References"
        var symbol = typeChecker.getSymbolAtLocation(node);
        return symbol.valueDeclaration &amp;&amp; [ts.FindAllReferences.getReferenceEntryFromNode(symbol.valueDeclaration)];
    }
    else {
        // Perform "Find all References" and retrieve only those that are implementations
        var referencedSymbols = ts.FindAllReferences.getReferencedSymbolsForNode(typeChecker, cancellationToken, node, sourceFiles
, /*findInStrings*/ false, /*findInComments*/ false, /*isForRename*/ false, /*implementations*/ true);
        var result = ts.flatMap(referencedSymbols, function (symbol) {
            return ts.map(symbol.references, function (_a) {
                var textSpan = _a.textSpan, fileName = _a.fileName;
                return ({ textSpan: textSpan, fileName: fileName });
            });
        });
        return result &amp;&amp; result.length &gt; 0 ? result : undefined;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.JsDoc" id="apidoc.module.typescript.JsDoc">module typescript.JsDoc</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.JsDoc.getAllJsDocCompletionEntries" id="apidoc.element.typescript.JsDoc.getAllJsDocCompletionEntries">
        function <span class="apidocSignatureSpan">typescript.JsDoc.</span>getAllJsDocCompletionEntries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAllJsDocCompletionEntries() {
    return jsDocCompletionEntries || (jsDocCompletionEntries = ts.map(jsDocTagNames, function (tagName) {
        return {
            name: tagName,
            kind: ts.ScriptElementKind.keyword,
            kindModifiers: "",
            sortText: "0",
        };
    }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.JsDoc.getDocCommentTemplateAtPosition" id="apidoc.element.typescript.JsDoc.getDocCommentTemplateAtPosition">
        function <span class="apidocSignatureSpan">typescript.JsDoc.</span>getDocCommentTemplateAtPosition
        <span class="apidocSignatureSpan">(newLine, sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDocCommentTemplateAtPosition(newLine, sourceFile, position) {
    // Check if in a context where we don't want to perform any insertion
    if (ts.isInString(sourceFile, position) || ts.isInComment(sourceFile, position) || ts.hasDocComment(sourceFile, position)) {
        return undefined;
    }
    var tokenAtPos = ts.getTokenAtPosition(sourceFile, position);
    var tokenStart = tokenAtPos.getStart();
    if (!tokenAtPos || tokenStart &lt; position) {
        return undefined;
    }
    // TODO: add support for:
    // - enums/enum members
    // - interfaces
    // - property declarations
    // - potentially property assignments
    var commentOwner;
    findOwner: for (commentOwner = tokenAtPos; commentOwner; commentOwner = commentOwner.parent) {
        switch (commentOwner.kind) {
            case 227 /* FunctionDeclaration */:
            case 150 /* MethodDeclaration */:
            case 151 /* Constructor */:
            case 228 /* ClassDeclaration */:
            case 207 /* VariableStatement */:
                break findOwner;
            case 263 /* SourceFile */:
                return undefined;
            case 232 /* ModuleDeclaration */:
                // If in walking up the tree, we hit a a nested namespace declaration,
                // then we must be somewhere within a dotted namespace name; however we don't
                // want to give back a JSDoc template for the 'b' or 'c' in 'namespace a.b.c { }'.
                if (commentOwner.parent.kind === 232 /* ModuleDeclaration */) {
                    return undefined;
                }
                break findOwner;
        }
    }
    if (!commentOwner || commentOwner.getStart() &lt; position) {
        return undefined;
    }
    var parameters = getParametersForJsDocOwningNode(commentOwner);
    var posLineAndChar = sourceFile.getLineAndCharacterOfPosition(position);
    var lineStart = sourceFile.getLineStarts()[posLineAndChar.line];
    var indentationStr = sourceFile.text.substr(lineStart, posLineAndChar.character);
    var isJavaScriptFile = ts.hasJavaScriptFileExtension(sourceFile.fileName);
    var docParams = "";
    for (var i = 0; i &lt; parameters.length; i++) {
        var currentName = parameters[i].name;
        var paramName = currentName.kind === 70 /* Identifier */ ?
            currentName.text :
            "param" + i;
        if (isJavaScriptFile) {
            docParams += indentationStr + " * @param {any} " + paramName + newLine;
        }
        else {
            docParams += indentationStr + " * @param " + paramName + newLine;
        }
    }
    // A doc comment consists of the following
    // * The opening comment line
    // * the first line (without a param) for the object's untagged info (this is also where the caret ends up)
    // * the '@param'-tagged lines
    // * TODO: other tags.
    // * the closing comment line
    // * if the caret was directly in front of the object, then we add an extra line and indentation.
    var preamble = "/**" + newLine +
        indentationStr + " * ";
    var result = preamble + newLine +
        docParams +
        indentationStr + " */" +
        (tokenStart === position ? newLine + indentationStr : "");
    return { newText: result, caretOffset: preamble.length };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.JsDoc.getJsDocCommentsFromDeclarations" id="apidoc.element.typescript.JsDoc.getJsDocCommentsFromDeclarations">
        function <span class="apidocSignatureSpan">typescript.JsDoc.</span>getJsDocCommentsFromDeclarations
        <span class="apidocSignatureSpan">(declarations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getJsDocCommentsFromDeclarations(declarations) {
    // Only collect doc comments from duplicate declarations once:
    // In case of a union property there might be same declaration multiple times
    // which only varies in type parameter
    // Eg. const a: Array&lt;string&gt; | Array&lt;number&gt;; a.length
    // The property length will have two declarations of property length coming
    // from Array&lt;T&gt; - Array&lt;string&gt; and Array&lt;number&gt;
    var documentationComment = [];
    forEachUnique(declarations, function (declaration) {
        var comments = ts.getCommentsFromJSDoc(declaration);
        if (!comments) {
            return;
        }
        for (var _i = 0, comments_3 = comments; _i &lt; comments_3.length; _i++) {
            var comment = comments_3[_i];
            if (comment) {
                if (documentationComment.length) {
                    documentationComment.push(ts.lineBreakPart());
                }
                documentationComment.push(ts.textPart(comment));
            }
        }
    });
    return documentationComment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.JsTyping" id="apidoc.module.typescript.JsTyping">module typescript.JsTyping</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.JsTyping.discoverTypings" id="apidoc.element.typescript.JsTyping.discoverTypings">
        function <span class="apidocSignatureSpan">typescript.JsTyping.</span>discoverTypings
        <span class="apidocSignatureSpan">(host, fileNames, projectRootPath, safeListPath, packageNameToTypingLocation, typeAcquisition, unresolvedImports )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function discoverTypings(host, fileNames, projectRootPath, safeListPath, packageNameToTypingLocation, typeAcquisition, unresolvedImports ) {
    // A typing name to typing file path mapping
    var inferredTypings = ts.createMap();
    if (!typeAcquisition || !typeAcquisition.enable) {
        return { cachedTypingPaths: [], newTypingNames: [], filesToWatch: [] };
    }
    // Only infer typings for .js and .jsx files
    fileNames = ts.filter(ts.map(fileNames, ts.normalizePath), function (f) {
        var kind = ts.ensureScriptKind(f, ts.getScriptKindFromFileName(f));
        return kind === 1<span class="apidocCodeCommentSpan"> /* JS */ || kind === 2 /* JSX */;
    });
    if (!safeList) {
        var result = ts.readConfigFile(safeListPath, function (path) { return host.readFile(path); });
        safeList = result.config ? ts.createMapFromTemplate(result.config) : EmptySafeList;
    }
    var filesToWatch = [];
    // Directories to search for package.json, bower.json and other typing information
    var searchDirs = [];
    var exclude = [];
    mergeTypings(typeAcquisition.include);
    exclude = typeAcquisition.exclude || [];
    var possibleSearchDirs = ts.map(fileNames, ts.getDirectoryPath);
    if (projectRootPath) {
        possibleSearchDirs.push(projectRootPath);
    }
    searchDirs = ts.deduplicate(possibleSearchDirs);
    for (var _i = 0, searchDirs_1 = searchDirs; _i &lt; searchDirs_1.length; _i++) {
        var searchDir = searchDirs_1[_i];
        var packageJsonPath = ts.combinePaths(searchDir, "package.json");
        getTypingNamesFromJson(packageJsonPath, filesToWatch);
        var bowerJsonPath = ts.combinePaths(searchDir, "bower.json");
        getTypingNamesFromJson(bowerJsonPath, filesToWatch);
        var nodeModulesPath = ts.combinePaths(searchDir, "node_modules");
        getTypingNamesFromNodeModuleFolder(nodeModulesPath);
    }
    getTypingNamesFromSourceFileNames(fileNames);
    // add typings for unresolved imports
    if (unresolvedImports) {
        for (var _a = 0, unresolvedImports_1 = unresolvedImports; _a &lt; unresolvedImports_1.length; _a++) {
            var moduleId = unresolvedImports_1[_a];
            var typingName = nodeCoreModules.has(moduleId) ? "node" : moduleId;
            if (!inferredTypings.has(typingName)) {
                inferredTypings.set(typingName, undefined);
            }
        }
    }
    // Add the cached typing locations for inferred typings that are already installed
    packageNameToTypingLocation.forEach(function (typingLocation, name) {
        if (inferredTypings.has(name) &amp;&amp; inferredTypings.get(name) === undefined) {
            inferredTypings.set(name, typingLocation);
        }
    });
    // Remove typings that the user has added to the exclude list
    for (var _b = 0, exclude_1 = exclude; _b &lt; exclude_1.length; _b++) {
        var excludeTypingName = exclude_1[_b];
        inferredTypings.delete(excludeTypingName);
    }
    var newTypingNames = [];
    var cachedTypingPaths = [];
    inferredTypings.forEach(function (inferred, typing) {
        if (inferred !== undefined) {
            cachedTypingPaths.push(inferred);
        }
        else {
            newTypingNames.push(typing);
        }
    });
    return { cachedTypingPaths: cachedTypingPaths, newTypingNames: newTypingNames, filesToWatch: filesToWatch };
    /**
     * Merge a given list of typingNames to the inferredTypings map
     */
</span>    function mergeTypings(typingNames) {
        if (!typingNames) {
            return;
        }
        for (var _i = 0, typingNames_1 = typingNames; _i &lt; typingNames_1.length; _i++) {
            var typing = typingNames_1[_i];
            if (!inferredTypings.has(typing)) {
                inferredTypings.set(typing, undefined);
            }
        }
    }
    /**
     * Get the typing info from common package manager json files like package.json or bower.json
     */
    function getTypingNamesFromJson(jsonPath, filesToWatch) {
        if (host.fileExists(jsonPath)) {
            filesToWatch.push(jsonPath);
        }
        var result = ts.readConfigFile(jsonPath, function (pat ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.LanguageServiceShimHostAdapter" id="apidoc.module.typescript.LanguageServiceShimHostAdapter">module typescript.LanguageServiceShimHostAdapter</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.LanguageServiceShimHostAdapter" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.LanguageServiceShimHostAdapter">
        function <span class="apidocSignatureSpan">typescript.</span>LanguageServiceShimHostAdapter
        <span class="apidocSignatureSpan">(shimHost)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LanguageServiceShimHostAdapter(shimHost) {
    var _this = this;
    this.shimHost = shimHost;
    this.loggingEnabled = false;
    this.tracingEnabled = false;
    // if shimHost is a COM object then property check will become method call with no arguments.
    // 'in' does not have this effect.
    if ("getModuleResolutionsForFile" in this.shimHost) {
        this.resolveModuleNames = function (moduleNames, containingFile) {
            var resolutionsInFile = JSON.parse(_this.shimHost.getModuleResolutionsForFile(containingFile));
            return ts.map(moduleNames, function (name) {
                var result = ts.getProperty(resolutionsInFile, name);
                return result ? { resolvedFileName: result, extension: ts.extensionFromPath(result), isExternalLibraryImport: false
 } : undefined;
            });
        };
    }
    if ("directoryExists" in this.shimHost) {
        this.directoryExists = function (directoryName) { return _this.shimHost.directoryExists(directoryName); };
    }
    if ("getTypeReferenceDirectiveResolutionsForFile" in this.shimHost) {
        this.resolveTypeReferenceDirectives = function (typeDirectiveNames, containingFile) {
            var typeDirectivesForFile = JSON.parse(_this.shimHost.getTypeReferenceDirectiveResolutionsForFile(containingFile));
            return ts.map(typeDirectiveNames, function (name) { return ts.getProperty(typeDirectivesForFile, name); });
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.LanguageServiceShimHostAdapter.prototype" id="apidoc.module.typescript.LanguageServiceShimHostAdapter.prototype">module typescript.LanguageServiceShimHostAdapter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.error" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.error">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>error
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (s) {
    this.shimHost.error(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.fileExists" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.fileExists">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>fileExists
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fileExists = function (path) {
    return this.shimHost.fileExists(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getCancellationToken" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getCancellationToken">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getCancellationToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCancellationToken = function () {
    var hostCancellationToken = this.shimHost.getCancellationToken();
    return new ThrottledCancellationToken(hostCancellationToken);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getCompilationSettings" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getCompilationSettings">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getCompilationSettings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCompilationSettings = function () {
    var settingsJson = this.shimHost.getCompilationSettings();
    // TODO: should this be '==='?
    if (settingsJson == null || settingsJson == "") {
        throw Error("LanguageServiceShimHostAdapter.getCompilationSettings: empty compilationSettings");
    }
    var compilerOptions = JSON.parse(settingsJson);
    // permit language service to handle all files (filtering should be performed on the host side)
    compilerOptions.allowNonTsExtensions = true;
    return compilerOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getCurrentDirectory" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getCurrentDirectory">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getCurrentDirectory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCurrentDirectory = function () {
    return this.shimHost.getCurrentDirectory();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getDefaultLibFileName" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getDefaultLibFileName">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getDefaultLibFileName
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefaultLibFileName = function (options) {
    return this.shimHost.getDefaultLibFileName(JSON.stringify(options));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getDirectories" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getDirectories">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getDirectories
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDirectories = function (path) {
    return JSON.parse(this.shimHost.getDirectories(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getLocalizedDiagnosticMessages" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getLocalizedDiagnosticMessages">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getLocalizedDiagnosticMessages
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLocalizedDiagnosticMessages = function () {
    var diagnosticMessagesJson = this.shimHost.getLocalizedDiagnosticMessages();
    if (diagnosticMessagesJson == null || diagnosticMessagesJson == "") {
        return null;
    }
    try {
        return JSON.parse(diagnosticMessagesJson);
    }
    catch (e) {
        this.log(e.description || "diagnosticMessages.generated.json has invalid JSON format");
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getProjectVersion" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getProjectVersion">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getProjectVersion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProjectVersion = function () {
    if (!this.shimHost.getProjectVersion) {
        // shimmed host does not support getProjectVersion
        return undefined;
    }
    return this.shimHost.getProjectVersion();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptFileNames" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptFileNames">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getScriptFileNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getScriptFileNames = function () {
    var encoded = this.shimHost.getScriptFileNames();
    return this.files = JSON.parse(encoded);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptKind" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptKind">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getScriptKind
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getScriptKind = function (fileName) {
    if ("getScriptKind" in this.shimHost) {
        return this.shimHost.getScriptKind(fileName);
    }
    else {
        return 0 /* Unknown */;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptSnapshot" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptSnapshot">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getScriptSnapshot
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getScriptSnapshot = function (fileName) {
    var scriptSnapshot = this.shimHost.getScriptSnapshot(fileName);
    return scriptSnapshot &amp;&amp; new ScriptSnapshotShimAdapter(scriptSnapshot);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptVersion" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getScriptVersion">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getScriptVersion
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getScriptVersion = function (fileName) {
    return this.shimHost.getScriptVersion(fileName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getTypeRootsVersion" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.getTypeRootsVersion">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>getTypeRootsVersion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTypeRootsVersion = function () {
    if (!this.shimHost.getTypeRootsVersion) {
        return 0;
    }
    return this.shimHost.getTypeRootsVersion();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.log" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.log">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>log
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (s) {
    if (this.loggingEnabled) {
        this.shimHost.log(s);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.readDirectory" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.readDirectory">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>readDirectory
        <span class="apidocSignatureSpan">(path, extensions, exclude, include, depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readDirectory = function (path, extensions, exclude, include, depth) {
    var pattern = ts.getFileMatcherPatterns(path, exclude, include, this.shimHost.useCaseSensitiveFileNames(), this.shimHost.getCurrentDirectory
());
    return JSON.parse(this.shimHost.readDirectory(path, JSON.stringify(extensions), JSON.stringify(pattern.basePaths), pattern.excludePattern
, pattern.includeFilePattern, pattern.includeDirectoryPattern, depth));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.readFile" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.readFile">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>readFile
        <span class="apidocSignatureSpan">(path, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFile = function (path, encoding) {
    return this.shimHost.readFile(path, encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.trace" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.trace">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>trace
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function (s) {
    if (this.tracingEnabled) {
        this.shimHost.trace(s);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.useCaseSensitiveFileNames" id="apidoc.element.typescript.LanguageServiceShimHostAdapter.prototype.useCaseSensitiveFileNames">
        function <span class="apidocSignatureSpan">typescript.LanguageServiceShimHostAdapter.prototype.</span>useCaseSensitiveFileNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useCaseSensitiveFileNames = function () {
    return this.shimHost.useCaseSensitiveFileNames ? this.shimHost.useCaseSensitiveFileNames() : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.NavigateTo" id="apidoc.module.typescript.NavigateTo">module typescript.NavigateTo</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.NavigateTo.getNavigateToItems" id="apidoc.element.typescript.NavigateTo.getNavigateToItems">
        function <span class="apidocSignatureSpan">typescript.NavigateTo.</span>getNavigateToItems
        <span class="apidocSignatureSpan">(sourceFiles, checker, cancellationToken, searchValue, maxResultCount, excludeDtsFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNavigateToItems(sourceFiles, checker, cancellationToken, searchValue, maxResultCount, excludeDtsFiles) {
    var patternMatcher = ts.createPatternMatcher(searchValue);
    var rawItems = [];
    var _loop_4 = function (sourceFile) {
        cancellationToken.throwIfCancellationRequested();
        if (excludeDtsFiles &amp;&amp; ts.fileExtensionIs(sourceFile.fileName, ".d.ts")) {
            return "continue";
        }
        ts.forEachEntry(sourceFile.getNamedDeclarations(), function (declarations, name) {
            if (declarations) {
                // First do a quick check to see if the name of the declaration matches the
                // last portion of the (possibly) dotted name they're searching for.
                var matches = patternMatcher.getMatchesForLastSegmentOfPattern(name);
                if (!matches) {
                    return; // continue to next named declarations
                }
                for (var _i = 0, declarations_9 = declarations; _i &lt; declarations_9.length; _i++) {
                    var declaration = declarations_9[_i];
                    // It was a match!  If the pattern has dots in it, then also see if the
                    // declaration container matches as well.
                    if (patternMatcher.patternContainsDots) {
                        var containers = getContainers(declaration);
                        if (!containers) {
                            return true; // Break out of named declarations and go to the next source file.
                        }
                        matches = patternMatcher.getMatches(containers, name);
                        if (!matches) {
                            return; // continue to next named declarations
                        }
                    }
                    var fileName = sourceFile.fileName;
                    var matchKind = bestMatchKind(matches);
                    rawItems.push({ name: name, fileName: fileName, matchKind: matchKind, isCaseSensitive: allMatchesAreCaseSensitive
(matches), declaration: declaration });
                }
            }
        });
    };
    // Search the declarations in all files and output matched NavigateToItem into array of NavigateToItem[]
    for (var _i = 0, sourceFiles_8 = sourceFiles; _i &lt; sourceFiles_8.length; _i++) {
        var sourceFile = sourceFiles_8[_i];
        _loop_4(sourceFile);
    }
    // Remove imports when the imported declaration is already in the list and has the same name.
    rawItems = ts.filter(rawItems, function (item) {
        var decl = item.declaration;
        if (decl.kind === 238 /* ImportClause */ || decl.kind === 241 /* ImportSpecifier */ || decl.kind === 236 /* ImportEqualsDeclaration
 */) {
            var importer = checker.getSymbolAtLocation(decl.name);
            var imported = checker.getAliasedSymbol(importer);
            return importer.name !== imported.name;
        }
        else {
            return true;
        }
    });
    rawItems.sort(compareNavigateToItems);
    if (maxResultCount !== undefined) {
        rawItems = rawItems.slice(0, maxResultCount);
    }
    var items = ts.map(rawItems, createNavigateToItem);
    return items;
    function allMatchesAreCaseSensitive(matches) {
        ts.Debug.assert(matches.length &gt; 0);
        // This is a case sensitive match, only if all the submatches were case sensitive.
        for (var _i = 0, matches_2 = matches; _i &lt; matches_2.length; _i++) {
            var match = matches_2[_i];
            if (!match.isCaseSensitive) {
                return false;
            }
        }
        return true;
    }
    function getTextOfIdentifierOrLiteral(node) {
        if (node) {
            if (node.kind === 70 /* Identifier */ ||
                node.kind === 9 /* StringLiteral */ ||
                node.kind === 8 /* NumericLiteral */) {
                return node.text;
            }
        }
        return undefined;
    }
    function tryAddSingleDeclarationName(declaration, containers) {
        if (declaration &amp;&amp; declaration.name) {
            var text = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.NavigationBar" id="apidoc.module.typescript.NavigationBar">module typescript.NavigationBar</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.NavigationBar.getNavigationBarItems" id="apidoc.element.typescript.NavigationBar.getNavigationBarItems">
        function <span class="apidocSignatureSpan">typescript.NavigationBar.</span>getNavigationBarItems
        <span class="apidocSignatureSpan">(sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNavigationBarItems(sourceFile) {
    curSourceFile = sourceFile;
    var result = ts.map(topLevelItems(rootNavigationBarNode(sourceFile)), convertToTopLevelItem);
    curSourceFile = undefined;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.NavigationBar.getNavigationTree" id="apidoc.element.typescript.NavigationBar.getNavigationTree">
        function <span class="apidocSignatureSpan">typescript.NavigationBar.</span>getNavigationTree
        <span class="apidocSignatureSpan">(sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNavigationTree(sourceFile) {
    curSourceFile = sourceFile;
    var result = convertToTree(rootNavigationBarNode(sourceFile));
    curSourceFile = undefined;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.OutliningElementsCollector" id="apidoc.module.typescript.OutliningElementsCollector">module typescript.OutliningElementsCollector</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.OutliningElementsCollector.collectElements" id="apidoc.element.typescript.OutliningElementsCollector.collectElements">
        function <span class="apidocSignatureSpan">typescript.OutliningElementsCollector.</span>collectElements
        <span class="apidocSignatureSpan">(sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function collectElements(sourceFile) {
    var elements = [];
    var collapseText = "...";
    function addOutliningSpan(hintSpanNode, startElement, endElement, autoCollapse) {
        if (hintSpanNode &amp;&amp; startElement &amp;&amp; endElement) {
            var span_12 = {
                textSpan: ts.createTextSpanFromBounds(startElement.pos, endElement.end),
                hintSpan: ts.createTextSpanFromNode(hintSpanNode, sourceFile),
                bannerText: collapseText,
                autoCollapse: autoCollapse
            };
            elements.push(span_12);
        }
    }
    function addOutliningSpanComments(commentSpan, autoCollapse) {
        if (commentSpan) {
            var span_13 = {
                textSpan: ts.createTextSpanFromBounds(commentSpan.pos, commentSpan.end),
                hintSpan: ts.createTextSpanFromBounds(commentSpan.pos, commentSpan.end),
                bannerText: collapseText,
                autoCollapse: autoCollapse
            };
            elements.push(span_13);
        }
    }
    function addOutliningForLeadingCommentsForNode(n) {
        var comments = ts.getLeadingCommentRangesOfNode(n, sourceFile);
        if (comments) {
            var firstSingleLineCommentStart = -1;
            var lastSingleLineCommentEnd = -1;
            var isFirstSingleLineComment = true;
            var singleLineCommentCount = 0;
            for (var _i = 0, comments_4 = comments; _i &lt; comments_4.length; _i++) {
                var currentComment = comments_4[_i];
                // For single line comments, combine consecutive ones (2 or more) into
                // a single span from the start of the first till the end of the last
                if (currentComment.kind === 2<span class="apidocCodeCommentSpan"> /* SingleLineCommentTrivia */) {
                    if (isFirstSingleLineComment) {
                        firstSingleLineCommentStart = currentComment.pos;
                    }
                    isFirstSingleLineComment = false;
                    lastSingleLineCommentEnd = currentComment.end;
                    singleLineCommentCount++;
                }
                else if (currentComment.kind === 3 /* MultiLineCommentTrivia */) {
                    combineAndAddMultipleSingleLineComments(singleLineCommentCount, firstSingleLineCommentStart, lastSingleLineCommentEnd
);
                    addOutliningSpanComments(currentComment, /*autoCollapse*/ false);
                    singleLineCommentCount = 0;
                    lastSingleLineCommentEnd = -1;
                    isFirstSingleLineComment = true;
                }
            }
            combineAndAddMultipleSingleLineComments(singleLineCommentCount, firstSingleLineCommentStart, lastSingleLineCommentEnd
);
        }
    }
    function combineAndAddMultipleSingleLineComments(count, start, end) {
        // Only outline spans of two or more consecutive single line comments
        if (count &gt; 1) {
            var multipleSingleLineComments = {
                pos: start,
                end: end,
                kind: 2 /* SingleLineCommentTrivia */
</span>            };
            addOutliningSpanComments(multipleSingleLineComments, /*autoCollapse*/ false);
        }
    }
    function autoCollapse(node) {
        return ts.isFunctionBlock(node) &amp;&amp; node.parent.kind !== 186 /* ArrowFunction */;
    }
    var depth = 0;
    var maxDepth = 20;
    function walk(n) {
        if (depth &gt; maxDepth) {
            return;
        }
        if (ts.isDeclaration(n)) {
            addOutliningForLeadingCommentsForNode(n);
        }
        switch (n.kind) {
            case 206 /* Block */:
                if (!ts.isFunctionBlock(n)) {
                    var parent = n.parent;
                    var openBrace = ts.findChildOfKind(n, 16 /* OpenBraceToken */, sourceFile);
                    var closeBrace = ts.findChildOfKind(n, 17 /* CloseBraceToken */, sourceFile);
                    // Check if the block is standalone, or 'attached' to some parent statement.
                    // If the latter, we want to collapse the block, but consider its hint span ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.Rename" id="apidoc.module.typescript.Rename">module typescript.Rename</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.Rename.getRenameInfo" id="apidoc.element.typescript.Rename.getRenameInfo">
        function <span class="apidocSignatureSpan">typescript.Rename.</span>getRenameInfo
        <span class="apidocSignatureSpan">(typeChecker, defaultLibFileName, getCanonicalFileName, sourceFile, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRenameInfo(typeChecker, defaultLibFileName, getCanonicalFileName, sourceFile, position) {
    var getCanonicalDefaultLibName = ts.memoize(function () { return getCanonicalFileName(ts.normalizePath(defaultLibFileName)); });
    var node = ts.getTouchingWord(sourceFile, position, /*includeJsDocComment*/ true);
    var renameInfo = node &amp;&amp; nodeIsEligibleForRename(node)
        ? getRenameInfoForNode(node, typeChecker, sourceFile, isDefinedInLibraryFile)
        : undefined;
    return renameInfo || getRenameInfoError(ts.Diagnostics.You_cannot_rename_this_element);
    function isDefinedInLibraryFile(declaration) {
        if (!defaultLibFileName) {
            return false;
        }
        var sourceFile = declaration.getSourceFile();
        var canonicalName = getCanonicalFileName(ts.normalizePath(sourceFile.fileName));
        return canonicalName === getCanonicalDefaultLibName();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.ScriptSnapshot" id="apidoc.module.typescript.ScriptSnapshot">module typescript.ScriptSnapshot</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.ScriptSnapshot.fromString" id="apidoc.element.typescript.ScriptSnapshot.fromString">
        function <span class="apidocSignatureSpan">typescript.ScriptSnapshot.</span>fromString
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromString(text) {
    return new StringScriptSnapshot(text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.SignatureHelp" id="apidoc.module.typescript.SignatureHelp">module typescript.SignatureHelp</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.SignatureHelp.getContainingArgumentInfo" id="apidoc.element.typescript.SignatureHelp.getContainingArgumentInfo">
        function <span class="apidocSignatureSpan">typescript.SignatureHelp.</span>getContainingArgumentInfo
        <span class="apidocSignatureSpan">(node, position, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getContainingArgumentInfo(node, position, sourceFile) {
    for (var n = node; n.kind !== 263 /* SourceFile */; n = n.parent) {
        if (ts.isFunctionBlock(n)) {
            return undefined;
        }
        // If the node is not a subspan of its parent, this is a big problem.
        // There have been crashes that might be caused by this violation.
        if (n.pos &lt; n.parent.pos || n.end &gt; n.parent.end) {
            ts.Debug.fail("Node of kind " + n.kind + " is not a subspan of its parent of kind " + n.parent.kind);
        }
        var argumentInfo = getImmediatelyContainingArgumentInfo(n, position, sourceFile);
        if (argumentInfo) {
            return argumentInfo;
        }
        // TODO: Handle generic call with incomplete syntax
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.SignatureHelp.getImmediatelyContainingArgumentInfo" id="apidoc.element.typescript.SignatureHelp.getImmediatelyContainingArgumentInfo">
        function <span class="apidocSignatureSpan">typescript.SignatureHelp.</span>getImmediatelyContainingArgumentInfo
        <span class="apidocSignatureSpan">(node, position, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getImmediatelyContainingArgumentInfo(node, position, sourceFile) {
    if (node.parent.kind === 180 /* CallExpression */ || node.parent.kind === 181 /* NewExpression */) {
        var callExpression = node.parent;
        // There are 3 cases to handle:
        //   1. The token introduces a list, and should begin a sig help session
        //   2. The token is either not associated with a list, or ends a list, so the session should end
        //   3. The token is buried inside a list, and should give sig help
        //
        // The following are examples of each:
        //
        //    Case 1:
        //          foo&lt;#T, U&gt;(#a, b)    -&gt; The token introduces a list, and should begin a sig help session
        //    Case 2:
        //          fo#o&lt;T, U&gt;#(a, b)#   -&gt; The token is either not associated with a list, or ends a list, so the session should
 end
        //    Case 3:
        //          foo&lt;T#, U#&gt;(a#, #b#) -&gt; The token is buried inside a list, and should give sig help
        // Find out if 'node' is an argument, a type argument, or neither
        if (node.kind === 26 /* LessThanToken */ ||
            node.kind === 18 /* OpenParenToken */) {
            // Find the list that starts right *after* the &lt; or ( token.
            // If the user has just opened a list, consider this item 0.
            var list = getChildListThatStartsWithOpenerToken(callExpression, node, sourceFile);
            var isTypeArgList = callExpression.typeArguments &amp;&amp; callExpression.typeArguments.pos === list.pos;
            ts.Debug.assert(list !== undefined);
            return {
                kind: isTypeArgList ? 0 /* TypeArguments */ : 1 /* CallArguments */,
                invocation: callExpression,
                argumentsSpan: getApplicableSpanForArguments(list, sourceFile),
                argumentIndex: 0,
                argumentCount: getArgumentCount(list)
            };
        }
        // findListItemInfo can return undefined if we are not in parent's argument list
        // or type argument list. This includes cases where the cursor is:
        //   - To the right of the closing paren, non-substitution template, or template tail.
        //   - Between the type arguments and the arguments (greater than token)
        //   - On the target of the call (parent.func)
        //   - On the 'new' keyword in a 'new' expression
        var listItemInfo = ts.findListItemInfo(node);
        if (listItemInfo) {
            var list = listItemInfo.list;
            var isTypeArgList = callExpression.typeArguments &amp;&amp; callExpression.typeArguments.pos === list.pos;
            var argumentIndex = getArgumentIndex(list, node);
            var argumentCount = getArgumentCount(list);
            ts.Debug.assert(argumentIndex === 0 || argumentIndex &lt; argumentCount, "argumentCount &lt; argumentIndex, " + argumentCount
 + " &lt; " + argumentIndex);
            return {
                kind: isTypeArgList ? 0 /* TypeArguments */ : 1 /* CallArguments */,
                invocation: callExpression,
                argumentsSpan: getApplicableSpanForArguments(list, sourceFile),
                argumentIndex: argumentIndex,
                argumentCount: argumentCount
            };
        }
        return undefined;
    }
    else if (node.kind === 12 /* NoSubstitutionTemplateLiteral */ &amp;&amp; node.parent.kind === 182 /* TaggedTemplateExpression */) {
        // Check if we're actually inside the template;
        // otherwise we'll fall out and return undefined.
        if (ts.isInsideTemplateLiteral(node, position)) {
            return getArgumentListInfoForTemplate(node.parent, /*argumentIndex*/ 0, sourceFile);
        }
    }
    else if (node.kind === 13 /* TemplateHead */ &amp;&amp; node.parent.parent.kind === 182 /* TaggedTemplateExpression */) {
        var templateExpression = node.parent;
        var tagExpression = templateExpression.parent;
        ts.Debug.assert(templateExpression.kind === 195 /* TemplateExpression */);
        var argumentIndex = ts.isInsideTemplateLiteral(node, position) ? 0 : 1;
        return getArgumen ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.SignatureHelp.getSignatureHelpItems" id="apidoc.element.typescript.SignatureHelp.getSignatureHelpItems">
        function <span class="apidocSignatureSpan">typescript.SignatureHelp.</span>getSignatureHelpItems
        <span class="apidocSignatureSpan">(program, sourceFile, position, cancellationToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSignatureHelpItems(program, sourceFile, position, cancellationToken) {
    var typeChecker = program.getTypeChecker();
    // Decide whether to show signature help
    var startingToken = ts.findTokenOnLeftOfPosition(sourceFile, position);
    if (!startingToken) {
        // We are at the beginning of the file
        return undefined;
    }
    var argumentInfo = getContainingArgumentInfo(startingToken, position, sourceFile);
    cancellationToken.throwIfCancellationRequested();
    // Semantic filtering of signature help
    if (!argumentInfo) {
        return undefined;
    }
    var call = argumentInfo.invocation;
    var candidates = [];
    var resolvedSignature = typeChecker.getResolvedSignature(call, candidates);
    cancellationToken.throwIfCancellationRequested();
    if (!candidates.length) {
        // We didn't have any sig help items produced by the TS compiler.  If this is a JS
        // file, then see if we can figure out anything better.
        if (ts.isSourceFileJavaScript(sourceFile)) {
            return createJavaScriptSignatureHelpItems(argumentInfo, program);
        }
        return undefined;
    }
    return createSignatureHelpItems(candidates, resolvedSignature, argumentInfo, typeChecker);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.SymbolDisplay" id="apidoc.module.typescript.SymbolDisplay">module typescript.SymbolDisplay</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind" id="apidoc.element.typescript.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind">
        function <span class="apidocSignatureSpan">typescript.SymbolDisplay.</span>getSymbolDisplayPartsDocumentationAndSymbolKind
        <span class="apidocSignatureSpan">(typeChecker, symbol, sourceFile, enclosingDeclaration, location, semanticMeaning )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSymbolDisplayPartsDocumentationAndSymbolKind(typeChecker, symbol, sourceFile, enclosingDeclaration, location, semanticMeaning ) {
    if (semanticMeaning === void 0) { semanticMeaning = ts.getMeaningFromLocation(location); }
    var displayParts = [];
    var documentation;
    var symbolFlags = symbol.flags;
    var symbolKind = getSymbolKindOfConstructorPropertyMethodAccessorFunctionOrVar(typeChecker, symbol, symbolFlags, location);
    var hasAddedSymbolInfo;
    var isThisExpression = location.kind === 98 /* ThisKeyword */ &amp;&amp; ts.isExpression(location);
    var type;
    // Class at constructor site need to be shown as constructor apart from property,method, vars
    if (symbolKind !== ts.ScriptElementKind.unknown || symbolFlags &amp; 32 /* Class */ || symbolFlags &amp; 8388608 /* Alias */) {
        // If it is accessor they are allowed only if location is at name of the accessor
        if (symbolKind === ts.ScriptElementKind.memberGetAccessorElement || symbolKind === ts.ScriptElementKind.memberSetAccessorElement
) {
            symbolKind = ts.ScriptElementKind.memberVariableElement;
        }
        var signature = void 0;
        type = isThisExpression ? typeChecker.getTypeAtLocation(location) : typeChecker.getTypeOfSymbolAtLocation(symbol, location
);
        if (type) {
            if (location.parent &amp;&amp; location.parent.kind === 178 /* PropertyAccessExpression */) {
                var right = location.parent.name;
                // Either the location is on the right of a property access, or on the left and the right is missing
                if (right === location || (right &amp;&amp; right.getFullWidth() === 0)) {
                    location = location.parent;
                }
            }
            // try get the call/construct signature from the type if it matches
            var callExpression = void 0;
            if (location.kind === 180 /* CallExpression */ || location.kind === 181 /* NewExpression */) {
                callExpression = location;
            }
            else if (ts.isCallExpressionTarget(location) || ts.isNewExpressionTarget(location)) {
                callExpression = location.parent;
            }
            if (callExpression) {
                var candidateSignatures = [];
                signature = typeChecker.getResolvedSignature(callExpression, candidateSignatures);
                if (!signature &amp;&amp; candidateSignatures.length) {
                    // Use the first candidate:
                    signature = candidateSignatures[0];
                }
                var useConstructSignatures = callExpression.kind === 181 /* NewExpression */ || callExpression.expression.kind ===
96 /* SuperKeyword */;
                var allSignatures = useConstructSignatures ? type.getConstructSignatures() : type.getCallSignatures();
                if (!ts.contains(allSignatures, signature.target) &amp;&amp; !ts.contains(allSignatures, signature)) {
                    // Get the first signature if there is one -- allSignatures may contain
                    // either the original signature or its target, so check for either
                    signature = allSignatures.length ? allSignatures[0] : undefined;
                }
                if (signature) {
                    if (useConstructSignatures &amp;&amp; (symbolFlags &amp; 32 /* Class */)) {
                        // Constructor
                        symbolKind = ts.ScriptElementKind.constructorImplementationElement;
                        addPrefixForAnyFunctionOrVar(type.symbol, symbolKind);
                    }
                    else if (symbolFlags &amp; 8388608 /* Alias */) {
                        symbolKind = ts.ScriptElementKind.alias;
                        pushTypePart(symbolKind);
                        displayParts.push(ts.spacePart());
                        if (useConstructSignatures) {
                            displayParts.push(ts.keywordPart(93 /* NewKeyword */));
                            displayParts.push(ts.spacePart());
                        }
                        addFullSymbolName(symbol); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.SymbolDisplay.getSymbolKind" id="apidoc.element.typescript.SymbolDisplay.getSymbolKind">
        function <span class="apidocSignatureSpan">typescript.SymbolDisplay.</span>getSymbolKind
        <span class="apidocSignatureSpan">(typeChecker, symbol, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSymbolKind(typeChecker, symbol, location) {
    var flags = symbol.getFlags();
    if (flags &amp; 32 /* Class */)
        return ts.getDeclarationOfKind(symbol, 198 /* ClassExpression */) ?
            ts.ScriptElementKind.localClassElement : ts.ScriptElementKind.classElement;
    if (flags &amp; 384 /* Enum */)
        return ts.ScriptElementKind.enumElement;
    if (flags &amp; 524288 /* TypeAlias */)
        return ts.ScriptElementKind.typeElement;
    if (flags &amp; 64 /* Interface */)
        return ts.ScriptElementKind.interfaceElement;
    if (flags &amp; 262144 /* TypeParameter */)
        return ts.ScriptElementKind.typeParameterElement;
    var result = getSymbolKindOfConstructorPropertyMethodAccessorFunctionOrVar(typeChecker, symbol, flags, location);
    if (result === ts.ScriptElementKind.unknown) {
        if (flags &amp; 262144 /* TypeParameter */)
            return ts.ScriptElementKind.typeParameterElement;
        if (flags &amp; 8 /* EnumMember */)
            return ts.ScriptElementKind.variableElement;
        if (flags &amp; 8388608 /* Alias */)
            return ts.ScriptElementKind.alias;
        if (flags &amp; 1536 /* Module */)
            return ts.ScriptElementKind.moduleElement;
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.SymbolDisplay.getSymbolModifiers" id="apidoc.element.typescript.SymbolDisplay.getSymbolModifiers">
        function <span class="apidocSignatureSpan">typescript.SymbolDisplay.</span>getSymbolModifiers
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSymbolModifiers(symbol) {
    return symbol &amp;&amp; symbol.declarations &amp;&amp; symbol.declarations.length &gt; 0
        ? ts.getNodeModifiers(symbol.declarations[0])
        : ts.ScriptElementKindModifier.none;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.TypeScriptServicesFactory" id="apidoc.module.typescript.TypeScriptServicesFactory">module typescript.TypeScriptServicesFactory</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.TypeScriptServicesFactory.TypeScriptServicesFactory" id="apidoc.element.typescript.TypeScriptServicesFactory.TypeScriptServicesFactory">
        function <span class="apidocSignatureSpan">typescript.</span>TypeScriptServicesFactory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TypeScriptServicesFactory() {
    this._shims = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.TypeScriptServicesFactory.prototype" id="apidoc.module.typescript.TypeScriptServicesFactory.prototype">module typescript.TypeScriptServicesFactory.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.close" id="apidoc.element.typescript.TypeScriptServicesFactory.prototype.close">
        function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    // Forget all the registered shims
    this._shims = [];
    this.documentRegistry = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.createClassifierShim" id="apidoc.element.typescript.TypeScriptServicesFactory.prototype.createClassifierShim">
        function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>createClassifierShim
        <span class="apidocSignatureSpan">(logger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createClassifierShim = function (logger) {
    try {
        return new ClassifierShimObject(this, logger);
    }
    catch (err) {
        logInternalError(logger, err);
        throw err;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.createCoreServicesShim" id="apidoc.element.typescript.TypeScriptServicesFactory.prototype.createCoreServicesShim">
        function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>createCoreServicesShim
        <span class="apidocSignatureSpan">(host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCoreServicesShim = function (host) {
    try {
        var adapter = new CoreServicesShimHostAdapter(host);
        return new CoreServicesShimObject(this, host, adapter);
    }
    catch (err) {
        logInternalError(host, err);
        throw err;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.createLanguageServiceShim" id="apidoc.element.typescript.TypeScriptServicesFactory.prototype.createLanguageServiceShim">
        function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>createLanguageServiceShim
        <span class="apidocSignatureSpan">(host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createLanguageServiceShim = function (host) {
    try {
        if (this.documentRegistry === undefined) {
            this.documentRegistry = ts.createDocumentRegistry(host.useCaseSensitiveFileNames &amp;&amp; host.useCaseSensitiveFileNames(),
host.getCurrentDirectory());
        }
        var hostAdapter = new LanguageServiceShimHostAdapter(host);
        var languageService = ts.createLanguageService(hostAdapter, this.documentRegistry);
        return new LanguageServiceShimObject(this, host, languageService);
    }
    catch (err) {
        logInternalError(host, err);
        throw err;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.getServicesVersion" id="apidoc.element.typescript.TypeScriptServicesFactory.prototype.getServicesVersion">
        function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>getServicesVersion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getServicesVersion = function () {
    return ts.servicesVersion;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.registerShim" id="apidoc.element.typescript.TypeScriptServicesFactory.prototype.registerShim">
        function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>registerShim
        <span class="apidocSignatureSpan">(shim)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerShim = function (shim) {
    this._shims.push(shim);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.TypeScriptServicesFactory.prototype.unregisterShim" id="apidoc.element.typescript.TypeScriptServicesFactory.prototype.unregisterShim">
        function <span class="apidocSignatureSpan">typescript.TypeScriptServicesFactory.prototype.</span>unregisterShim
        <span class="apidocSignatureSpan">(shim)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unregisterShim = function (shim) {
    for (var i = 0; i &lt; this._shims.length; i++) {
        if (this._shims[i] === shim) {
            delete this._shims[i];
            return;
        }
    }
    throw new Error("Invalid operation");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.codefix" id="apidoc.module.typescript.codefix">module typescript.codefix</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.codefix.getFixes" id="apidoc.element.typescript.codefix.getFixes">
        function <span class="apidocSignatureSpan">typescript.codefix.</span>getFixes
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFixes(context) {
    var fixes = codeFixes[context.errorCode];
    var allActions = [];
    ts.forEach(fixes, function (f) {
        var actions = f.getCodeActions(context);
        if (actions &amp;&amp; actions.length &gt; 0) {
            allActions = allActions.concat(actions);
        }
    });
    return allActions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.codefix.getMissingMembersInsertion" id="apidoc.element.typescript.codefix.getMissingMembersInsertion">
        function <span class="apidocSignatureSpan">typescript.codefix.</span>getMissingMembersInsertion
        <span class="apidocSignatureSpan">(classDeclaration, possiblyMissingSymbols, checker, newlineChar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMissingMembersInsertion(classDeclaration, possiblyMissingSymbols, checker, newlineChar) {
    var classMembers = classDeclaration.symbol.members;
    var missingMembers = possiblyMissingSymbols.filter(function (symbol) { return !classMembers.has(symbol.getName()); });
    var insertion = "";
    for (var _i = 0, missingMembers_1 = missingMembers; _i &lt; missingMembers_1.length; _i++) {
        var symbol = missingMembers_1[_i];
        insertion = insertion.concat(getInsertionForMemberSymbol(symbol, classDeclaration, checker, newlineChar));
    }
    return insertion;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.codefix.getStubbedMethod" id="apidoc.element.typescript.codefix.getStubbedMethod">
        function <span class="apidocSignatureSpan">typescript.codefix.</span>getStubbedMethod
        <span class="apidocSignatureSpan">(visibility, name, sigString, newlineChar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStubbedMethod(visibility, name, sigString, newlineChar) {
    if (sigString === void 0) { sigString = "()"; }
    return "" + visibility + name + sigString + getMethodBodyStub(newlineChar);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.codefix.getSupportedErrorCodes" id="apidoc.element.typescript.codefix.getSupportedErrorCodes">
        function <span class="apidocSignatureSpan">typescript.codefix.</span>getSupportedErrorCodes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSupportedErrorCodes() {
    return Object.keys(codeFixes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.codefix.registerCodeFix" id="apidoc.element.typescript.codefix.registerCodeFix">
        function <span class="apidocSignatureSpan">typescript.codefix.</span>registerCodeFix
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function registerCodeFix(action) {
    ts.forEach(action.errorCodes, function (error) {
        var fixes = codeFixes[error];
        if (!fixes) {
            fixes = [];
            codeFixes[error] = fixes;
        }
        fixes.push(action);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting" id="apidoc.module.typescript.formatting">module typescript.formatting</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext" id="apidoc.element.typescript.formatting.FormattingContext">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>FormattingContext
        <span class="apidocSignatureSpan">(sourceFile, formattingRequestKind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FormattingContext(sourceFile, formattingRequestKind) {
    this.sourceFile = sourceFile;
    this.formattingRequestKind = formattingRequestKind;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rule" id="apidoc.element.typescript.formatting.Rule">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>Rule
        <span class="apidocSignatureSpan">(Descriptor, Operation, Flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Rule(Descriptor, Operation, Flag) {
    if (Flag === void 0) { Flag = 0 /* None */; }
    this.Descriptor = Descriptor;
    this.Operation = Operation;
    this.Flag = Flag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleDescriptor" id="apidoc.element.typescript.formatting.RuleDescriptor">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleDescriptor
        <span class="apidocSignatureSpan">(LeftTokenRange, RightTokenRange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleDescriptor(LeftTokenRange, RightTokenRange) {
    this.LeftTokenRange = LeftTokenRange;
    this.RightTokenRange = RightTokenRange;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperation" id="apidoc.element.typescript.formatting.RuleOperation">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleOperation
        <span class="apidocSignatureSpan">(Context, Action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleOperation(Context, Action) {
    this.Context = Context;
    this.Action = Action;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperationContext" id="apidoc.element.typescript.formatting.RuleOperationContext">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleOperationContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleOperationContext() {
    var funcs = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        funcs[_i] = arguments[_i];
    }
    this.customContextChecks = funcs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules" id="apidoc.element.typescript.formatting.Rules">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>Rules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Rules() {
    ///
    /// Common Rules
    ///
    // Leave comments alone
    this.IgnoreBeforeComment = new formatting.Rule(formatting.RuleDescriptor.create4(formatting.Shared.TokenRange.Any, formatting
.Shared.TokenRange.Comments), formatting.RuleOperation.create1(1 /* Ignore */));
    this.IgnoreAfterLineComment = new formatting.Rule(formatting.RuleDescriptor.create3(2 /* SingleLineCommentTrivia */, formatting
.Shared.TokenRange.Any), formatting.RuleOperation.create1(1 /* Ignore */));
    // Space after keyword but not before ; or : or ?
    this.NoSpaceBeforeSemicolon = new formatting.Rule(formatting.RuleDescriptor.create2(formatting.Shared.TokenRange.Any, 24 /*
SemicolonToken */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 8 /*
Delete */));
    this.NoSpaceBeforeColon = new formatting.Rule(formatting.RuleDescriptor.create2(formatting.Shared.TokenRange.Any, 55 /* ColonToken
 */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules.IsNotBinaryOpContext
), 8 /* Delete */));
    this.NoSpaceBeforeQuestionMark = new formatting.Rule(formatting.RuleDescriptor.create2(formatting.Shared.TokenRange.Any, 54 /*
QuestionToken */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules
.IsNotBinaryOpContext), 8 /* Delete */));
    this.SpaceAfterColon = new formatting.Rule(formatting.RuleDescriptor.create3(55 /* ColonToken */, formatting.Shared.TokenRange
.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules.IsNotBinaryOpContext
), 2 /* Space */));
    this.SpaceAfterQuestionMarkInConditionalOperator = new formatting.Rule(formatting.RuleDescriptor.create3(54 /* QuestionToken
 */, formatting.Shared.TokenRange.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext
, Rules.IsConditionalOperatorContext), 2 /* Space */));
    this.NoSpaceAfterQuestionMark = new formatting.Rule(formatting.RuleDescriptor.create3(54 /* QuestionToken */, formatting.Shared
.TokenRange.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 8 /*
Delete */));
    this.SpaceAfterSemicolon = new formatting.Rule(formatting.RuleDescriptor.create3(24 /* SemicolonToken */, formatting.Shared.
TokenRange.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 2 /*
Space */));
    // Space after }.
    this.SpaceAfterCloseBrace = new formatting.Rule(formatting.RuleDescriptor.create3(17 /* CloseBraceToken */, formatting.Shared
.TokenRange.FromRange(0 /* FirstToken */, 141 /* LastToken */, [19 /* CloseParenToken */])), formatting.RuleOperation.create2(new
 formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules.IsAfterCodeBlockContext), 2 /* Space */));
    // Special case for (}, else) and (}, while) since else &amp; while tokens are not part of the tree which makes SpaceAfterCloseBrace
 rule not applied
    this.SpaceBetweenCloseBraceAndElse = new formatting.Rule(formatting.RuleDescriptor.create1(17 /* CloseBraceToken */, 81 /* ElseKeyword
 */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 2 /* Space */));
    this.SpaceBetweenCloseBraceAndWhile = new formatting.Rule(formatting.RuleDescriptor.create1(17 /* CloseBraceToken */, 105 /*
WhileKeyword */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 2 /*
Space */));
    this.NoSpaceAfterCloseBrace = new formatting.Rule(formatting.RuleDescriptor.create3(17 /* CloseBraceToken */, formatting.Shared
.TokenRange.FromTokens([21 /* CloseBracketToken */, 25 /* CommaToken */, 24 /* SemicolonToken */])), formatting.RuleOperation.create2
(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 8 /* Delete */));
    // No space for dot
    this.NoSpaceBeforeDot = ne ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucket" id="apidoc.element.typescript.formatting.RulesBucket">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesBucket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesBucket() {
    this.rules = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucketConstructionState" id="apidoc.element.typescript.formatting.RulesBucketConstructionState">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesBucketConstructionState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesBucketConstructionState() {
    //// The Rules list contains all the inserted rules into a rulebucket in the following order:
    ////    1- Ignore rules with specific token combination
    ////    2- Ignore rules with any token combination
    ////    3- Context rules with specific token combination
    ////    4- Context rules with any token combination
    ////    5- Non-context rules with specific token combination
    ////    6- Non-context rules with any token combination
    ////
    //// The member rulesInsertionIndexBitmap is used to describe the number of rules
    //// in each sub-bucket (above) hence can be used to know the index of where to insert
    //// the next rule. It's a bitmap which contains 6 different sections each is given 5 bits.
    ////
    //// Example:
    //// In order to insert a rule to the end of sub-bucket (3), we get the index by adding
    //// the values in the bitmap segments 3rd, 2nd, and 1st.
    this.rulesInsertionIndexBitmap = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesMap" id="apidoc.element.typescript.formatting.RulesMap">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesMap() {
    this.map = [];
    this.mapRowLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesProvider" id="apidoc.element.typescript.formatting.RulesProvider">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesProvider
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesProvider() {
    this.globalRules = new formatting.Rules();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.formatDocument" id="apidoc.element.typescript.formatting.formatDocument">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>formatDocument
        <span class="apidocSignatureSpan">(sourceFile, rulesProvider, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatDocument(sourceFile, rulesProvider, options) {
    var span = {
        pos: 0,
        end: sourceFile.text.length
    };
    return formatSpan(span, sourceFile, options, rulesProvider, 0 /* FormatDocument */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.formatOnClosingCurly" id="apidoc.element.typescript.formatting.formatOnClosingCurly">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>formatOnClosingCurly
        <span class="apidocSignatureSpan">(position, sourceFile, rulesProvider, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatOnClosingCurly(position, sourceFile, rulesProvider, options) {
    return formatOutermostParent(position, 17 /* CloseBraceToken */, sourceFile, options, rulesProvider, 4 /* FormatOnClosingCurlyBrace
 */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.formatOnEnter" id="apidoc.element.typescript.formatting.formatOnEnter">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>formatOnEnter
        <span class="apidocSignatureSpan">(position, sourceFile, rulesProvider, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatOnEnter(position, sourceFile, rulesProvider, options) {
    var line = sourceFile.getLineAndCharacterOfPosition(position).line;
    if (line === 0) {
        return [];
    }
    // After the enter key, the cursor is now at a new line. The new line may or may not contain non-whitespace characters.
    // If the new line has only whitespaces, we won't want to format this line, because that would remove the indentation as
    // trailing whitespaces. So the end of the formatting span should be the later one between:
    //  1. the end of the previous line
    //  2. the last non-whitespace character in the current line
    var endOfFormatSpan = ts.getEndLinePosition(line, sourceFile);
    while (ts.isWhiteSpaceSingleLine(sourceFile.text.charCodeAt(endOfFormatSpan))) {
        endOfFormatSpan--;
    }
    // if the character at the end of the span is a line break, we shouldn't include it, because it indicates we don't want to
    // touch the current line at all. Also, on some OSes the line break consists of two characters (\r\n), we should test if the
    // previous character before the end of format span is line break character as well.
    if (ts.isLineBreak(sourceFile.text.charCodeAt(endOfFormatSpan))) {
        endOfFormatSpan--;
    }
    var span = {
        // get start position for the previous line
        pos: ts.getStartPositionOfLine(line - 1, sourceFile),
        // end value is exclusive so add 1 to the result
        end: endOfFormatSpan + 1
    };
    return formatSpan(span, sourceFile, options, rulesProvider, 2 /* FormatOnEnter */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.formatOnSemicolon" id="apidoc.element.typescript.formatting.formatOnSemicolon">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>formatOnSemicolon
        <span class="apidocSignatureSpan">(position, sourceFile, rulesProvider, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatOnSemicolon(position, sourceFile, rulesProvider, options) {
    return formatOutermostParent(position, 24 /* SemicolonToken */, sourceFile, options, rulesProvider, 3 /* FormatOnSemicolon */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.formatSelection" id="apidoc.element.typescript.formatting.formatSelection">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>formatSelection
        <span class="apidocSignatureSpan">(start, end, sourceFile, rulesProvider, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatSelection(start, end, sourceFile, rulesProvider, options) {
    // format from the beginning of the line
    var span = {
        pos: ts.getLineStartPositionForPosition(start, sourceFile),
        end: end
    };
    return formatSpan(span, sourceFile, options, rulesProvider, 1 /* FormatSelection */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.getFormattingScanner" id="apidoc.element.typescript.formatting.getFormattingScanner">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>getFormattingScanner
        <span class="apidocSignatureSpan">(sourceFile, startPos, endPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFormattingScanner(sourceFile, startPos, endPos) {
    ts.Debug.assert(scanner === undefined, "Scanner should be undefined");
    scanner = sourceFile.languageVariant === 1 /* JSX */ ? jsxScanner : standardScanner;
    scanner.setText(sourceFile.text);
    scanner.setTextPos(startPos);
    var wasNewLine = true;
    var leadingTrivia;
    var trailingTrivia;
    var savedPos;
    var lastScanAction;
    var lastTokenInfo;
    return {
        advance: advance,
        readTokenInfo: readTokenInfo,
        isOnToken: isOnToken,
        getCurrentLeadingTrivia: function () { return leadingTrivia; },
        lastTrailingTriviaWasNewLine: function () { return wasNewLine; },
        skipToEndOf: skipToEndOf,
        close: function () {
            ts.Debug.assert(scanner !== undefined);
            lastTokenInfo = undefined;
            scanner.setText(undefined);
            scanner = undefined;
        }
    };
    function advance() {
        ts.Debug.assert(scanner !== undefined, "Scanner should be present");
        lastTokenInfo = undefined;
        var isStarted = scanner.getStartPos() !== startPos;
        if (isStarted) {
            if (trailingTrivia) {
                ts.Debug.assert(trailingTrivia.length !== 0);
                wasNewLine = ts.lastOrUndefined(trailingTrivia).kind === 4 /* NewLineTrivia */;
            }
            else {
                wasNewLine = false;
            }
        }
        leadingTrivia = undefined;
        trailingTrivia = undefined;
        if (!isStarted) {
            scanner.scan();
        }
        var pos = scanner.getStartPos();
        // Read leading trivia and token
        while (pos &lt; endPos) {
            var t = scanner.getToken();
            if (!ts.isTrivia(t)) {
                break;
            }
            // consume leading trivia
            scanner.scan();
            var item = {
                pos: pos,
                end: scanner.getStartPos(),
                kind: t
            };
            pos = scanner.getStartPos();
            if (!leadingTrivia) {
                leadingTrivia = [];
            }
            leadingTrivia.push(item);
        }
        savedPos = scanner.getStartPos();
    }
    function shouldRescanGreaterThanToken(node) {
        if (node) {
            switch (node.kind) {
                case 30 /* GreaterThanEqualsToken */:
                case 65 /* GreaterThanGreaterThanEqualsToken */:
                case 66 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 46 /* GreaterThanGreaterThanGreaterThanToken */:
                case 45 /* GreaterThanGreaterThanToken */:
                    return true;
            }
        }
        return false;
    }
    function shouldRescanJsxIdentifier(node) {
        if (node.parent) {
            switch (node.parent.kind) {
                case 252 /* JsxAttribute */:
                case 250 /* JsxOpeningElement */:
                case 251 /* JsxClosingElement */:
                case 249 /* JsxSelfClosingElement */:
                    return node.kind === 70 /* Identifier */;
            }
        }
        return false;
    }
    function shouldRescanJsxText(node) {
        return node &amp;&amp; node.kind === 10 /* JsxText */;
    }
    function shouldRescanSlashToken(container) {
        return container.kind === 11 /* RegularExpressionLiteral */;
    }
    function shouldRescanTemplateToken(container) {
        return container.kind === 14 /* TemplateMiddle */ ||
            container.kind === 15 /* TemplateTail */;
    }
    function startsWithSlashToken(t) {
        return t === 40 /* SlashToken */ || t === 62 /* SlashEqualsToken */;
    }
    function readTokenInfo(n) {
        ts.Debug.assert(scanner !== undefined);
        if (!isOnToken()) {
            // scanner is not on the token (either advance was not called yet or scanner is already past the end position)
            return {
                leadingTrivia: leadingTrivia,
                trailingTrivia: undefined,
                token: undefined
            };
        }
        // norm ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.getIndentationString" id="apidoc.element.typescript.formatting.getIndentationString">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>getIndentationString
        <span class="apidocSignatureSpan">(indentation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getIndentationString(indentation, options) {
    // reset interned strings if FormatCodeOptions were changed
    var resetInternedStrings = !internedSizes || (internedSizes.tabSize !== options.tabSize || internedSizes.indentSize !== options
.indentSize);
    if (resetInternedStrings) {
        internedSizes = { tabSize: options.tabSize, indentSize: options.indentSize };
        internedTabsIndentation = internedSpacesIndentation = undefined;
    }
    if (!options.convertTabsToSpaces) {
        var tabs = Math.floor(indentation / options.tabSize);
        var spaces = indentation - tabs * options.tabSize;
        var tabString = void 0;
        if (!internedTabsIndentation) {
            internedTabsIndentation = [];
        }
        if (internedTabsIndentation[tabs] === undefined) {
            internedTabsIndentation[tabs] = tabString = repeat("\t", tabs);
        }
        else {
            tabString = internedTabsIndentation[tabs];
        }
        return spaces ? tabString + repeat(" ", spaces) : tabString;
    }
    else {
        var spacesString = void 0;
        var quotient = Math.floor(indentation / options.indentSize);
        var remainder = indentation % options.indentSize;
        if (!internedSpacesIndentation) {
            internedSpacesIndentation = [];
        }
        if (internedSpacesIndentation[quotient] === undefined) {
            spacesString = repeat(" ", options.indentSize * quotient);
            internedSpacesIndentation[quotient] = spacesString;
        }
        else {
            spacesString = internedSpacesIndentation[quotient];
        }
        return remainder ? spacesString + repeat(" ", remainder) : spacesString;
    }
    function repeat(value, count) {
        var s = "";
        for (var i = 0; i &lt; count; i++) {
            s += value;
        }
        return s;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.FormattingContext" id="apidoc.module.typescript.formatting.FormattingContext">module typescript.formatting.FormattingContext</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext.FormattingContext" id="apidoc.element.typescript.formatting.FormattingContext.FormattingContext">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>FormattingContext
        <span class="apidocSignatureSpan">(sourceFile, formattingRequestKind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FormattingContext(sourceFile, formattingRequestKind) {
    this.sourceFile = sourceFile;
    this.formattingRequestKind = formattingRequestKind;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.FormattingContext.prototype" id="apidoc.module.typescript.formatting.FormattingContext.prototype">module typescript.formatting.FormattingContext.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext.prototype.BlockIsOnOneLine" id="apidoc.element.typescript.formatting.FormattingContext.prototype.BlockIsOnOneLine">
        function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>BlockIsOnOneLine
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BlockIsOnOneLine = function (node) {
    var openBrace = ts.findChildOfKind(node, 16 /* OpenBraceToken */, this.sourceFile);
    var closeBrace = ts.findChildOfKind(node, 17 /* CloseBraceToken */, this.sourceFile);
    if (openBrace &amp;&amp; closeBrace) {
        var startLine = this.sourceFile.getLineAndCharacterOfPosition(openBrace.getEnd()).line;
        var endLine = this.sourceFile.getLineAndCharacterOfPosition(closeBrace.getStart(this.sourceFile)).line;
        return startLine === endLine;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext.prototype.ContextNodeAllOnSameLine" id="apidoc.element.typescript.formatting.FormattingContext.prototype.ContextNodeAllOnSameLine">
        function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>ContextNodeAllOnSameLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContextNodeAllOnSameLine = function () {
    if (this.contextNodeAllOnSameLine === undefined) {
        this.contextNodeAllOnSameLine = this.NodeIsOnOneLine(this.contextNode);
    }
    return this.contextNodeAllOnSameLine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext.prototype.ContextNodeBlockIsOnOneLine" id="apidoc.element.typescript.formatting.FormattingContext.prototype.ContextNodeBlockIsOnOneLine">
        function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>ContextNodeBlockIsOnOneLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContextNodeBlockIsOnOneLine = function () {
    if (this.contextNodeBlockIsOnOneLine === undefined) {
        this.contextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.contextNode);
    }
    return this.contextNodeBlockIsOnOneLine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext.prototype.NextNodeAllOnSameLine" id="apidoc.element.typescript.formatting.FormattingContext.prototype.NextNodeAllOnSameLine">
        function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>NextNodeAllOnSameLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NextNodeAllOnSameLine = function () {
    if (this.nextNodeAllOnSameLine === undefined) {
        this.nextNodeAllOnSameLine = this.NodeIsOnOneLine(this.nextTokenParent);
    }
    return this.nextNodeAllOnSameLine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext.prototype.NextNodeBlockIsOnOneLine" id="apidoc.element.typescript.formatting.FormattingContext.prototype.NextNodeBlockIsOnOneLine">
        function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>NextNodeBlockIsOnOneLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NextNodeBlockIsOnOneLine = function () {
    if (this.nextNodeBlockIsOnOneLine === undefined) {
        this.nextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.nextTokenParent);
    }
    return this.nextNodeBlockIsOnOneLine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext.prototype.NodeIsOnOneLine" id="apidoc.element.typescript.formatting.FormattingContext.prototype.NodeIsOnOneLine">
        function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>NodeIsOnOneLine
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NodeIsOnOneLine = function (node) {
    var startLine = this.sourceFile.getLineAndCharacterOfPosition(node.getStart(this.sourceFile)).line;
    var endLine = this.sourceFile.getLineAndCharacterOfPosition(node.getEnd()).line;
    return startLine === endLine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext.prototype.TokensAreOnSameLine" id="apidoc.element.typescript.formatting.FormattingContext.prototype.TokensAreOnSameLine">
        function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>TokensAreOnSameLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokensAreOnSameLine = function () {
    if (this.tokensAreOnSameLine === undefined) {
        var startLine = this.sourceFile.getLineAndCharacterOfPosition(this.currentTokenSpan.pos).line;
        var endLine = this.sourceFile.getLineAndCharacterOfPosition(this.nextTokenSpan.pos).line;
        this.tokensAreOnSameLine = (startLine === endLine);
    }
    return this.tokensAreOnSameLine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.FormattingContext.prototype.updateContext" id="apidoc.element.typescript.formatting.FormattingContext.prototype.updateContext">
        function <span class="apidocSignatureSpan">typescript.formatting.FormattingContext.prototype.</span>updateContext
        <span class="apidocSignatureSpan">(currentRange, currentTokenParent, nextRange, nextTokenParent, commonParent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateContext = function (currentRange, currentTokenParent, nextRange, nextTokenParent, commonParent) {
    ts.Debug.assert(currentRange !== undefined, "currentTokenSpan is null");
    ts.Debug.assert(currentTokenParent !== undefined, "currentTokenParent is null");
    ts.Debug.assert(nextRange !== undefined, "nextTokenSpan is null");
    ts.Debug.assert(nextTokenParent !== undefined, "nextTokenParent is null");
    ts.Debug.assert(commonParent !== undefined, "commonParent is null");
    this.currentTokenSpan = currentRange;
    this.currentTokenParent = currentTokenParent;
    this.nextTokenSpan = nextRange;
    this.nextTokenParent = nextTokenParent;
    this.contextNode = commonParent;
    // drop cached results
    this.contextNodeAllOnSameLine = undefined;
    this.nextNodeAllOnSameLine = undefined;
    this.tokensAreOnSameLine = undefined;
    this.contextNodeBlockIsOnOneLine = undefined;
    this.nextNodeBlockIsOnOneLine = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Rule" id="apidoc.module.typescript.formatting.Rule">module typescript.formatting.Rule</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Rule.Rule" id="apidoc.element.typescript.formatting.Rule.Rule">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>Rule
        <span class="apidocSignatureSpan">(Descriptor, Operation, Flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Rule(Descriptor, Operation, Flag) {
    if (Flag === void 0) { Flag = 0 /* None */; }
    this.Descriptor = Descriptor;
    this.Operation = Operation;
    this.Flag = Flag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Rule.prototype" id="apidoc.module.typescript.formatting.Rule.prototype">module typescript.formatting.Rule.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Rule.prototype.toString" id="apidoc.element.typescript.formatting.Rule.prototype.toString">
        function <span class="apidocSignatureSpan">typescript.formatting.Rule.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return "[desc=" + this.Descriptor + "," +
        "operation=" + this.Operation + "," +
        "flag=" + this.Flag + "]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RuleDescriptor" id="apidoc.module.typescript.formatting.RuleDescriptor">module typescript.formatting.RuleDescriptor</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleDescriptor.RuleDescriptor" id="apidoc.element.typescript.formatting.RuleDescriptor.RuleDescriptor">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleDescriptor
        <span class="apidocSignatureSpan">(LeftTokenRange, RightTokenRange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleDescriptor(LeftTokenRange, RightTokenRange) {
    this.LeftTokenRange = LeftTokenRange;
    this.RightTokenRange = RightTokenRange;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleDescriptor.create1" id="apidoc.element.typescript.formatting.RuleDescriptor.create1">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.</span>create1
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create1 = function (left, right) {
    return RuleDescriptor.create4(formatting.Shared.TokenRange.FromToken(left), formatting.Shared.TokenRange.FromToken(right));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleDescriptor.create2" id="apidoc.element.typescript.formatting.RuleDescriptor.create2">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.</span>create2
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create2 = function (left, right) {
    return RuleDescriptor.create4(left, formatting.Shared.TokenRange.FromToken(right));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleDescriptor.create3" id="apidoc.element.typescript.formatting.RuleDescriptor.create3">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.</span>create3
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create3 = function (left, right) {
    return RuleDescriptor.create4(formatting.Shared.TokenRange.FromToken(left), right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleDescriptor.create4" id="apidoc.element.typescript.formatting.RuleDescriptor.create4">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.</span>create4
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create4 = function (left, right) {
    return new RuleDescriptor(left, right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RuleDescriptor.prototype" id="apidoc.module.typescript.formatting.RuleDescriptor.prototype">module typescript.formatting.RuleDescriptor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleDescriptor.prototype.toString" id="apidoc.element.typescript.formatting.RuleDescriptor.prototype.toString">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleDescriptor.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return "[leftRange=" + this.LeftTokenRange + "," +
        "rightRange=" + this.RightTokenRange + "]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RuleOperation" id="apidoc.module.typescript.formatting.RuleOperation">module typescript.formatting.RuleOperation</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperation.RuleOperation" id="apidoc.element.typescript.formatting.RuleOperation.RuleOperation">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleOperation
        <span class="apidocSignatureSpan">(Context, Action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleOperation(Context, Action) {
    this.Context = Context;
    this.Action = Action;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperation.create1" id="apidoc.element.typescript.formatting.RuleOperation.create1">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleOperation.</span>create1
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create1 = function (action) {
    return RuleOperation.create2(formatting.RuleOperationContext.Any, action);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperation.create2" id="apidoc.element.typescript.formatting.RuleOperation.create2">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleOperation.</span>create2
        <span class="apidocSignatureSpan">(context, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create2 = function (context, action) {
    return new RuleOperation(context, action);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RuleOperation.prototype" id="apidoc.module.typescript.formatting.RuleOperation.prototype">module typescript.formatting.RuleOperation.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperation.prototype.toString" id="apidoc.element.typescript.formatting.RuleOperation.prototype.toString">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleOperation.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return "[context=" + this.Context + "," +
        "action=" + this.Action + "]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RuleOperationContext" id="apidoc.module.typescript.formatting.RuleOperationContext">module typescript.formatting.RuleOperationContext</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperationContext.RuleOperationContext" id="apidoc.element.typescript.formatting.RuleOperationContext.RuleOperationContext">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RuleOperationContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleOperationContext() {
    var funcs = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        funcs[_i] = arguments[_i];
    }
    this.customContextChecks = funcs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RuleOperationContext.prototype" id="apidoc.module.typescript.formatting.RuleOperationContext.prototype">module typescript.formatting.RuleOperationContext.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperationContext.prototype.InContext" id="apidoc.element.typescript.formatting.RuleOperationContext.prototype.InContext">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleOperationContext.prototype.</span>InContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InContext = function (context) {
    if (this.IsAny()) {
        return true;
    }
    for (var _i = 0, _a = this.customContextChecks; _i &lt; _a.length; _i++) {
        var check = _a[_i];
        if (!check(context)) {
            return false;
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RuleOperationContext.prototype.IsAny" id="apidoc.element.typescript.formatting.RuleOperationContext.prototype.IsAny">
        function <span class="apidocSignatureSpan">typescript.formatting.RuleOperationContext.prototype.</span>IsAny
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsAny = function () {
    return this === RuleOperationContext.Any;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Rules" id="apidoc.module.typescript.formatting.Rules">module typescript.formatting.Rules</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.Rules" id="apidoc.element.typescript.formatting.Rules.Rules">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>Rules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Rules() {
    ///
    /// Common Rules
    ///
    // Leave comments alone
    this.IgnoreBeforeComment = new formatting.Rule(formatting.RuleDescriptor.create4(formatting.Shared.TokenRange.Any, formatting
.Shared.TokenRange.Comments), formatting.RuleOperation.create1(1 /* Ignore */));
    this.IgnoreAfterLineComment = new formatting.Rule(formatting.RuleDescriptor.create3(2 /* SingleLineCommentTrivia */, formatting
.Shared.TokenRange.Any), formatting.RuleOperation.create1(1 /* Ignore */));
    // Space after keyword but not before ; or : or ?
    this.NoSpaceBeforeSemicolon = new formatting.Rule(formatting.RuleDescriptor.create2(formatting.Shared.TokenRange.Any, 24 /*
SemicolonToken */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 8 /*
Delete */));
    this.NoSpaceBeforeColon = new formatting.Rule(formatting.RuleDescriptor.create2(formatting.Shared.TokenRange.Any, 55 /* ColonToken
 */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules.IsNotBinaryOpContext
), 8 /* Delete */));
    this.NoSpaceBeforeQuestionMark = new formatting.Rule(formatting.RuleDescriptor.create2(formatting.Shared.TokenRange.Any, 54 /*
QuestionToken */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules
.IsNotBinaryOpContext), 8 /* Delete */));
    this.SpaceAfterColon = new formatting.Rule(formatting.RuleDescriptor.create3(55 /* ColonToken */, formatting.Shared.TokenRange
.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules.IsNotBinaryOpContext
), 2 /* Space */));
    this.SpaceAfterQuestionMarkInConditionalOperator = new formatting.Rule(formatting.RuleDescriptor.create3(54 /* QuestionToken
 */, formatting.Shared.TokenRange.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext
, Rules.IsConditionalOperatorContext), 2 /* Space */));
    this.NoSpaceAfterQuestionMark = new formatting.Rule(formatting.RuleDescriptor.create3(54 /* QuestionToken */, formatting.Shared
.TokenRange.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 8 /*
Delete */));
    this.SpaceAfterSemicolon = new formatting.Rule(formatting.RuleDescriptor.create3(24 /* SemicolonToken */, formatting.Shared.
TokenRange.Any), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 2 /*
Space */));
    // Space after }.
    this.SpaceAfterCloseBrace = new formatting.Rule(formatting.RuleDescriptor.create3(17 /* CloseBraceToken */, formatting.Shared
.TokenRange.FromRange(0 /* FirstToken */, 141 /* LastToken */, [19 /* CloseParenToken */])), formatting.RuleOperation.create2(new
 formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext, Rules.IsAfterCodeBlockContext), 2 /* Space */));
    // Special case for (}, else) and (}, while) since else &amp; while tokens are not part of the tree which makes SpaceAfterCloseBrace
 rule not applied
    this.SpaceBetweenCloseBraceAndElse = new formatting.Rule(formatting.RuleDescriptor.create1(17 /* CloseBraceToken */, 81 /* ElseKeyword
 */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 2 /* Space */));
    this.SpaceBetweenCloseBraceAndWhile = new formatting.Rule(formatting.RuleDescriptor.create1(17 /* CloseBraceToken */, 105 /*
WhileKeyword */), formatting.RuleOperation.create2(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 2 /*
Space */));
    this.NoSpaceAfterCloseBrace = new formatting.Rule(formatting.RuleDescriptor.create3(17 /* CloseBraceToken */, formatting.Shared
.TokenRange.FromTokens([21 /* CloseBracketToken */, 25 /* CommaToken */, 24 /* SemicolonToken */])), formatting.RuleOperation.create2
(new formatting.RuleOperationContext(Rules.IsNonJsxSameLineTokenContext), 8 /* Delete */));
    // No space for dot
    this.NoSpaceBeforeDot = ne ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsAfterCodeBlockContext" id="apidoc.element.typescript.formatting.Rules.IsAfterCodeBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsAfterCodeBlockContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsAfterCodeBlockContext = function (context) {
    switch (context.currentTokenParent.kind) {
        case 228 /* ClassDeclaration */:
        case 232 /* ModuleDeclaration */:
        case 231 /* EnumDeclaration */:
        case 258 /* CatchClause */:
        case 233 /* ModuleBlock */:
        case 220 /* SwitchStatement */:
            return true;
        case 206 /* Block */: {
            var blockParent = context.currentTokenParent.parent;
            if (blockParent.kind !== 186 /* ArrowFunction */ &amp;&amp;
                blockParent.kind !== 185 /* FunctionExpression */) {
                return true;
            }
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsArrowFunctionContext" id="apidoc.element.typescript.formatting.Rules.IsArrowFunctionContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsArrowFunctionContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsArrowFunctionContext = function (context) {
    return context.contextNode.kind === 186 /* ArrowFunction */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsBeforeBlockContext" id="apidoc.element.typescript.formatting.Rules.IsBeforeBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBeforeBlockContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsBeforeBlockContext = function (context) {
    return Rules.NodeIsBlockContext(context.nextTokenParent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsBeforeMultilineBlockContext" id="apidoc.element.typescript.formatting.Rules.IsBeforeMultilineBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBeforeMultilineBlockContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsBeforeMultilineBlockContext = function (context) {
    return Rules.IsBeforeBlockContext(context) &amp;&amp; !(context.NextNodeAllOnSameLine() || context.NextNodeBlockIsOnOneLine());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsBinaryOpContext" id="apidoc.element.typescript.formatting.Rules.IsBinaryOpContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBinaryOpContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsBinaryOpContext = function (context) {
    switch (context.contextNode.kind) {
        case 193 /* BinaryExpression */:
        case 194 /* ConditionalExpression */:
        case 201 /* AsExpression */:
        case 245 /* ExportSpecifier */:
        case 241 /* ImportSpecifier */:
        case 157 /* TypePredicate */:
        case 165 /* UnionType */:
        case 166 /* IntersectionType */:
            return true;
        // equals in binding elements: function foo([[x, y] = [1, 2]])
        case 175 /* BindingElement */:
        // equals in type X = ...
        case 230 /* TypeAliasDeclaration */:
        // equal in import a = module('a');
        case 236 /* ImportEqualsDeclaration */:
        // equal in let a = 0;
        case 225 /* VariableDeclaration */:
        // equal in p = 0;
        case 145 /* Parameter */:
        case 262 /* EnumMember */:
        case 148 /* PropertyDeclaration */:
        case 147 /* PropertySignature */:
            return context.currentTokenSpan.kind === 57 /* EqualsToken */ || context.nextTokenSpan.kind === 57 /* EqualsToken */;
        // "in" keyword in for (let x in []) { }
        case 214 /* ForInStatement */:
        // "in" keyword in [P in keyof T]: T[P]
        case 144 /* TypeParameter */:
            return context.currentTokenSpan.kind === 91 /* InKeyword */ || context.nextTokenSpan.kind === 91 /* InKeyword */;
        // Technically, "of" is not a binary operator, but format it the same way as "in"
        case 215 /* ForOfStatement */:
            return context.currentTokenSpan.kind === 141 /* OfKeyword */ || context.nextTokenSpan.kind === 141 /* OfKeyword */;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsBlockContext" id="apidoc.element.typescript.formatting.Rules.IsBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBlockContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsBlockContext = function (context) {
    return Rules.NodeIsBlockContext(context.contextNode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsBraceWrappedContext" id="apidoc.element.typescript.formatting.Rules.IsBraceWrappedContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsBraceWrappedContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsBraceWrappedContext = function (context) {
    return context.contextNode.kind === 173 /* ObjectBindingPattern */ || Rules.IsSingleLineBlockContext(context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsConditionalOperatorContext" id="apidoc.element.typescript.formatting.Rules.IsConditionalOperatorContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsConditionalOperatorContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsConditionalOperatorContext = function (context) {
    return context.contextNode.kind === 194 /* ConditionalExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsControlDeclContext" id="apidoc.element.typescript.formatting.Rules.IsControlDeclContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsControlDeclContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsControlDeclContext = function (context) {
    switch (context.contextNode.kind) {
        case 210 /* IfStatement */:
        case 220 /* SwitchStatement */:
        case 213 /* ForStatement */:
        case 214 /* ForInStatement */:
        case 215 /* ForOfStatement */:
        case 212 /* WhileStatement */:
        case 223 /* TryStatement */:
        case 211 /* DoStatement */:
        case 219 /* WithStatement */:
        // TODO
        // case SyntaxKind.ElseClause:
        case 258 /* CatchClause */:
            return true;
        default:
            return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsEndOfDecoratorContextOnSameLine" id="apidoc.element.typescript.formatting.Rules.IsEndOfDecoratorContextOnSameLine">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsEndOfDecoratorContextOnSameLine
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsEndOfDecoratorContextOnSameLine = function (context) {
    return context.TokensAreOnSameLine() &amp;&amp;
        context.contextNode.decorators &amp;&amp;
        Rules.NodeIsInDecoratorContext(context.currentTokenParent) &amp;&amp;
        !Rules.NodeIsInDecoratorContext(context.nextTokenParent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsForContext" id="apidoc.element.typescript.formatting.Rules.IsForContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsForContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsForContext = function (context) {
    return context.contextNode.kind === 213 /* ForStatement */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsFunctionCallContext" id="apidoc.element.typescript.formatting.Rules.IsFunctionCallContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsFunctionCallContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsFunctionCallContext = function (context) {
    return context.contextNode.kind === 180 /* CallExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsFunctionCallOrNewContext" id="apidoc.element.typescript.formatting.Rules.IsFunctionCallOrNewContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsFunctionCallOrNewContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsFunctionCallOrNewContext = function (context) {
    return Rules.IsFunctionCallContext(context) || Rules.IsNewContext(context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsFunctionDeclContext" id="apidoc.element.typescript.formatting.Rules.IsFunctionDeclContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsFunctionDeclContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsFunctionDeclContext = function (context) {
    switch (context.contextNode.kind) {
        case 227 /* FunctionDeclaration */:
        case 150 /* MethodDeclaration */:
        case 149 /* MethodSignature */:
        // case SyntaxKind.MemberFunctionDeclaration:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
        // case SyntaxKind.MethodSignature:
        case 154 /* CallSignature */:
        case 185 /* FunctionExpression */:
        case 151 /* Constructor */:
        case 186 /* ArrowFunction */:
        // case SyntaxKind.ConstructorDeclaration:
        // case SyntaxKind.SimpleArrowFunctionExpression:
        // case SyntaxKind.ParenthesizedArrowFunctionExpression:
        case 229 /* InterfaceDeclaration */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsFunctionDeclarationOrFunctionExpressionContext" id="apidoc.element.typescript.formatting.Rules.IsFunctionDeclarationOrFunctionExpressionContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsFunctionDeclarationOrFunctionExpressionContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsFunctionDeclarationOrFunctionExpressionContext = function (context) {
    return context.contextNode.kind === 227 /* FunctionDeclaration */ || context.contextNode.kind === 185 /* FunctionExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsJsxAttributeContext" id="apidoc.element.typescript.formatting.Rules.IsJsxAttributeContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsJsxAttributeContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsJsxAttributeContext = function (context) {
    return context.contextNode.kind === 252 /* JsxAttribute */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsJsxExpressionContext" id="apidoc.element.typescript.formatting.Rules.IsJsxExpressionContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsJsxExpressionContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsJsxExpressionContext = function (context) {
    return context.contextNode.kind === 254 /* JsxExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsJsxSelfClosingElementContext" id="apidoc.element.typescript.formatting.Rules.IsJsxSelfClosingElementContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsJsxSelfClosingElementContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsJsxSelfClosingElementContext = function (context) {
    return context.contextNode.kind === 249 /* JsxSelfClosingElement */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsModuleDeclContext" id="apidoc.element.typescript.formatting.Rules.IsModuleDeclContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsModuleDeclContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsModuleDeclContext = function (context) {
    return context.contextNode.kind === 232 /* ModuleDeclaration */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsMultilineBlockContext" id="apidoc.element.typescript.formatting.Rules.IsMultilineBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsMultilineBlockContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsMultilineBlockContext = function (context) {
    return Rules.IsBlockContext(context) &amp;&amp; !(context.ContextNodeAllOnSameLine() || context.ContextNodeBlockIsOnOneLine());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNewContext" id="apidoc.element.typescript.formatting.Rules.IsNewContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNewContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNewContext = function (context) {
    return context.contextNode.kind === 181 /* NewExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNextTokenNotCloseBracket" id="apidoc.element.typescript.formatting.Rules.IsNextTokenNotCloseBracket">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNextTokenNotCloseBracket
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNextTokenNotCloseBracket = function (context) {
    return context.nextTokenSpan.kind !== 21 /* CloseBracketToken */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNextTokenParentJsxAttribute" id="apidoc.element.typescript.formatting.Rules.IsNextTokenParentJsxAttribute">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNextTokenParentJsxAttribute
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNextTokenParentJsxAttribute = function (context) {
    return context.nextTokenParent.kind === 252 /* JsxAttribute */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNonJsxElementContext" id="apidoc.element.typescript.formatting.Rules.IsNonJsxElementContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNonJsxElementContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNonJsxElementContext = function (context) {
    return context.contextNode.kind !== 248 /* JsxElement */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNonJsxSameLineTokenContext" id="apidoc.element.typescript.formatting.Rules.IsNonJsxSameLineTokenContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNonJsxSameLineTokenContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNonJsxSameLineTokenContext = function (context) {
    return context.TokensAreOnSameLine() &amp;&amp; context.contextNode.kind !== 10 /* JsxText */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNonNullAssertionContext" id="apidoc.element.typescript.formatting.Rules.IsNonNullAssertionContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNonNullAssertionContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNonNullAssertionContext = function (context) {
    return context.contextNode.kind === 202 /* NonNullExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNotBeforeBlockInFunctionDeclarationContext" id="apidoc.element.typescript.formatting.Rules.IsNotBeforeBlockInFunctionDeclarationContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNotBeforeBlockInFunctionDeclarationContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNotBeforeBlockInFunctionDeclarationContext = function (context) {
    return !Rules.IsFunctionDeclContext(context) &amp;&amp; !Rules.IsBeforeBlockContext(context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNotBinaryOpContext" id="apidoc.element.typescript.formatting.Rules.IsNotBinaryOpContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNotBinaryOpContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNotBinaryOpContext = function (context) {
    return !Rules.IsBinaryOpContext(context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNotForContext" id="apidoc.element.typescript.formatting.Rules.IsNotForContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNotForContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNotForContext = function (context) {
    return !Rules.IsForContext(context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsNotFormatOnEnter" id="apidoc.element.typescript.formatting.Rules.IsNotFormatOnEnter">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsNotFormatOnEnter
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsNotFormatOnEnter = function (context) {
    return context.formattingRequestKind !== 2 /* FormatOnEnter */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsObjectContext" id="apidoc.element.typescript.formatting.Rules.IsObjectContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsObjectContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsObjectContext = function (context) {
    return context.contextNode.kind === 177 /* ObjectLiteralExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsObjectTypeContext" id="apidoc.element.typescript.formatting.Rules.IsObjectTypeContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsObjectTypeContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsObjectTypeContext = function (context) {
    return context.contextNode.kind === 162 /* TypeLiteral */; // &amp;&amp; context.contextNode.parent.kind !== SyntaxKind.InterfaceDeclaration
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsPreviousTokenNotComma" id="apidoc.element.typescript.formatting.Rules.IsPreviousTokenNotComma">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsPreviousTokenNotComma
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsPreviousTokenNotComma = function (context) {
    return context.currentTokenSpan.kind !== 25 /* CommaToken */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsSameLineTokenOrBeforeMultilineBlockContext" id="apidoc.element.typescript.formatting.Rules.IsSameLineTokenOrBeforeMultilineBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsSameLineTokenOrBeforeMultilineBlockContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsSameLineTokenOrBeforeMultilineBlockContext = function (context) {
    //// This check is mainly used inside SpaceBeforeOpenBraceInControl and SpaceBeforeOpenBraceInFunction.
    ////
    //// Ex:
    //// if (1)     { ....
    ////      * ) and { are on the same line so apply the rule. Here we don't care whether it's same or multi block context
    ////
    //// Ex:
    //// if (1)
    //// { ... }
    ////      * ) and { are on different lines. We only need to format if the block is multiline context. So in this case we don
't format.
    ////
    //// Ex:
    //// if (1)
    //// { ...
    //// }
    ////      * ) and { are on different lines. We only need to format if the block is multiline context. So in this case we format
.
    return context.TokensAreOnSameLine() || Rules.IsBeforeMultilineBlockContext(context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsSingleLineBlockContext" id="apidoc.element.typescript.formatting.Rules.IsSingleLineBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsSingleLineBlockContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsSingleLineBlockContext = function (context) {
    return Rules.IsBlockContext(context) &amp;&amp; (context.ContextNodeAllOnSameLine() || context.ContextNodeBlockIsOnOneLine());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsStartOfVariableDeclarationList" id="apidoc.element.typescript.formatting.Rules.IsStartOfVariableDeclarationList">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsStartOfVariableDeclarationList
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsStartOfVariableDeclarationList = function (context) {
    return context.currentTokenParent.kind === 226 /* VariableDeclarationList */ &amp;&amp;
        context.currentTokenParent.getStart(context.sourceFile) === context.currentTokenSpan.pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsTypeArgumentOrParameterOrAssertion" id="apidoc.element.typescript.formatting.Rules.IsTypeArgumentOrParameterOrAssertion">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsTypeArgumentOrParameterOrAssertion
        <span class="apidocSignatureSpan">(token, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsTypeArgumentOrParameterOrAssertion = function (token, parent) {
    if (token.kind !== 26 /* LessThanToken */ &amp;&amp; token.kind !== 28 /* GreaterThanToken */) {
        return false;
    }
    switch (parent.kind) {
        case 158 /* TypeReference */:
        case 183 /* TypeAssertionExpression */:
        case 230 /* TypeAliasDeclaration */:
        case 228 /* ClassDeclaration */:
        case 198 /* ClassExpression */:
        case 229 /* InterfaceDeclaration */:
        case 227 /* FunctionDeclaration */:
        case 185 /* FunctionExpression */:
        case 186 /* ArrowFunction */:
        case 150 /* MethodDeclaration */:
        case 149 /* MethodSignature */:
        case 154 /* CallSignature */:
        case 155 /* ConstructSignature */:
        case 180 /* CallExpression */:
        case 181 /* NewExpression */:
        case 200 /* ExpressionWithTypeArguments */:
            return true;
        default:
            return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsTypeArgumentOrParameterOrAssertionContext" id="apidoc.element.typescript.formatting.Rules.IsTypeArgumentOrParameterOrAssertionContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsTypeArgumentOrParameterOrAssertionContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsTypeArgumentOrParameterOrAssertionContext = function (context) {
    return Rules.IsTypeArgumentOrParameterOrAssertion(context.currentTokenSpan, context.currentTokenParent) ||
        Rules.IsTypeArgumentOrParameterOrAssertion(context.nextTokenSpan, context.nextTokenParent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsTypeAssertionContext" id="apidoc.element.typescript.formatting.Rules.IsTypeAssertionContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsTypeAssertionContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsTypeAssertionContext = function (context) {
    return context.contextNode.kind === 183 /* TypeAssertionExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsTypeScriptDeclWithBlockContext" id="apidoc.element.typescript.formatting.Rules.IsTypeScriptDeclWithBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsTypeScriptDeclWithBlockContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsTypeScriptDeclWithBlockContext = function (context) {
    return Rules.NodeIsTypeScriptDeclWithBlockContext(context.contextNode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsVoidOpContext" id="apidoc.element.typescript.formatting.Rules.IsVoidOpContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsVoidOpContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsVoidOpContext = function (context) {
    return context.currentTokenSpan.kind === 104 /* VoidKeyword */ &amp;&amp; context.currentTokenParent.kind === 189 /* VoidExpression */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.IsYieldOrYieldStarWithOperand" id="apidoc.element.typescript.formatting.Rules.IsYieldOrYieldStarWithOperand">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>IsYieldOrYieldStarWithOperand
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsYieldOrYieldStarWithOperand = function (context) {
    return context.contextNode.kind === 196 /* YieldExpression */ &amp;&amp; context.contextNode.expression !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.NodeIsBlockContext" id="apidoc.element.typescript.formatting.Rules.NodeIsBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>NodeIsBlockContext
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NodeIsBlockContext = function (node) {
    if (Rules.NodeIsTypeScriptDeclWithBlockContext(node)) {
        // This means we are in a context that looks like a block to the user, but in the grammar is actually not a node (it's a
 class, module, enum, object type literal, etc).
        return true;
    }
    switch (node.kind) {
        case 206 /* Block */:
        case 234 /* CaseBlock */:
        case 177 /* ObjectLiteralExpression */:
        case 233 /* ModuleBlock */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.NodeIsInDecoratorContext" id="apidoc.element.typescript.formatting.Rules.NodeIsInDecoratorContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>NodeIsInDecoratorContext
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NodeIsInDecoratorContext = function (node) {
    while (ts.isPartOfExpression(node)) {
        node = node.parent;
    }
    return node.kind === 146 /* Decorator */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.NodeIsTypeScriptDeclWithBlockContext" id="apidoc.element.typescript.formatting.Rules.NodeIsTypeScriptDeclWithBlockContext">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.</span>NodeIsTypeScriptDeclWithBlockContext
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NodeIsTypeScriptDeclWithBlockContext = function (node) {
    switch (node.kind) {
        case 228 /* ClassDeclaration */:
        case 198 /* ClassExpression */:
        case 229 /* InterfaceDeclaration */:
        case 231 /* EnumDeclaration */:
        case 162 /* TypeLiteral */:
        case 232 /* ModuleDeclaration */:
        case 243 /* ExportDeclaration */:
        case 244 /* NamedExports */:
        case 237 /* ImportDeclaration */:
        case 240 /* NamedImports */:
            return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Rules.prototype" id="apidoc.module.typescript.formatting.Rules.prototype">module typescript.formatting.Rules.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Rules.prototype.getRuleName" id="apidoc.element.typescript.formatting.Rules.prototype.getRuleName">
        function <span class="apidocSignatureSpan">typescript.formatting.Rules.prototype.</span>getRuleName
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRuleName = function (rule) {
    var o = this;
    for (var name in o) {
        if (o[name] === rule) {
            return name;
        }
    }
    throw new Error("Unknown rule");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RulesBucket" id="apidoc.module.typescript.formatting.RulesBucket">module typescript.formatting.RulesBucket</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucket.RulesBucket" id="apidoc.element.typescript.formatting.RulesBucket.RulesBucket">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesBucket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesBucket() {
    this.rules = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RulesBucket.prototype" id="apidoc.module.typescript.formatting.RulesBucket.prototype">module typescript.formatting.RulesBucket.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucket.prototype.AddRule" id="apidoc.element.typescript.formatting.RulesBucket.prototype.AddRule">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesBucket.prototype.</span>AddRule
        <span class="apidocSignatureSpan">(rule, specificTokens, constructionState, rulesBucketIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">AddRule = function (rule, specificTokens, constructionState, rulesBucketIndex) {
    var position;
    if (rule.Operation.Action === 1 /* Ignore */) {
        position = specificTokens ?
            RulesPosition.IgnoreRulesSpecific :
            RulesPosition.IgnoreRulesAny;
    }
    else if (!rule.Operation.Context.IsAny()) {
        position = specificTokens ?
            RulesPosition.ContextRulesSpecific :
            RulesPosition.ContextRulesAny;
    }
    else {
        position = specificTokens ?
            RulesPosition.NoContextRulesSpecific :
            RulesPosition.NoContextRulesAny;
    }
    var state = constructionState[rulesBucketIndex];
    if (state === undefined) {
        state = constructionState[rulesBucketIndex] = new RulesBucketConstructionState();
    }
    var index = state.GetInsertionIndex(position);
    this.rules.splice(index, 0, rule);
    state.IncreaseInsertionIndex(position);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucket.prototype.Rules" id="apidoc.element.typescript.formatting.RulesBucket.prototype.Rules">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesBucket.prototype.</span>Rules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Rules = function () {
    return this.rules;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RulesBucketConstructionState" id="apidoc.module.typescript.formatting.RulesBucketConstructionState">module typescript.formatting.RulesBucketConstructionState</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucketConstructionState.RulesBucketConstructionState" id="apidoc.element.typescript.formatting.RulesBucketConstructionState.RulesBucketConstructionState">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesBucketConstructionState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesBucketConstructionState() {
    //// The Rules list contains all the inserted rules into a rulebucket in the following order:
    ////    1- Ignore rules with specific token combination
    ////    2- Ignore rules with any token combination
    ////    3- Context rules with specific token combination
    ////    4- Context rules with any token combination
    ////    5- Non-context rules with specific token combination
    ////    6- Non-context rules with any token combination
    ////
    //// The member rulesInsertionIndexBitmap is used to describe the number of rules
    //// in each sub-bucket (above) hence can be used to know the index of where to insert
    //// the next rule. It's a bitmap which contains 6 different sections each is given 5 bits.
    ////
    //// Example:
    //// In order to insert a rule to the end of sub-bucket (3), we get the index by adding
    //// the values in the bitmap segments 3rd, 2nd, and 1st.
    this.rulesInsertionIndexBitmap = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RulesBucketConstructionState.prototype" id="apidoc.module.typescript.formatting.RulesBucketConstructionState.prototype">module typescript.formatting.RulesBucketConstructionState.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucketConstructionState.prototype.GetInsertionIndex" id="apidoc.element.typescript.formatting.RulesBucketConstructionState.prototype.GetInsertionIndex">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesBucketConstructionState.prototype.</span>GetInsertionIndex
        <span class="apidocSignatureSpan">(maskPosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GetInsertionIndex = function (maskPosition) {
    var index = 0;
    var pos = 0;
    var indexBitmap = this.rulesInsertionIndexBitmap;
    while (pos &lt;= maskPosition) {
        index += (indexBitmap &amp; Mask);
        indexBitmap &gt;&gt;= MaskBitSize;
        pos += MaskBitSize;
    }
    return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesBucketConstructionState.prototype.IncreaseInsertionIndex" id="apidoc.element.typescript.formatting.RulesBucketConstructionState.prototype.IncreaseInsertionIndex">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesBucketConstructionState.prototype.</span>IncreaseInsertionIndex
        <span class="apidocSignatureSpan">(maskPosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IncreaseInsertionIndex = function (maskPosition) {
    var value = (this.rulesInsertionIndexBitmap &gt;&gt; maskPosition) &amp; Mask;
    value++;
    ts.Debug.assert((value &amp; Mask) === value, "Adding more rules into the sub-bucket than allowed. Maximum allowed is 32 rules.");
    var temp = this.rulesInsertionIndexBitmap &amp; ~(Mask &lt;&lt; maskPosition);
    temp |= value &lt;&lt; maskPosition;
    this.rulesInsertionIndexBitmap = temp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RulesMap" id="apidoc.module.typescript.formatting.RulesMap">module typescript.formatting.RulesMap</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesMap.RulesMap" id="apidoc.element.typescript.formatting.RulesMap.RulesMap">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesMap() {
    this.map = [];
    this.mapRowLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesMap.create" id="apidoc.element.typescript.formatting.RulesMap.create">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.</span>create
        <span class="apidocSignatureSpan">(rules)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (rules) {
    var result = new RulesMap();
    result.Initialize(rules);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RulesMap.prototype" id="apidoc.module.typescript.formatting.RulesMap.prototype">module typescript.formatting.RulesMap.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesMap.prototype.FillRule" id="apidoc.element.typescript.formatting.RulesMap.prototype.FillRule">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>FillRule
        <span class="apidocSignatureSpan">(rule, rulesBucketConstructionStateList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FillRule = function (rule, rulesBucketConstructionStateList) {
    var _this = this;
    var specificRule = rule.Descriptor.LeftTokenRange !== formatting.Shared.TokenRange.Any &amp;&amp;
        rule.Descriptor.RightTokenRange !== formatting.Shared.TokenRange.Any;
    rule.Descriptor.LeftTokenRange.GetTokens().forEach(function (left) {
        rule.Descriptor.RightTokenRange.GetTokens().forEach(function (right) {
            var rulesBucketIndex = _this.GetRuleBucketIndex(left, right);
            var rulesBucket = _this.map[rulesBucketIndex];
            if (rulesBucket === undefined) {
                rulesBucket = _this.map[rulesBucketIndex] = new RulesBucket();
            }
            rulesBucket.AddRule(rule, specificRule, rulesBucketConstructionStateList, rulesBucketIndex);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesMap.prototype.FillRules" id="apidoc.element.typescript.formatting.RulesMap.prototype.FillRules">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>FillRules
        <span class="apidocSignatureSpan">(rules, rulesBucketConstructionStateList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FillRules = function (rules, rulesBucketConstructionStateList) {
    var _this = this;
    rules.forEach(function (rule) {
        _this.FillRule(rule, rulesBucketConstructionStateList);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesMap.prototype.GetRule" id="apidoc.element.typescript.formatting.RulesMap.prototype.GetRule">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>GetRule
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GetRule = function (context) {
    var bucketIndex = this.GetRuleBucketIndex(context.currentTokenSpan.kind, context.nextTokenSpan.kind);
    var bucket = this.map[bucketIndex];
    if (bucket) {
        for (var _i = 0, _a = bucket.Rules(); _i &lt; _a.length; _i++) {
            var rule = _a[_i];
            if (rule.Operation.Context.InContext(context)) {
                return rule;
            }
        }
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesMap.prototype.GetRuleBucketIndex" id="apidoc.element.typescript.formatting.RulesMap.prototype.GetRuleBucketIndex">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>GetRuleBucketIndex
        <span class="apidocSignatureSpan">(row, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GetRuleBucketIndex = function (row, column) {
    ts.Debug.assert(row &lt;= 141 /* LastKeyword */ &amp;&amp; column &lt;= 141 /* LastKeyword */, "Must compute formatting context from tokens
");
    var rulesBucketIndex = (row * this.mapRowLength) + column;
    return rulesBucketIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesMap.prototype.Initialize" id="apidoc.element.typescript.formatting.RulesMap.prototype.Initialize">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesMap.prototype.</span>Initialize
        <span class="apidocSignatureSpan">(rules)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Initialize = function (rules) {
    this.mapRowLength = 141 /* LastToken */ + 1;
    this.map = new Array(this.mapRowLength * this.mapRowLength); // new Array&lt;RulesBucket&gt;(this.mapRowLength * this.mapRowLength
);
    // This array is used only during construction of the rulesbucket in the map
    var rulesBucketConstructionStateList = new Array(this.map.length); // new Array&lt;RulesBucketConstructionState&gt;(this.map.length
);
    this.FillRules(rules, rulesBucketConstructionStateList);
    return this.map;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RulesProvider" id="apidoc.module.typescript.formatting.RulesProvider">module typescript.formatting.RulesProvider</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesProvider.RulesProvider" id="apidoc.element.typescript.formatting.RulesProvider.RulesProvider">
        function <span class="apidocSignatureSpan">typescript.formatting.</span>RulesProvider
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RulesProvider() {
    this.globalRules = new formatting.Rules();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.RulesProvider.prototype" id="apidoc.module.typescript.formatting.RulesProvider.prototype">module typescript.formatting.RulesProvider.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesProvider.prototype.createActiveRules" id="apidoc.element.typescript.formatting.RulesProvider.prototype.createActiveRules">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>createActiveRules
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createActiveRules = function (options) {
    var rules = this.globalRules.HighPriorityCommonRules.slice(0);
    if (options.insertSpaceAfterConstructor) {
        rules.push(this.globalRules.SpaceAfterConstructor);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterConstructor);
    }
    if (options.insertSpaceAfterCommaDelimiter) {
        rules.push(this.globalRules.SpaceAfterComma);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterComma);
    }
    if (options.insertSpaceAfterFunctionKeywordForAnonymousFunctions) {
        rules.push(this.globalRules.SpaceAfterAnonymousFunctionKeyword);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterAnonymousFunctionKeyword);
    }
    if (options.insertSpaceAfterKeywordsInControlFlowStatements) {
        rules.push(this.globalRules.SpaceAfterKeywordInControl);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterKeywordInControl);
    }
    if (options.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis) {
        rules.push(this.globalRules.SpaceAfterOpenParen);
        rules.push(this.globalRules.SpaceBeforeCloseParen);
        rules.push(this.globalRules.NoSpaceBetweenParens);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterOpenParen);
        rules.push(this.globalRules.NoSpaceBeforeCloseParen);
        rules.push(this.globalRules.NoSpaceBetweenParens);
    }
    if (options.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets) {
        rules.push(this.globalRules.SpaceAfterOpenBracket);
        rules.push(this.globalRules.SpaceBeforeCloseBracket);
        rules.push(this.globalRules.NoSpaceBetweenBrackets);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterOpenBracket);
        rules.push(this.globalRules.NoSpaceBeforeCloseBracket);
        rules.push(this.globalRules.NoSpaceBetweenBrackets);
    }
    // The default value of InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces is true
    // so if the option is undefined, we should treat it as true as well
    if (options.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces !== false) {
        rules.push(this.globalRules.SpaceAfterOpenBrace);
        rules.push(this.globalRules.SpaceBeforeCloseBrace);
        rules.push(this.globalRules.NoSpaceBetweenEmptyBraceBrackets);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterOpenBrace);
        rules.push(this.globalRules.NoSpaceBeforeCloseBrace);
        rules.push(this.globalRules.NoSpaceBetweenEmptyBraceBrackets);
    }
    if (options.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces) {
        rules.push(this.globalRules.SpaceAfterTemplateHeadAndMiddle);
        rules.push(this.globalRules.SpaceBeforeTemplateMiddleAndTail);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterTemplateHeadAndMiddle);
        rules.push(this.globalRules.NoSpaceBeforeTemplateMiddleAndTail);
    }
    if (options.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces) {
        rules.push(this.globalRules.SpaceAfterOpenBraceInJsxExpression);
        rules.push(this.globalRules.SpaceBeforeCloseBraceInJsxExpression);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterOpenBraceInJsxExpression);
        rules.push(this.globalRules.NoSpaceBeforeCloseBraceInJsxExpression);
    }
    if (options.insertSpaceAfterSemicolonInForStatements) {
        rules.push(this.globalRules.SpaceAfterSemicolonInFor);
    }
    else {
        rules.push(this.globalRules.NoSpaceAfterSemicolonInFor);
    }
    if (options.insertSpaceBeforeAndAfterBinaryOperators) {
        rules.push(this.globalRules.SpaceBeforeBinaryOperator);
        rules.push(this.globalRules.SpaceAfterBinaryOperator);
    }
    else {
        rules.push(this.globalRules.NoSpaceBeforeBinaryOperator);
        rules.push(this.globalRules.NoSpaceAfterBinaryOperator);
    }
    if (options.insertSpaceBeforeFunctionParenthesis) {
        rules.push(this.globalRules.SpaceBeforeOpenParenInFuncDecl);
    }
    else {
        rules.push(this.globalRules.NoSpaceBeforeOpenParenInFuncDecl);
    }
    if (options.placeOpenBrace ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesProvider.prototype.ensureUpToDate" id="apidoc.element.typescript.formatting.RulesProvider.prototype.ensureUpToDate">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>ensureUpToDate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureUpToDate = function (options) {
    if (!this.options || !ts.compareDataObjects(this.options, options)) {
        var activeRules = this.createActiveRules(options);
        var rulesMap = formatting.RulesMap.create(activeRules);
        this.activeRules = activeRules;
        this.rulesMap = rulesMap;
        this.options = ts.clone(options);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesProvider.prototype.getRuleByName" id="apidoc.element.typescript.formatting.RulesProvider.prototype.getRuleByName">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>getRuleByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRuleByName = function (name) {
    return this.globalRules[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesProvider.prototype.getRuleName" id="apidoc.element.typescript.formatting.RulesProvider.prototype.getRuleName">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>getRuleName
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRuleName = function (rule) {
    return this.globalRules.getRuleName(rule);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.RulesProvider.prototype.getRulesMap" id="apidoc.element.typescript.formatting.RulesProvider.prototype.getRulesMap">
        function <span class="apidocSignatureSpan">typescript.formatting.RulesProvider.prototype.</span>getRulesMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRulesMap = function () {
    return this.rulesMap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Shared" id="apidoc.module.typescript.formatting.Shared">module typescript.formatting.Shared</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenAllAccess" id="apidoc.element.typescript.formatting.Shared.TokenAllAccess">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenAllAccess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenAllAccess() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenRange" id="apidoc.element.typescript.formatting.Shared.TokenRange">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenRange
        <span class="apidocSignatureSpan">(tokenAccess)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenRange(tokenAccess) {
    this.tokenAccess = tokenAccess;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenRangeAccess" id="apidoc.element.typescript.formatting.Shared.TokenRangeAccess">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenRangeAccess
        <span class="apidocSignatureSpan">(from, to, except)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenRangeAccess(from, to, except) {
    this.tokens = [];
    for (var token = from; token &lt;= to; token++) {
        if (ts.indexOf(except, token) &lt; 0) {
            this.tokens.push(token);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenSingleValueAccess" id="apidoc.element.typescript.formatting.Shared.TokenSingleValueAccess">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenSingleValueAccess
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenSingleValueAccess(token) {
    this.token = token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenValuesAccess" id="apidoc.element.typescript.formatting.Shared.TokenValuesAccess">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.</span>TokenValuesAccess
        <span class="apidocSignatureSpan">(tks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenValuesAccess(tks) {
    this.tokens = tks &amp;&amp; tks.length ? tks : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Shared.TokenAllAccess.prototype" id="apidoc.module.typescript.formatting.Shared.TokenAllAccess.prototype">module typescript.formatting.Shared.TokenAllAccess.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenAllAccess.prototype.Contains" id="apidoc.element.typescript.formatting.Shared.TokenAllAccess.prototype.Contains">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenAllAccess.prototype.</span>Contains
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Contains = function () {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenAllAccess.prototype.GetTokens" id="apidoc.element.typescript.formatting.Shared.TokenAllAccess.prototype.GetTokens">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenAllAccess.prototype.</span>GetTokens
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GetTokens = function () {
    var result = [];
    for (var token = 0 /* FirstToken */; token &lt;= 141 /* LastToken */; token++) {
        result.push(token);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenAllAccess.prototype.toString" id="apidoc.element.typescript.formatting.Shared.TokenAllAccess.prototype.toString">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenAllAccess.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return "[allTokens]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Shared.TokenRange.prototype" id="apidoc.module.typescript.formatting.Shared.TokenRange.prototype">module typescript.formatting.Shared.TokenRange.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenRange.prototype.Contains" id="apidoc.element.typescript.formatting.Shared.TokenRange.prototype.Contains">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRange.prototype.</span>Contains
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Contains = function (token) {
    return this.tokenAccess.Contains(token);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenRange.prototype.GetTokens" id="apidoc.element.typescript.formatting.Shared.TokenRange.prototype.GetTokens">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRange.prototype.</span>GetTokens
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GetTokens = function () {
    return this.tokenAccess.GetTokens();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenRange.prototype.toString" id="apidoc.element.typescript.formatting.Shared.TokenRange.prototype.toString">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRange.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return this.tokenAccess.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Shared.TokenRangeAccess.prototype" id="apidoc.module.typescript.formatting.Shared.TokenRangeAccess.prototype">module typescript.formatting.Shared.TokenRangeAccess.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenRangeAccess.prototype.Contains" id="apidoc.element.typescript.formatting.Shared.TokenRangeAccess.prototype.Contains">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRangeAccess.prototype.</span>Contains
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Contains = function (token) {
    return this.tokens.indexOf(token) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenRangeAccess.prototype.GetTokens" id="apidoc.element.typescript.formatting.Shared.TokenRangeAccess.prototype.GetTokens">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenRangeAccess.prototype.</span>GetTokens
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GetTokens = function () {
    return this.tokens;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Shared.TokenSingleValueAccess.prototype" id="apidoc.module.typescript.formatting.Shared.TokenSingleValueAccess.prototype">module typescript.formatting.Shared.TokenSingleValueAccess.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenSingleValueAccess.prototype.Contains" id="apidoc.element.typescript.formatting.Shared.TokenSingleValueAccess.prototype.Contains">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenSingleValueAccess.prototype.</span>Contains
        <span class="apidocSignatureSpan">(tokenValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Contains = function (tokenValue) {
    return tokenValue === this.token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenSingleValueAccess.prototype.GetTokens" id="apidoc.element.typescript.formatting.Shared.TokenSingleValueAccess.prototype.GetTokens">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenSingleValueAccess.prototype.</span>GetTokens
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GetTokens = function () {
    return [this.token];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.Shared.TokenValuesAccess.prototype" id="apidoc.module.typescript.formatting.Shared.TokenValuesAccess.prototype">module typescript.formatting.Shared.TokenValuesAccess.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenValuesAccess.prototype.Contains" id="apidoc.element.typescript.formatting.Shared.TokenValuesAccess.prototype.Contains">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenValuesAccess.prototype.</span>Contains
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Contains = function (token) {
    return this.tokens.indexOf(token) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.Shared.TokenValuesAccess.prototype.GetTokens" id="apidoc.element.typescript.formatting.Shared.TokenValuesAccess.prototype.GetTokens">
        function <span class="apidocSignatureSpan">typescript.formatting.Shared.TokenValuesAccess.prototype.</span>GetTokens
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GetTokens = function () {
    return this.tokens;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.formatting.SmartIndenter" id="apidoc.module.typescript.formatting.SmartIndenter">module typescript.formatting.SmartIndenter</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.formatting.SmartIndenter.childStartsOnTheSameLineWithElseInIfStatement" id="apidoc.element.typescript.formatting.SmartIndenter.childStartsOnTheSameLineWithElseInIfStatement">
        function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>childStartsOnTheSameLineWithElseInIfStatement
        <span class="apidocSignatureSpan">(parent, child, childStartLine, sourceFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function childStartsOnTheSameLineWithElseInIfStatement(parent, child, childStartLine, sourceFile) {
    if (parent.kind === 210 /* IfStatement */ &amp;&amp; parent.elseStatement === child) {
        var elseKeyword = ts.findChildOfKind(parent, 81 /* ElseKeyword */, sourceFile);
        ts.Debug.assert(elseKeyword !== undefined);
        var elseKeywordStartLine = getStartLineAndCharacterForNode(elseKeyword, sourceFile).line;
        return elseKeywordStartLine === childStartLine;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.SmartIndenter.findFirstNonWhitespaceCharacterAndColumn" id="apidoc.element.typescript.formatting.SmartIndenter.findFirstNonWhitespaceCharacterAndColumn">
        function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>findFirstNonWhitespaceCharacterAndColumn
        <span class="apidocSignatureSpan">(startPos, endPos, sourceFile, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findFirstNonWhitespaceCharacterAndColumn(startPos, endPos, sourceFile, options) {
    var character = 0;
    var column = 0;
    for (var pos = startPos; pos &lt; endPos; pos++) {
        var ch = sourceFile.text.charCodeAt(pos);
        if (!ts.isWhiteSpaceSingleLine(ch)) {
            break;
        }
        if (ch === 9 /* tab */) {
            column += options.tabSize + (column % options.tabSize);
        }
        else {
            column++;
        }
        character++;
    }
    return { column: column, character: character };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.SmartIndenter.findFirstNonWhitespaceColumn" id="apidoc.element.typescript.formatting.SmartIndenter.findFirstNonWhitespaceColumn">
        function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>findFirstNonWhitespaceColumn
        <span class="apidocSignatureSpan">(startPos, endPos, sourceFile, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findFirstNonWhitespaceColumn(startPos, endPos, sourceFile, options) {
    return findFirstNonWhitespaceCharacterAndColumn(startPos, endPos, sourceFile, options).column;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.SmartIndenter.getBaseIndentation" id="apidoc.element.typescript.formatting.SmartIndenter.getBaseIndentation">
        function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>getBaseIndentation
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getBaseIndentation(options) {
    return options.baseIndentSize || 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.SmartIndenter.getIndentation" id="apidoc.element.typescript.formatting.SmartIndenter.getIndentation">
        function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>getIndentation
        <span class="apidocSignatureSpan">(position, sourceFile, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getIndentation(position, sourceFile, options) {
    if (position &gt; sourceFile.text.length) {
        return getBaseIndentation(options); // past EOF
    }
    // no indentation when the indent style is set to none,
    // so we can return fast
    if (options.indentStyle === ts.IndentStyle.None) {
        return 0;
    }
    var precedingToken = ts.findPrecedingToken(position, sourceFile);
    if (!precedingToken) {
        return getBaseIndentation(options);
    }
    // no indentation in string \regex\template literals
    var precedingTokenIsLiteral = ts.isStringOrRegularExpressionOrTemplateLiteral(precedingToken.kind);
    if (precedingTokenIsLiteral &amp;&amp; precedingToken.getStart(sourceFile) &lt;= position &amp;&amp; precedingToken.end &gt; position) {
        return 0;
    }
    var lineAtPosition = sourceFile.getLineAndCharacterOfPosition(position).line;
    // indentation is first non-whitespace character in a previous line
    // for block indentation, we should look for a line which contains something that's not
    // whitespace.
    if (options.indentStyle === ts.IndentStyle.Block) {
        // move backwards until we find a line with a non-whitespace character,
        // then find the first non-whitespace character for that line.
        var current_1 = position;
        while (current_1 &gt; 0) {
            var char = sourceFile.text.charCodeAt(current_1);
            if (!ts.isWhiteSpace(char)) {
                break;
            }
            current_1--;
        }
        var lineStart = ts.getLineStartPositionForPosition(current_1, sourceFile);
        return SmartIndenter.findFirstNonWhitespaceColumn(lineStart, current_1, sourceFile, options);
    }
    if (precedingToken.kind === 25 /* CommaToken */ &amp;&amp; precedingToken.parent.kind !== 193 /* BinaryExpression */) {
        // previous token is comma that separates items in list - find the previous item and try to derive indentation from it
        var actualIndentation = getActualIndentationForListItemBeforeComma(precedingToken, sourceFile, options);
        if (actualIndentation !== -1 /* Unknown */) {
            return actualIndentation;
        }
    }
    // try to find node that can contribute to indentation and includes 'position' starting from 'precedingToken'
    // if such node is found - compute initial indentation for 'position' inside this node
    var previous;
    var current = precedingToken;
    var currentStart;
    var indentationDelta;
    while (current) {
        if (ts.positionBelongsToNode(current, position, sourceFile) &amp;&amp; shouldIndentChildNode(current, previous)) {
            currentStart = getStartLineAndCharacterForNode(current, sourceFile);
            if (nextTokenIsCurlyBraceOnSameLineAsCursor(precedingToken, current, lineAtPosition, sourceFile)) {
                indentationDelta = 0;
            }
            else {
                indentationDelta = lineAtPosition !== currentStart.line ? options.indentSize : 0;
            }
            break;
        }
        // check if current node is a list item - if yes, take indentation from it
        var actualIndentation = getActualIndentationForListItem(current, sourceFile, options);
        if (actualIndentation !== -1 /* Unknown */) {
            return actualIndentation;
        }
        actualIndentation = getLineIndentationWhenExpressionIsInMultiLine(current, sourceFile, options);
        if (actualIndentation !== -1 /* Unknown */) {
            return actualIndentation + options.indentSize;
        }
        previous = current;
        current = current.parent;
    }
    if (!current) {
        // no parent was found - return the base indentation of the SourceFile
        return getBaseIndentation(options);
    }
    return getIndentationForNodeWorker(current, currentStart, /*ignoreActualIndentationRange*/ undefined, indentationDelta, sourceFile
, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.SmartIndenter.getIndentationForNode" id="apidoc.element.typescript.formatting.SmartIndenter.getIndentationForNode">
        function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>getIndentationForNode
        <span class="apidocSignatureSpan">(n, ignoreActualIndentationRange, sourceFile, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getIndentationForNode(n, ignoreActualIndentationRange, sourceFile, options) {
    var start = sourceFile.getLineAndCharacterOfPosition(n.getStart(sourceFile));
    return getIndentationForNodeWorker(n, start, ignoreActualIndentationRange, /*indentationDelta*/ 0, sourceFile, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.SmartIndenter.nodeWillIndentChild" id="apidoc.element.typescript.formatting.SmartIndenter.nodeWillIndentChild">
        function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>nodeWillIndentChild
        <span class="apidocSignatureSpan">(parent, child, indentByDefault)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeWillIndentChild(parent, child, indentByDefault) {
    var childKind = child ? child.kind : 0 /* Unknown */;
    switch (parent.kind) {
        case 211 /* DoStatement */:
        case 212 /* WhileStatement */:
        case 214 /* ForInStatement */:
        case 215 /* ForOfStatement */:
        case 213 /* ForStatement */:
        case 210 /* IfStatement */:
        case 227 /* FunctionDeclaration */:
        case 185 /* FunctionExpression */:
        case 150 /* MethodDeclaration */:
        case 186 /* ArrowFunction */:
        case 151 /* Constructor */:
        case 152 /* GetAccessor */:
        case 153 /* SetAccessor */:
            return childKind !== 206 /* Block */;
        case 243 /* ExportDeclaration */:
            return childKind !== 244 /* NamedExports */;
        case 237 /* ImportDeclaration */:
            return childKind !== 238 /* ImportClause */ ||
                (child.namedBindings &amp;&amp; child.namedBindings.kind !== 240 /* NamedImports */);
        case 248 /* JsxElement */:
            return childKind !== 251 /* JsxClosingElement */;
    }
    // No explicit rule for given nodes so the result will follow the default value argument
    return indentByDefault;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.formatting.SmartIndenter.shouldIndentChildNode" id="apidoc.element.typescript.formatting.SmartIndenter.shouldIndentChildNode">
        function <span class="apidocSignatureSpan">typescript.formatting.SmartIndenter.</span>shouldIndentChildNode
        <span class="apidocSignatureSpan">(parent, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldIndentChildNode(parent, child) {
    return nodeContentIsAlwaysIndented(parent.kind) || nodeWillIndentChild(parent, child, /*indentByDefault*/ false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.objectAllocator" id="apidoc.module.typescript.objectAllocator">module typescript.objectAllocator</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.objectAllocator.getIdentifierConstructor" id="apidoc.element.typescript.objectAllocator.getIdentifierConstructor">
        function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getIdentifierConstructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdentifierConstructor = function () { return IdentifierObject; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.objectAllocator.getNodeConstructor" id="apidoc.element.typescript.objectAllocator.getNodeConstructor">
        function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getNodeConstructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeConstructor = function () { return NodeObject; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.objectAllocator.getSignatureConstructor" id="apidoc.element.typescript.objectAllocator.getSignatureConstructor">
        function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getSignatureConstructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSignatureConstructor = function () { return SignatureObject; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.objectAllocator.getSourceFileConstructor" id="apidoc.element.typescript.objectAllocator.getSourceFileConstructor">
        function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getSourceFileConstructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceFileConstructor = function () { return SourceFileObject; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.objectAllocator.getSymbolConstructor" id="apidoc.element.typescript.objectAllocator.getSymbolConstructor">
        function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getSymbolConstructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSymbolConstructor = function () { return SymbolObject; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.objectAllocator.getTokenConstructor" id="apidoc.element.typescript.objectAllocator.getTokenConstructor">
        function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getTokenConstructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenConstructor = function () { return TokenObject; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.objectAllocator.getTypeConstructor" id="apidoc.element.typescript.objectAllocator.getTypeConstructor">
        function <span class="apidocSignatureSpan">typescript.objectAllocator.</span>getTypeConstructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTypeConstructor = function () { return TypeObject; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.performance" id="apidoc.module.typescript.performance">module typescript.performance</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.performance.disable" id="apidoc.element.typescript.performance.disable">
        function <span class="apidocSignatureSpan">typescript.performance.</span>disable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disable() {
    enabled = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.performance.enable" id="apidoc.element.typescript.performance.enable">
        function <span class="apidocSignatureSpan">typescript.performance.</span>enable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enable() {
    counts = ts.createMap();
    marks = ts.createMap();
    measures = ts.createMap();
    enabled = true;
    profilerStart = ts.timestamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.performance.forEachMeasure" id="apidoc.element.typescript.performance.forEachMeasure">
        function <span class="apidocSignatureSpan">typescript.performance.</span>forEachMeasure
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachMeasure(cb) {
    measures.forEach(function (measure, key) {
        cb(key, measure);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.performance.getCount" id="apidoc.element.typescript.performance.getCount">
        function <span class="apidocSignatureSpan">typescript.performance.</span>getCount
        <span class="apidocSignatureSpan">(markName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCount(markName) {
    return counts &amp;&amp; counts.get(markName) || 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.performance.getDuration" id="apidoc.element.typescript.performance.getDuration">
        function <span class="apidocSignatureSpan">typescript.performance.</span>getDuration
        <span class="apidocSignatureSpan">(measureName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDuration(measureName) {
    return measures &amp;&amp; measures.get(measureName) || 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.performance.mark" id="apidoc.element.typescript.performance.mark">
        function <span class="apidocSignatureSpan">typescript.performance.</span>mark
        <span class="apidocSignatureSpan">(markName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mark(markName) {
    if (enabled) {
        marks.set(markName, ts.timestamp());
        counts.set(markName, (counts.get(markName) || 0) + 1);
        profilerEvent(markName);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.performance.measure" id="apidoc.element.typescript.performance.measure">
        function <span class="apidocSignatureSpan">typescript.performance.</span>measure
        <span class="apidocSignatureSpan">(measureName, startMarkName, endMarkName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function measure(measureName, startMarkName, endMarkName) {
    if (enabled) {
        var end = endMarkName &amp;&amp; marks.get(endMarkName) || ts.timestamp();
        var start = startMarkName &amp;&amp; marks.get(startMarkName) || profilerStart;
        measures.set(measureName, (measures.get(measureName) || 0) + (end - start));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.scanner" id="apidoc.module.typescript.scanner">module typescript.scanner</a></h1>


    <h2>
        <a href="#apidoc.element.typescript.scanner.getStartPos" id="apidoc.element.typescript.scanner.getStartPos">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>getStartPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getStartPos = function () { return startPos; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.getText" id="apidoc.element.typescript.scanner.getText">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>getText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getText() {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.getTextPos" id="apidoc.element.typescript.scanner.getTextPos">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>getTextPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTextPos = function () { return pos; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.getToken" id="apidoc.element.typescript.scanner.getToken">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>getToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getToken = function () { return token; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.getTokenPos" id="apidoc.element.typescript.scanner.getTokenPos">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>getTokenPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenPos = function () { return tokenPos; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.getTokenText" id="apidoc.element.typescript.scanner.getTokenText">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>getTokenText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenText = function () { return text.substring(tokenPos, pos); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.getTokenValue" id="apidoc.element.typescript.scanner.getTokenValue">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>getTokenValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenValue = function () { return tokenValue; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.hasExtendedUnicodeEscape" id="apidoc.element.typescript.scanner.hasExtendedUnicodeEscape">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>hasExtendedUnicodeEscape
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasExtendedUnicodeEscape = function () { return hasExtendedUnicodeEscape; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.hasPrecedingLineBreak" id="apidoc.element.typescript.scanner.hasPrecedingLineBreak">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>hasPrecedingLineBreak
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasPrecedingLineBreak = function () { return precedingLineBreak; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.isIdentifier" id="apidoc.element.typescript.scanner.isIdentifier">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>isIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isIdentifier = function () { return token === 70 /* Identifier */ || token &gt; 106 /* LastReservedWord */; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.isReservedWord" id="apidoc.element.typescript.scanner.isReservedWord">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>isReservedWord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isReservedWord = function () { return token &gt;= 71 /* FirstReservedWord */ &amp;&amp; token &lt;= 106 /* LastReservedWord */; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.isUnterminated" id="apidoc.element.typescript.scanner.isUnterminated">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>isUnterminated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUnterminated = function () { return tokenIsUnterminated; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.lookAhead" id="apidoc.element.typescript.scanner.lookAhead">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>lookAhead
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookAhead(callback) {
    return speculationHelper(callback, /*isLookahead*/ true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.reScanGreaterToken" id="apidoc.element.typescript.scanner.reScanGreaterToken">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>reScanGreaterToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reScanGreaterToken() {
    if (token === 28 /* GreaterThanToken */) {
        if (text.charCodeAt(pos) === 62 /* greaterThan */) {
            if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {
                if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                    return pos += 3, token = 66 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
                }
                return pos += 2, token = 46 /* GreaterThanGreaterThanGreaterThanToken */;
            }
            if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                return pos += 2, token = 65 /* GreaterThanGreaterThanEqualsToken */;
            }
            pos++;
            return token = 45 /* GreaterThanGreaterThanToken */;
        }
        if (text.charCodeAt(pos) === 61 /* equals */) {
            pos++;
            return token = 30 /* GreaterThanEqualsToken */;
        }
    }
    return token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.reScanJsxToken" id="apidoc.element.typescript.scanner.reScanJsxToken">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>reScanJsxToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reScanJsxToken() {
    pos = tokenPos = startPos;
    return token = scanJsxToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.reScanSlashToken" id="apidoc.element.typescript.scanner.reScanSlashToken">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>reScanSlashToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reScanSlashToken() {
    if (token === 40 /* SlashToken */ || token === 62 /* SlashEqualsToken */) {
        var p = tokenPos + 1;
        var inEscape = false;
        var inCharacterClass = false;
        while (true) {
            // If we reach the end of a file, or hit a newline, then this is an unterminated
            // regex.  Report error and return what we have so far.
            if (p &gt;= end) {
                tokenIsUnterminated = true;
                error(ts.Diagnostics.Unterminated_regular_expression_literal);
                break;
            }
            var ch = text.charCodeAt(p);
            if (isLineBreak(ch)) {
                tokenIsUnterminated = true;
                error(ts.Diagnostics.Unterminated_regular_expression_literal);
                break;
            }
            if (inEscape) {
                // Parsing an escape character;
                // reset the flag and just advance to the next char.
                inEscape = false;
            }
            else if (ch === 47 /* slash */ &amp;&amp; !inCharacterClass) {
                // A slash within a character class is permissible,
                // but in general it signals the end of the regexp literal.
                p++;
                break;
            }
            else if (ch === 91 /* openBracket */) {
                inCharacterClass = true;
            }
            else if (ch === 92 /* backslash */) {
                inEscape = true;
            }
            else if (ch === 93 /* closeBracket */) {
                inCharacterClass = false;
            }
            p++;
        }
        while (p &lt; end &amp;&amp; isIdentifierPart(text.charCodeAt(p), languageVersion)) {
            p++;
        }
        pos = p;
        tokenValue = text.substring(tokenPos, pos);
        token = 11 /* RegularExpressionLiteral */;
    }
    return token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.reScanTemplateToken" id="apidoc.element.typescript.scanner.reScanTemplateToken">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>reScanTemplateToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reScanTemplateToken() {
    ts.Debug.assert(token === 17 /* CloseBraceToken */, "'reScanTemplateToken' should only be called on a '}'");
    pos = tokenPos;
    return token = scanTemplateAndSetTokenValue();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.scan" id="apidoc.element.typescript.scanner.scan">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>scan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scan() {
    startPos = pos;
    hasExtendedUnicodeEscape = false;
    precedingLineBreak = false;
    tokenIsUnterminated = false;
    while (true) {
        tokenPos = pos;
        if (pos &gt;= end) {
            return token = 1 /* EndOfFileToken */;
        }
        var ch = text.charCodeAt(pos);
        // Special handling for shebang
        if (ch === 35 /* hash */ &amp;&amp; pos === 0 &amp;&amp; isShebangTrivia(text, pos)) {
            pos = scanShebangTrivia(text, pos);
            if (skipTrivia) {
                continue;
            }
            else {
                return token = 6 /* ShebangTrivia */;
            }
        }
        switch (ch) {
            case 10 /* lineFeed */:
            case 13 /* carriageReturn */:
                precedingLineBreak = true;
                if (skipTrivia) {
                    pos++;
                    continue;
                }
                else {
                    if (ch === 13 /* carriageReturn */ &amp;&amp; pos + 1 &lt; end &amp;&amp; text.charCodeAt(pos + 1) === 10 /* lineFeed */) {
                        // consume both CR and LF
                        pos += 2;
                    }
                    else {
                        pos++;
                    }
                    return token = 4 /* NewLineTrivia */;
                }
            case 9 /* tab */:
            case 11 /* verticalTab */:
            case 12 /* formFeed */:
            case 32 /* space */:
                if (skipTrivia) {
                    pos++;
                    continue;
                }
                else {
                    while (pos &lt; end &amp;&amp; isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
                        pos++;
                    }
                    return token = 5 /* WhitespaceTrivia */;
                }
            case 33 /* exclamation */:
                if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                    if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                        return pos += 3, token = 34 /* ExclamationEqualsEqualsToken */;
                    }
                    return pos += 2, token = 32 /* ExclamationEqualsToken */;
                }
                pos++;
                return token = 50 /* ExclamationToken */;
            case 34 /* doubleQuote */:
            case 39 /* singleQuote */:
                tokenValue = scanString();
                return token = 9 /* StringLiteral */;
            case 96 /* backtick */:
                return token = scanTemplateAndSetTokenValue();
            case 37 /* percent */:
                if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                    return pos += 2, token = 63 /* PercentEqualsToken */;
                }
                pos++;
                return token = 41 /* PercentToken */;
            case 38 /* ampersand */:
                if (text.charCodeAt(pos + 1) === 38 /* ampersand */) {
                    return pos += 2, token = 52 /* AmpersandAmpersandToken */;
                }
                if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                    return pos += 2, token = 67 /* AmpersandEqualsToken */;
                }
                pos++;
                return token = 47 /* AmpersandToken */;
            case 40 /* openParen */:
                pos++;
                return token = 18 /* OpenParenToken */;
            case 41 /* closeParen */:
                pos++;
                return token = 19 /* CloseParenToken */;
            case 42 /* asterisk */:
                if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                    return pos += 2, token = 60 /* AsteriskEqualsToken */;
                }
                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                    if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                        return pos += 3, token = 61 /* AsteriskAsteriskEqualsToken */;
                    }
                    return pos += 2, token = 39 /* AsteriskAsteriskToken */;
                }
                pos++;
                return token = 38 /* Aster ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.scanJSDocToken" id="apidoc.element.typescript.scanner.scanJSDocToken">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>scanJSDocToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scanJSDocToken() {
    if (pos &gt;= end) {
        return token = 1 /* EndOfFileToken */;
    }
    startPos = pos;
    tokenPos = pos;
    var ch = text.charCodeAt(pos);
    switch (ch) {
        case 9 /* tab */:
        case 11 /* verticalTab */:
        case 12 /* formFeed */:
        case 32 /* space */:
            while (pos &lt; end &amp;&amp; isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
                pos++;
            }
            return token = 5 /* WhitespaceTrivia */;
        case 64 /* at */:
            pos++;
            return token = 56 /* AtToken */;
        case 10 /* lineFeed */:
        case 13 /* carriageReturn */:
            pos++;
            return token = 4 /* NewLineTrivia */;
        case 42 /* asterisk */:
            pos++;
            return token = 38 /* AsteriskToken */;
        case 123 /* openBrace */:
            pos++;
            return token = 16 /* OpenBraceToken */;
        case 125 /* closeBrace */:
            pos++;
            return token = 17 /* CloseBraceToken */;
        case 91 /* openBracket */:
            pos++;
            return token = 20 /* OpenBracketToken */;
        case 93 /* closeBracket */:
            pos++;
            return token = 21 /* CloseBracketToken */;
        case 61 /* equals */:
            pos++;
            return token = 57 /* EqualsToken */;
        case 44 /* comma */:
            pos++;
            return token = 25 /* CommaToken */;
        case 46 /* dot */:
            pos++;
            return token = 22 /* DotToken */;
    }
    if (isIdentifierStart(ch, 5 /* Latest */)) {
        pos++;
        while (isIdentifierPart(text.charCodeAt(pos), 5 /* Latest */) &amp;&amp; pos &lt; end) {
            pos++;
        }
        return token = 70 /* Identifier */;
    }
    else {
        return pos += 1, token = 0 /* Unknown */;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.scanJsxAttributeValue" id="apidoc.element.typescript.scanner.scanJsxAttributeValue">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>scanJsxAttributeValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scanJsxAttributeValue() {
    startPos = pos;
    switch (text.charCodeAt(pos)) {
        case 34 /* doubleQuote */:
        case 39 /* singleQuote */:
            tokenValue = scanString(/*allowEscapes*/ false);
            return token = 9 /* StringLiteral */;
        default:
            // If this scans anything other than `{`, it's a parse error.
            return scan();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.scanJsxIdentifier" id="apidoc.element.typescript.scanner.scanJsxIdentifier">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>scanJsxIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scanJsxIdentifier() {
    if (tokenIsIdentifierOrKeyword(token)) {
        var firstCharPosition = pos;
        while (pos &lt; end) {
            var ch = text.charCodeAt(pos);
            if (ch === 45 /* minus */ || ((firstCharPosition === pos) ? isIdentifierStart(ch, languageVersion) : isIdentifierPart
(ch, languageVersion))) {
                pos++;
            }
            else {
                break;
            }
        }
        tokenValue += text.substr(firstCharPosition, pos - firstCharPosition);
    }
    return token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.scanJsxToken" id="apidoc.element.typescript.scanner.scanJsxToken">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>scanJsxToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scanJsxToken() {
    startPos = tokenPos = pos;
    if (pos &gt;= end) {
        return token = 1 /* EndOfFileToken */;
    }
    var char = text.charCodeAt(pos);
    if (char === 60 /* lessThan */) {
        if (text.charCodeAt(pos + 1) === 47 /* slash */) {
            pos += 2;
            return token = 27 /* LessThanSlashToken */;
        }
        pos++;
        return token = 26 /* LessThanToken */;
    }
    if (char === 123 /* openBrace */) {
        pos++;
        return token = 16 /* OpenBraceToken */;
    }
    while (pos &lt; end) {
        pos++;
        char = text.charCodeAt(pos);
        if ((char === 123 /* openBrace */) || (char === 60 /* lessThan */)) {
            break;
        }
    }
    return token = 10 /* JsxText */;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.scanRange" id="apidoc.element.typescript.scanner.scanRange">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>scanRange
        <span class="apidocSignatureSpan">(start, length, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scanRange(start, length, callback) {
    var saveEnd = end;
    var savePos = pos;
    var saveStartPos = startPos;
    var saveTokenPos = tokenPos;
    var saveToken = token;
    var savePrecedingLineBreak = precedingLineBreak;
    var saveTokenValue = tokenValue;
    var saveHasExtendedUnicodeEscape = hasExtendedUnicodeEscape;
    var saveTokenIsUnterminated = tokenIsUnterminated;
    setText(text, start, length);
    var result = callback();
    end = saveEnd;
    pos = savePos;
    startPos = saveStartPos;
    tokenPos = saveTokenPos;
    token = saveToken;
    precedingLineBreak = savePrecedingLineBreak;
    tokenValue = saveTokenValue;
    hasExtendedUnicodeEscape = saveHasExtendedUnicodeEscape;
    tokenIsUnterminated = saveTokenIsUnterminated;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.setLanguageVariant" id="apidoc.element.typescript.scanner.setLanguageVariant">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>setLanguageVariant
        <span class="apidocSignatureSpan">(variant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setLanguageVariant(variant) {
    languageVariant = variant;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.setOnError" id="apidoc.element.typescript.scanner.setOnError">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>setOnError
        <span class="apidocSignatureSpan">(errorCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOnError(errorCallback) {
    onError = errorCallback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.setScriptTarget" id="apidoc.element.typescript.scanner.setScriptTarget">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>setScriptTarget
        <span class="apidocSignatureSpan">(scriptTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setScriptTarget(scriptTarget) {
    languageVersion = scriptTarget;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.setText" id="apidoc.element.typescript.scanner.setText">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>setText
        <span class="apidocSignatureSpan">(newText, start, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setText(newText, start, length) {
    text = newText || "";
    end = length === undefined ? text.length : start + length;
    setTextPos(start || 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.setTextPos" id="apidoc.element.typescript.scanner.setTextPos">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>setTextPos
        <span class="apidocSignatureSpan">(textPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTextPos(textPos) {
    ts.Debug.assert(textPos &gt;= 0);
    pos = textPos;
    startPos = textPos;
    tokenPos = textPos;
    token = 0 /* Unknown */;
    precedingLineBreak = false;
    tokenValue = undefined;
    hasExtendedUnicodeEscape = false;
    tokenIsUnterminated = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.scanner.tryScan" id="apidoc.element.typescript.scanner.tryScan">
        function <span class="apidocSignatureSpan">typescript.scanner.</span>tryScan
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryScan(callback) {
    return speculationHelper(callback, /*isLookahead*/ false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.typescript.sys" id="apidoc.module.typescript.sys">module typescript.sys</a></h1>




    <h2>
        <a href="#apidoc.element.typescript.sys.clearTimeout" id="apidoc.element.typescript.sys.clearTimeout">
        function <span class="apidocSignatureSpan">typescript.sys.</span>clearTimeout
        <span class="apidocSignatureSpan">(timer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearTimeout = function (timer) {
  if (timer &amp;&amp; (timer[kOnTimeout] || timer._onTimeout)) {
    timer[kOnTimeout] = timer._onTimeout = null;
    if (timer instanceof Timeout) {
      timer.close(); // for after === 0
    } else {
      unenroll(timer);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.createDirectory" id="apidoc.element.typescript.sys.createDirectory">
        function <span class="apidocSignatureSpan">typescript.sys.</span>createDirectory
        <span class="apidocSignatureSpan">(directoryName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDirectory = function (directoryName) {
    if (!nodeSystem.directoryExists(directoryName)) {
        _fs.mkdirSync(directoryName);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.createHash" id="apidoc.element.typescript.sys.createHash">
        function <span class="apidocSignatureSpan">typescript.sys.</span>createHash
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createHash = function (data) {
    var hash = _crypto.createHash("md5");
    hash.update(data);
    return hash.digest("hex");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.directoryExists" id="apidoc.element.typescript.sys.directoryExists">
        function <span class="apidocSignatureSpan">typescript.sys.</span>directoryExists
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function directoryExists(path) {
    return fileSystemEntryExists(path, 1 /* Directory */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.exit" id="apidoc.element.typescript.sys.exit">
        function <span class="apidocSignatureSpan">typescript.sys.</span>exit
        <span class="apidocSignatureSpan">(exitCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exit = function (exitCode) {
    process.exit(exitCode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.fileExists" id="apidoc.element.typescript.sys.fileExists">
        function <span class="apidocSignatureSpan">typescript.sys.</span>fileExists
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fileExists(path) {
    return fileSystemEntryExists(path, 0 /* File */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.getCurrentDirectory" id="apidoc.element.typescript.sys.getCurrentDirectory">
        function <span class="apidocSignatureSpan">typescript.sys.</span>getCurrentDirectory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCurrentDirectory = function () {
    return process.cwd();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.getDirectories" id="apidoc.element.typescript.sys.getDirectories">
        function <span class="apidocSignatureSpan">typescript.sys.</span>getDirectories
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDirectories(path) {
    return ts.filter(_fs.readdirSync(path), function (dir) { return fileSystemEntryExists(ts.combinePaths(path, dir), 1 /* Directory
 */); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.getEnvironmentVariable" id="apidoc.element.typescript.sys.getEnvironmentVariable">
        function <span class="apidocSignatureSpan">typescript.sys.</span>getEnvironmentVariable
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEnvironmentVariable = function (name) {
    return process.env[name] || "";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.getExecutingFilePath" id="apidoc.element.typescript.sys.getExecutingFilePath">
        function <span class="apidocSignatureSpan">typescript.sys.</span>getExecutingFilePath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExecutingFilePath = function () {
    return __filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.getFileSize" id="apidoc.element.typescript.sys.getFileSize">
        function <span class="apidocSignatureSpan">typescript.sys.</span>getFileSize
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFileSize = function (path) {
    try {
        var stat = _fs.statSync(path);
        if (stat.isFile()) {
            return stat.size;
        }
    }
    catch (e) { }
    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.getMemoryUsage" id="apidoc.element.typescript.sys.getMemoryUsage">
        function <span class="apidocSignatureSpan">typescript.sys.</span>getMemoryUsage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMemoryUsage = function () {
    if (global.gc) {
        global.gc();
    }
    return process.memoryUsage().heapUsed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.getModifiedTime" id="apidoc.element.typescript.sys.getModifiedTime">
        function <span class="apidocSignatureSpan">typescript.sys.</span>getModifiedTime
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModifiedTime = function (path) {
    try {
        return _fs.statSync(path).mtime;
    }
    catch (e) {
        return undefined;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.readDirectory" id="apidoc.element.typescript.sys.readDirectory">
        function <span class="apidocSignatureSpan">typescript.sys.</span>readDirectory
        <span class="apidocSignatureSpan">(path, extensions, excludes, includes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readDirectory(path, extensions, excludes, includes) {
    return ts.matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, process.cwd(), getAccessibleFileSystemEntries
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.readFile" id="apidoc.element.typescript.sys.readFile">
        function <span class="apidocSignatureSpan">typescript.sys.</span>readFile
        <span class="apidocSignatureSpan">(fileName, _encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFile(fileName, _encoding) {
    if (!fileExists(fileName)) {
        return undefined;
    }
    var buffer = _fs.readFileSync(fileName);
    var len = buffer.length;
    if (len &gt;= 2 &amp;&amp; buffer[0] === 0xFE &amp;&amp; buffer[1] === 0xFF) {
        // Big endian UTF-16 byte order mark detected. Since big endian is not supported by node.js,
        // flip all byte pairs and treat as little endian.
        len &amp;= ~1;
        for (var i = 0; i &lt; len; i += 2) {
            var temp = buffer[i];
            buffer[i] = buffer[i + 1];
            buffer[i + 1] = temp;
        }
        return buffer.toString("utf16le", 2);
    }
    if (len &gt;= 2 &amp;&amp; buffer[0] === 0xFF &amp;&amp; buffer[1] === 0xFE) {
        // Little endian UTF-16 byte order mark detected
        return buffer.toString("utf16le", 2);
    }
    if (len &gt;= 3 &amp;&amp; buffer[0] === 0xEF &amp;&amp; buffer[1] === 0xBB &amp;&amp; buffer[2] === 0xBF) {
        // UTF-8 byte order mark detected
        return buffer.toString("utf8", 3);
    }
    // Default is UTF-8 with no byte order mark
    return buffer.toString("utf8");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.realpath" id="apidoc.element.typescript.sys.realpath">
        function <span class="apidocSignatureSpan">typescript.sys.</span>realpath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">realpath = function (path) {
    return _fs.realpathSync(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.resolvePath" id="apidoc.element.typescript.sys.resolvePath">
        function <span class="apidocSignatureSpan">typescript.sys.</span>resolvePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolvePath = function (path) {
    return _path.resolve(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.setTimeout" id="apidoc.element.typescript.sys.setTimeout">
        function <span class="apidocSignatureSpan">typescript.sys.</span>setTimeout
        <span class="apidocSignatureSpan">(callback, after, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeout = function (callback, after, arg1, arg2, arg3) {
  if (typeof callback !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args;
  if (len === 3) {
    args = [arg1];
  } else if (len === 4) {
    args = [arg1, arg2];
  } else if (len &gt; 4) {
    args = [arg1, arg2, arg3];
    for (var i = 5; i &lt; len; i++)
      // extend array dynamically, makes .apply run much faster in v6.0.0
      args[i - 2] = arguments[i];
  }

  return createSingleTimeout(callback, after, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.tryEnableSourceMapsForHost" id="apidoc.element.typescript.sys.tryEnableSourceMapsForHost">
        function <span class="apidocSignatureSpan">typescript.sys.</span>tryEnableSourceMapsForHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryEnableSourceMapsForHost = function () {
    try {
        require("source-map-support").install();
    }
    catch (e) {
        // Could not enable source maps.
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.watchDirectory" id="apidoc.element.typescript.sys.watchDirectory">
        function <span class="apidocSignatureSpan">typescript.sys.</span>watchDirectory
        <span class="apidocSignatureSpan">(directoryName, callback, recursive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watchDirectory = function (directoryName, callback, recursive) {
    // Node 4.0 `fs.watch` function supports the "recursive" option on both OSX and Windows
    // (ref: https://github.com/nodejs/node/pull/2649 and https://github.com/Microsoft/TypeScript/issues/4643)
    var options;
    if (!directoryExists(directoryName)) {
        // do nothing if target folder does not exist
        return noOpFileWatcher;
    }
    if (isNode4OrLater &amp;&amp; (process.platform === "win32" || process.platform === "darwin")) {
        options = { persistent: true, recursive: !!recursive };
    }
    else {
        options = { persistent: true };
    }
    return _fs.watch(directoryName, options, function (eventName, relativeFileName) {
        // In watchDirectory we only care about adding and removing files (when event name is
        // "rename"); changes made within files are handled by corresponding fileWatchers (when
        // event name is "change")
        if (eventName === "rename") {
            // When deleting a file, the passed baseFileName is null
            callback(!relativeFileName ? relativeFileName : ts.normalizePath(ts.combinePaths(directoryName, relativeFileName)));
        }
        ;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.watchFile" id="apidoc.element.typescript.sys.watchFile">
        function <span class="apidocSignatureSpan">typescript.sys.</span>watchFile
        <span class="apidocSignatureSpan">(fileName, callback, pollingInterval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watchFile = function (fileName, callback, pollingInterval) {
    if (useNonPollingWatchers) {
        var watchedFile_1 = watchedFileSet.addFile(fileName, callback);
        return {
            close: function () { return watchedFileSet.removeFile(watchedFile_1); }
        };
    }
    else {
        _fs.watchFile(fileName, { persistent: true, interval: pollingInterval || 250 }, fileChanged);
        return {
            close: function () { return _fs.unwatchFile(fileName, fileChanged); }
        };
    }
    function fileChanged(curr, prev) {
        if (+curr.mtime &lt;= +prev.mtime) {
            return;
        }
        callback(fileName);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.write" id="apidoc.element.typescript.sys.write">
        function <span class="apidocSignatureSpan">typescript.sys.</span>write
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (s) {
    process.stdout.write(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.typescript.sys.writeFile" id="apidoc.element.typescript.sys.writeFile">
        function <span class="apidocSignatureSpan">typescript.sys.</span>writeFile
        <span class="apidocSignatureSpan">(path, data, writeBom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function (path, data, writeBom) {
    var directoryPath = ts.getDirectoryPath(ts.normalizeSlashes(path));
    if (directoryPath &amp;&amp; !sys.directoryExists(directoryPath)) {
        recursiveCreateDirectory(directoryPath, sys);
    }
    originalWriteFile_1.call(sys, path, data, writeBom);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>